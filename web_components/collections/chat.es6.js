/*! Copyright (c) 2019 CommonTime Ltd */
/*! Build date: Tue Oct 29 2019 11:35:57 GMT+0000 (Greenwich Mean Time) */
/*! ================================= */

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 211);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var prop_1 = __webpack_require__(80);
exports.prop = prop_1.prop;
var customProps_1 = __webpack_require__(79);
exports.Stroolean = customProps_1.Stroolean;
exports.NullableNumber = customProps_1.NullableNumber;
var CTBaseComponent_1 = __webpack_require__(44);
exports.CTBaseComponent = CTBaseComponent_1.CTBaseComponent;
var CTLayerComponent_1 = __webpack_require__(77);
exports.CTLayerComponent = CTLayerComponent_1.CTLayerComponent;
var BaseLayer_1 = __webpack_require__(76);
exports.BaseLayer = BaseLayer_1.BaseLayer;
var Logger_1 = __webpack_require__(17);
exports.Logger = Logger_1.Logger;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var AppMode_1 = __webpack_require__(95);
exports.AppMode = AppMode_1.AppMode;
var Alert_1 = __webpack_require__(46);
exports.DefaultAlerts = Alert_1.DefaultAlerts;
var ChatEntryType_1 = __webpack_require__(96);
exports.ChatEntryType = ChatEntryType_1.ChatEntryType;
var ChatRole_1 = __webpack_require__(97);
exports.ChatRole = ChatRole_1.ChatRole;
var ConnectionStatus_1 = __webpack_require__(98);
exports.ConnectionStatus = ConnectionStatus_1.ConnectionStatus;
var DisconnectionStatus_1 = __webpack_require__(99);
exports.DisconnectionStatus = DisconnectionStatus_1.DisconnectionStatus;
var Icons_1 = __webpack_require__(47);
exports.Icons = Icons_1.Icons;
var RoomRole_1 = __webpack_require__(100);
exports.RoomRole = RoomRole_1.RoomRole;
var UserAdditionalDetailsType_1 = __webpack_require__(101);
exports.UserAdditionalDetailsType = UserAdditionalDetailsType_1.UserAdditionalDetailsType;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Moment = __webpack_require__(205);
const deep_diff_1 = __webpack_require__(195);
const handlers_1 = __webpack_require__(32);
const Keys_1 = __webpack_require__(20);
// tslint:disable no-any
var NameFormat;
(function (NameFormat) {
    NameFormat[NameFormat["PREFIX_INITIAL_LAST"] = 0] = "PREFIX_INITIAL_LAST";
    NameFormat[NameFormat["PREFIX_FIRST_LAST"] = 1] = "PREFIX_FIRST_LAST";
})(NameFormat = exports.NameFormat || (exports.NameFormat = {}));
exports.safeMoment = Moment;
function setLocale(locale) {
    exports.safeMoment.locale(locale);
}
exports.setLocale = setLocale;
function isDesktop() {
    return (typeof window.orientation === "undefined");
}
exports.isDesktop = isDesktop;
function isMobile() {
    return (typeof window.orientation !== "undefined");
}
exports.isMobile = isMobile;
function isAndroid() {
    const win = window;
    if (win.device && win.device.platform) {
        return win.device.platform.toLowerCase() === "android";
    }
    else {
        if (win.cti) {
            return win.cti.store.env.platform.name === "android";
        }
    }
    return false;
}
exports.isAndroid = isAndroid;
function normalizeLocalFilePaths(path) {
    if (window.Ionic && window.Ionic.normalizeURL)
        return window.Ionic.normalizeURL(path);
    return path;
}
exports.normalizeLocalFilePaths = normalizeLocalFilePaths;
function padLeft(value, length, char = " ") {
    let result = value;
    const lengthDiff = (length - value.length);
    if (lengthDiff > 0) {
        result = Array(lengthDiff + 1).join(char) + result;
    }
    return result;
}
exports.padLeft = padLeft;
function generateRandomSixString() {
    let firstPart = (Math.random() * 46656) | 0;
    let secondPart = (Math.random() * 46656) | 0;
    firstPart = ("000" + firstPart.toString(36)).slice(-3);
    secondPart = ("000" + secondPart.toString(36)).slice(-3);
    return firstPart + secondPart;
}
exports.generateRandomSixString = generateRandomSixString;
function tokenReplace(input, data) {
    if (!input)
        return "";
    if (data === undefined || data === null)
        return input;
    if (input.indexOf("${") === -1)
        return input;
    const getPropertyValue = (entity, propertyPath) => {
        const parts = propertyPath.split(".");
        do {
        } while (parts.length && (entity = entity[parts.shift()]));
        return entity;
    };
    return input.replace(/\${([^{}]*)}/g, (token, propertyPath) => {
        const replacement = getPropertyValue(data, propertyPath);
        return typeof replacement === "string" || typeof replacement === "number" ? replacement : token;
    });
}
exports.tokenReplace = tokenReplace;
function jidsMatch(jidA, jidB, caseSensitive = false) {
    if (!caseSensitive) {
        jidA = (jidA || "").toLowerCase();
        jidB = (jidB || "").toLowerCase();
    }
    return (jidA === jidB);
}
exports.jidsMatch = jidsMatch;
function formatDate(date, format) {
    if (date === null || date === undefined)
        return "";
    return Moment(date).format(format);
}
exports.formatDate = formatDate;
function formatDateForTimeOrDate(date, includeTodayLabel = false, showSeconds = false, translationProvider = null) {
    if (date === null || date === undefined)
        return "";
    const offset = daysFromNow(date);
    if (offset === 0) {
        let todayLabel = "";
        if (includeTodayLabel) {
            const key = Keys_1.CommonI18nKeys.TODAY;
            todayLabel = translationProvider && translationProvider.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(key)) || key.toString();
        }
        return (includeTodayLabel && `${todayLabel}, ` || "") + getFriendlyTime(date, showSeconds);
    }
    return `${getFriendlyDate(date, translationProvider)} ${getFriendlyTime(date, showSeconds)}`;
}
exports.formatDateForTimeOrDate = formatDateForTimeOrDate;
function daysFromNow(date) {
    const now = new exports.safeMoment().startOf("day");
    const other = new exports.safeMoment(date).startOf("day");
    return other.diff(now, "days");
}
exports.daysFromNow = daysFromNow;
function getFriendlyDate(date, translationProvider = null) {
    const offset = daysFromNow(date);
    if (offset === 0 || offset === -1) {
        const key = offset === 0
            ? Keys_1.CommonI18nKeys.TODAY
            : Keys_1.CommonI18nKeys.YESTERDAY;
        return translationProvider && translationProvider.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(key)) || key.toString();
    }
    return exports.safeMoment(date).format("L");
}
exports.getFriendlyDate = getFriendlyDate;
function getFriendlyTime(date, showSeconds = false) {
    const format = showSeconds ? "LTS" : "LT";
    return exports.safeMoment(date).format(format);
}
exports.getFriendlyTime = getFriendlyTime;
function prettyDuration(timespan) {
    if (timespan < 1000)
        return "< 1s";
    const seconds = Math.trunc(timespan / 1000);
    if (seconds < 60)
        return `${seconds}s`;
    const minutes = Math.trunc(timespan / 1000 / 60);
    const remainingSeconds = Math.trunc((timespan - (minutes * 60 * 1000)) / 1000);
    if (minutes < 60)
        return `${minutes}m` + (remainingSeconds && ` ${remainingSeconds}s` || "");
    const hours = Math.trunc(timespan / 1000 / 60 / 60);
    const remainingMinutes = Math.trunc((timespan - (hours * 60 * 60 * 1000)) / 1000 / 60);
    if (hours < 24)
        return `${hours}h` + (remainingMinutes && ` ${remainingMinutes}m` || "");
    const days = Math.trunc(timespan / 1000 / 60 / 60 / 24);
    return `${days} days`;
}
exports.prettyDuration = prettyDuration;
function formatUserName(user, format) {
    if (!user)
        return "";
    switch (format) {
        case NameFormat.PREFIX_INITIAL_LAST:
            return `${user.prefix || ""} ${(user.firstName || "").substr(0, 1)} ${user.lastName || ""}`.trim() || user.username || user.jid || "";
        case NameFormat.PREFIX_FIRST_LAST:
            return `${user.prefix || ""} ${user.firstName || ""} ${user.lastName || ""}`.trim() || user.username || user.jid || "";
    }
}
exports.formatUserName = formatUserName;
function sortUsersByName(users) {
    return deepCloneArray(users).sort((a, b) => {
        const lnA = a.lastName || "";
        const lnB = b.lastName || "";
        const lnCompare = lnA.localeCompare(lnB);
        if (lnCompare !== 0)
            return lnCompare;
        const fnA = a.firstName || "";
        const fnB = b.firstName || "";
        return fnA.localeCompare(fnB);
    });
}
exports.sortUsersByName = sortUsersByName;
function enumFromString(stringValue) {
    return stringValue || null;
}
exports.enumFromString = enumFromString;
function deepCloneArray(array) {
    return array.map(x => {
        if (x instanceof Array)
            return deepCloneArray(x);
        else if (typeof (x) === "object")
            return Object.assign({}, x);
        else
            return x;
    });
}
exports.deepCloneArray = deepCloneArray;
function uniqueArrayItems(array, propToCompare = x => x) {
    const keys = [];
    const unique = [];
    array.forEach(x => {
        const key = propToCompare(x);
        if (keys.includes(key))
            return;
        keys.push(key);
        unique.push(x);
    });
    return unique;
}
exports.uniqueArrayItems = uniqueArrayItems;
function groupArrayItemsByKey(array, keyProp = x => x) {
    return array.reduce((acc, cur) => {
        const key = keyProp(cur);
        let group = null;
        if (acc[key]) {
            group = acc[key];
        }
        else {
            group = [];
            acc[key] = group;
        }
        group.push(cur);
        return acc;
    }, {});
}
exports.groupArrayItemsByKey = groupArrayItemsByKey;
function deepCloneObject(obj) {
    if (obj === null)
        return null;
    if (obj === undefined)
        return undefined;
    if (typeof (obj) !== "object")
        return obj;
    return JSON.parse(JSON.stringify(obj));
}
exports.deepCloneObject = deepCloneObject;
function isObject(item) {
    return (item && typeof item === "object" && !Array.isArray(item));
}
exports.isObject = isObject;
function mergeDeep(target, ...sources) {
    if (!sources.length)
        return target;
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key])
                    Object.assign(target, { [key]: {} });
                mergeDeep(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return mergeDeep(target, ...sources);
}
exports.mergeDeep = mergeDeep;
function getMessageType(message) {
    if ("data" in message && typeof (message.data) === "object") {
        const dataKeys = Object.keys(message.data).filter(x => x !== "$attributes");
        if (dataKeys.length > 0) {
            return dataKeys[0];
        }
    }
    return handlers_1.BaseMessageType.XmppChat;
}
exports.getMessageType = getMessageType;
function parseMessagePayload(message, messageType) {
    const messageClone = deepCloneObject(message);
    if (!messageType)
        messageClone;
    if (messageClone.data && typeof (messageClone.data[messageType.toString()]) === "string") {
        messageClone.data[messageType.toString()] = JSON.parse(messageClone.data[messageType.toString()]);
    }
    return messageClone;
}
exports.parseMessagePayload = parseMessagePayload;
function getMessageContentForDebug(message) {
    const messageType = getMessageType(message);
    if (messageType === null)
        return "";
    if (messageType === handlers_1.BaseMessageType.XmppChat) {
        return {
            [messageType]: {
                body: message.body,
                attachments: message.attachments
            }
        };
    }
    if (message.data && messageType in message.data) {
        const parsedMessage = parseMessagePayload(message, messageType);
        return {
            [messageType]: parsedMessage.data[messageType]
        };
    }
    return "";
}
exports.getMessageContentForDebug = getMessageContentForDebug;
function getUsernameFromJid(jid) {
    if (jid.indexOf("@") > -1) {
        return jid.substring(0, jid.indexOf("@"));
    }
    else
        return jid;
}
exports.getUsernameFromJid = getUsernameFromJid;
function findRoomJidInMessage(message, mucHost) {
    const roomJidCandidateProperties = ["recipient_id", "sender_id", "jid"];
    for (let i = 0; i < roomJidCandidateProperties.length; i++) {
        const prop = roomJidCandidateProperties[i];
        if (message[prop]) {
            const value = (message[prop] || "").toString()
                .toLowerCase() // make checking case-insensitive
                .split("/")[0]; // remove any "resource" part of the jid
            if (value.endsWith(mucHost.toLowerCase()))
                return value;
        }
    }
    return null;
}
exports.findRoomJidInMessage = findRoomJidInMessage;
function validateVCardObject(obj) {
    return obj && Object.keys(obj).length > 0;
}
exports.validateVCardObject = validateVCardObject;
function randomNumberBetween(start, end) {
    return Math.floor(Math.random() * end) + start;
}
exports.randomNumberBetween = randomNumberBetween;
function sleep(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    });
}
exports.sleep = sleep;
function getDiffs(lhs, rhs) {
    if (lhs === undefined || rhs === undefined)
        return [];
    const diffs = deep_diff_1.default(lhs, rhs);
    return diffs.map(x => {
        const path = x.path.reduce((acc, cur) => {
            if (typeof (cur) === "number") {
                return `${acc}[${cur}]`;
            }
            else {
                return `${acc}.${cur}`;
            }
        }, "").replace(".", "");
        if (path === "_id" || path === "_rev")
            return null;
        let type = "";
        let added = false;
        let deleted = false;
        let lhs = null;
        let rhs = null;
        if (x.kind === "A" && x.item.kind === "N") {
            type = `ADDED [${x.index}]`;
            added = true;
            rhs = x.item.rhs;
        }
        else if (x.kind === "A" && x.item.kind === "D") {
            type = `DELETED [${x.index}]`;
            deleted = true;
            rhs = x.item.lhs;
        }
        else if (x.kind === "N") {
            type = "ADDED";
            added = true;
            rhs = x.rhs;
        }
        else if (x.kind === "D") {
            type = "DELETED";
            deleted = true;
            rhs = x.lhs;
        }
        else {
            type = "EDITED";
            lhs = x.lhs;
            rhs = x.rhs;
        }
        return {
            type,
            added,
            deleted,
            path,
            lhs,
            rhs
        };
    }).filter(x => x !== null);
}
exports.getDiffs = getDiffs;
/**
 * Returns the value of the supplied CSS variable name.
 *
 * @param {String} cssVar Name of the variable to find
 */
function getCSSVariable(cssVar) {
    const value = getComputedStyle(document.body).getPropertyValue(cssVar);
    return value ? value.trim() : value;
}
exports.getCSSVariable = getCSSVariable;
// tslint:enable no-any


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ct_alert_modal_manager_1 = __webpack_require__(174);
exports.CTAlertModalManager = ct_alert_modal_manager_1.CTAlertModalManager;
var ct_alert_modal_1 = __webpack_require__(175);
exports.CTAlertModal = ct_alert_modal_1.CTAlertModal;
var ct_avatar_tile_1 = __webpack_require__(176);
exports.CTAvatarTile = ct_avatar_tile_1.CTAvatarTile;
var ct_button_1 = __webpack_require__(59);
exports.CTButton = ct_button_1.CTButton;
var ct_debugger_1 = __webpack_require__(177);
exports.CTDebugger = ct_debugger_1.CTDebugger;
var ct_file_picker_1 = __webpack_require__(178);
exports.CTFilePicker = ct_file_picker_1.CTFilePicker;
var ct_growing_textbox_1 = __webpack_require__(180);
exports.CTGrowingTextbox = ct_growing_textbox_1.CTGrowingTextbox;
var ct_icon_1 = __webpack_require__(181);
exports.CTIcon = ct_icon_1.CTIcon;
var ct_login_form_1 = __webpack_require__(182);
exports.CTLoginForm = ct_login_form_1.CTLoginForm;
exports.CTLoginFormMetadata = ct_login_form_1.CTLoginFormMetadata;
var ct_menu_1 = __webpack_require__(183);
exports.CTMenu = ct_menu_1.CTMenu;
exports.MenuItem = ct_menu_1.MenuItem;
var ct_online_indicator_1 = __webpack_require__(184);
exports.CTOnlineIndicator = ct_online_indicator_1.CTOnlineIndicator;
exports.CTOnlineIndicatorMetadata = ct_online_indicator_1.CTOnlineIndicatorMetadata;
var ct_searchbox_1 = __webpack_require__(185);
exports.CTSearchbox = ct_searchbox_1.CTSearchbox;
var ct_selection_list_1 = __webpack_require__(186);
exports.CTSelectionList = ct_selection_list_1.CTSelectionList;
var ct_slide_panel_1 = __webpack_require__(188);
exports.CTSlidePanel = ct_slide_panel_1.CTSlidePanel;
var ct_textbox_1 = __webpack_require__(189);
exports.CTTextbox = ct_textbox_1.CTTextbox;
var ct_user_avatar_1 = __webpack_require__(62);
exports.CTUserAvatar = ct_user_avatar_1.CTUserAvatar;
var ct_user_display_1 = __webpack_require__(190);
exports.CTUserDisplay = ct_user_display_1.CTUserDisplay;
var ct_user_list_1 = __webpack_require__(191);
exports.CTUserList = ct_user_list_1.CTUserList;
exports.CTUserListMetadata = ct_user_list_1.CTUserListMetadata;
var ct_user_tile_1 = __webpack_require__(192);
exports.CTUserTile = ct_user_tile_1.CTUserTile;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __webpack_require__(9);
var ConversationEventArgs_1 = __webpack_require__(54);
exports.ConversationEventArgs = ConversationEventArgs_1.ConversationEventArgs;
var ConversationParticiantsEventArgs_1 = __webpack_require__(115);
exports.ConversationParticiantsEventArgs = ConversationParticiantsEventArgs_1.ConversationParticiantsEventArgs;
var ConversationParticiantRoleEventArgs_1 = __webpack_require__(114);
exports.ConversationParticiantRoleEventArgs = ConversationParticiantRoleEventArgs_1.ConversationParticiantRoleEventArgs;
var ForceQuitConversationEventArgs_1 = __webpack_require__(116);
exports.ForceQuitConversationEventArgs = ForceQuitConversationEventArgs_1.ForceQuitConversationEventArgs;
var ChatEntryEventArgs_1 = __webpack_require__(53);
exports.ChatEntryEventArgs = ChatEntryEventArgs_1.ChatEntryEventArgs;
var ChatNotificationEventArgs_1 = __webpack_require__(113);
exports.ChatNotificationEventArgs = ChatNotificationEventArgs_1.ChatNotificationEventArgs;
var AudioAttachmentDownloadComplete_1 = __webpack_require__(112);
exports.AudioAttachmentDownloadComplete = AudioAttachmentDownloadComplete_1.AudioAttachmentDownloadComplete;
var AttachmentDownloadComplete_1 = __webpack_require__(111);
exports.AttachmentDownloadComplete = AttachmentDownloadComplete_1.AttachmentDownloadComplete;
class ChatEvents extends index_1.BaseEvents {
}
// === Events to be handled === //
ChatEvents.ConversationAdded = "conversation-added"; // raised when a conversation is added
ChatEvents.ConversationUpdated = "conversation-updated"; // raised when a conversation is updated
ChatEvents.ConversationClosed = "conversation-closed"; // raised when a conversation is closed to a user
ChatEvents.ConversationRemoved = "conversation-removed"; // raised when a conversation is removed by the user
ChatEvents.ConversationDeleted = "conversation-deleted"; // raised when the user deletes a direct conversation and the server confirms response of this
ChatEvents.ConversationPurged = "conversation-purged"; // raised when a conversation has finished being purged
ChatEvents.ConversationParticipantsChanged = "conversation-participants-changed"; // raised when the participants or role of a participant of a conversation are changed
ChatEvents.ForceQuitConversation = "force-quit-conversation"; // raised when the current user is removed from the current contextual conversation
ChatEvents.CurrentConversationChanged = "current-conversation-changed"; // raised when the current (contextual) conversation has changed
ChatEvents.ChatEntryReceived = "chat-entry-received"; // raised when a new chat entry is received by the current user
ChatEvents.ChatEntryUpdated = "chat-entry-updated"; // raised when a chat entry is updated
ChatEvents.ChatEntriesFetched = "chat-entries-fetched"; // raised when chat entries have been fetched
ChatEvents.ThumbnailLoaded = "thumbnail-loaded";
ChatEvents.ChatNotification = "chat-notification"; // raised when a notification should be displayed for a received message
ChatEvents.PriorityConversationNotification = "priority-conversation-notification"; // raised when a priority notification should be started.
ChatEvents.PriorityConversationAcknowledged = "priority-conversation-acknowledged"; // raised when a priority notification should be stopped.
ChatEvents.PriorityConversationAcknowledgedOnAnotherDevice = "priority-conversation-acknowledged-on-another-device";
ChatEvents.MuteAlertToPlayOtherAudio = "mute-alert-to-play-other-audio";
ChatEvents.ResumeAlertAfterPlayingAudio = "resume-alert-after-playing-audio";
ChatEvents.AudioAttachmentDownloadComplete = "audio-attachment-download-complete";
ChatEvents.RemotelyStartAudioPlayer = "remotely-start-audio-player";
ChatEvents.RemotelyStopAudioPlayer = "remotely-stop-audio-player";
ChatEvents.AudioRecordingStarted = "audio-recording-started";
ChatEvents.AudioRecordingStopped = "audio-recording-stopped";
ChatEvents.AttachmentDownloadComplete = "attachment-download-complete";
ChatEvents.AutoReconnected = "auto-reconnected"; // raised when a the XMPP client raises the auto-reconnected event
ChatEvents.Mute = "mute"; // request to mute sound and stop vibration
ChatEvents.MessageProcessorQueueEmpty = "message-processor-queue-empty"; // raised when a conversation has finished being purged
exports.ChatEvents = ChatEvents;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var ChatMetaActivityType_1 = __webpack_require__(157);
exports.ChatMetaActivityType = ChatMetaActivityType_1.ChatMetaActivityType;
var ConversationType_1 = __webpack_require__(158);
exports.ConversationType = ConversationType_1.ConversationType;
var Icons_1 = __webpack_require__(159);
exports.Icons = Icons_1.Icons;
__export(__webpack_require__(156));
__export(__webpack_require__(160));
__export(__webpack_require__(57));


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(32);
const utils_1 = __webpack_require__(2);
class BaseChatHandler extends handlers_1.BaseHandler {
    constructor(layer) {
        super(layer);
    }
    callHandleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._ensureValidVersion(message);
            yield this.handleMessage(message);
            yield this.layer.updateLatestIdentifier(message);
        });
    }
    callHandleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._ensureValidVersion(message);
            yield this.handleMessageUpdate(message);
            yield this.layer.updateLatestIdentifier(message);
        });
    }
    // === Protected functions === //
    handleConversationNotFound(message, id) {
        return;
    }
    isMamMessage(message) {
        return message.fromMam === true;
    }
    isInjectedMessage(message) {
        return message.injected === true;
    }
    // === Private functions === //
    _ensureValidVersion(message) {
        const messageType = utils_1.getMessageType(message);
        if (messageType === handlers_1.BaseMessageType.XmppChat)
            return; // XmppChat messages do not require a version number
        const content = message.data[messageType];
        const version = content && content.version || 1;
        if (version > BaseChatHandler.VERSION) {
            const errorMessage = `Invalid message version ${content.version} for message "${messageType}" - expected ${BaseChatHandler.VERSION}`;
            this.layer.logger.error(errorMessage, message);
            throw new Error(errorMessage);
        }
    }
}
BaseChatHandler.VERSION = 1;
exports.BaseChatHandler = BaseChatHandler;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const AcknowledgeConversationHandler_1 = __webpack_require__(124);
var ChatMessageType_1 = __webpack_require__(118);
exports.ChatMessageType = ChatMessageType_1.ChatMessageType;
// === Event handlers === //
const CommsConnectionHandler_1 = __webpack_require__(119);
// === IQ handlers === //
const FetchConversationsHandler_1 = __webpack_require__(130);
const CreateConversationHandler_1 = __webpack_require__(127);
const UpdateConversationHandler_1 = __webpack_require__(134);
const AddParticipantsHandler_1 = __webpack_require__(125);
const RemoveParticipantsHandler_1 = __webpack_require__(133);
const ChangeParticipantRoleHandler_1 = __webpack_require__(126);
const LeaveConversationHandler_1 = __webpack_require__(131);
const EndConversationHandler_1 = __webpack_require__(129);
const DeleteDirectConversationHandler_1 = __webpack_require__(128);
// === XMPP message handlers (room)  === //
const ChatMessageHandler_1 = __webpack_require__(135);
const ConversationStartedHandler_1 = __webpack_require__(137);
const ConversationUpdatedHandler_1 = __webpack_require__(138);
const ParticipantAddedHandler_1 = __webpack_require__(140);
const ParticipantRemovedHandler_1 = __webpack_require__(143);
const ParticipantRoleChangedHandler_1 = __webpack_require__(144);
const ParticipantLeftHandler_1 = __webpack_require__(141);
const ConversationEndedHandler_1 = __webpack_require__(136);
// === XMPP message handlers (user) === //
const UserAddedHandler_1 = __webpack_require__(145);
const UserRemovedHandler_1 = __webpack_require__(149);
const UserLeftHandler_1 = __webpack_require__(148);
const UserConversationEndedHandler_1 = __webpack_require__(146);
const UserDeleteDirectConversationHandler_1 = __webpack_require__(147);
// === Event handlers === //
const ChatEntryEventHandler_1 = __webpack_require__(122);
const ParticipantAcknowledgedHandler_1 = __webpack_require__(139);
const AutoReconnectedHandler_1 = __webpack_require__(121);
const ReceivedConversationHandler_1 = __webpack_require__(132);
const ParticipantReceivedHandler_1 = __webpack_require__(142);
const RaiseDeviceNotification_1 = __webpack_require__(123);
const AttachmentDownloaded_1 = __webpack_require__(120);
// tslint:disable-next-line no-any
function get(chatLayer) {
    return [
        // === Event handlers === //
        new AutoReconnectedHandler_1.AutoReconnectedHandler(chatLayer),
        new CommsConnectionHandler_1.CommsConnectionHandler(chatLayer),
        new AttachmentDownloaded_1.AttachmentDownloadedHandler(chatLayer),
        // === Hardware handlers === //
        new RaiseDeviceNotification_1.RaiseDeviceNotificationHandler(chatLayer),
        // === IQ handlers === //
        new FetchConversationsHandler_1.FetchConversationsHandler(chatLayer),
        new CreateConversationHandler_1.CreateConversationHandler(chatLayer),
        new UpdateConversationHandler_1.UpdateConversationHandler(chatLayer),
        new AddParticipantsHandler_1.AddParticipantsHandler(chatLayer),
        new RemoveParticipantsHandler_1.RemoveParticipantsHandler(chatLayer),
        new ChangeParticipantRoleHandler_1.ChangeParticipantRoleHandler(chatLayer),
        new LeaveConversationHandler_1.LeaveConversationHandler(chatLayer),
        new EndConversationHandler_1.EndConversationHandler(chatLayer),
        new ReceivedConversationHandler_1.ReceivedConversationHandler(chatLayer),
        new AcknowledgeConversationHandler_1.AcknowledgeConversationHandler(chatLayer),
        new DeleteDirectConversationHandler_1.DeleteDirectConversationHandler(chatLayer),
        // === XMPP message handlers (room) === //
        new ChatMessageHandler_1.ChatMessageHandler(chatLayer),
        new ConversationStartedHandler_1.ConversationStartedHandler(chatLayer),
        new ConversationUpdatedHandler_1.ConversationUpdatedHandler(chatLayer),
        new ParticipantAddedHandler_1.ParticipantAddedHandler(chatLayer),
        new ParticipantRemovedHandler_1.ParticipantRemovedHandler(chatLayer),
        new ParticipantRoleChangedHandler_1.ParticipantRoleChangedHandler(chatLayer),
        new ParticipantLeftHandler_1.ParticipantLeftHandler(chatLayer),
        new ConversationEndedHandler_1.ConversationEndedHandler(chatLayer),
        new ParticipantReceivedHandler_1.ParticipantReceivedHandler(chatLayer),
        new ParticipantAcknowledgedHandler_1.ParticipantAcknowledgedHandler(chatLayer),
        // === XMPP message handlers (user) === //
        new UserAddedHandler_1.UserAddedHandler(chatLayer),
        new UserRemovedHandler_1.UserRemovedHandler(chatLayer),
        new UserLeftHandler_1.UserLeftHandler(chatLayer),
        new UserConversationEndedHandler_1.UserConversationEndedHandler(chatLayer),
        new UserDeleteDirectConversationHandler_1.UserDeleteDirectConversationHandler(chatLayer),
        // === Event handlers (user) === //
        new ChatEntryEventHandler_1.ChatEntryEventHandler(chatLayer)
    ];
}
exports.get = get;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const linkifyString = __webpack_require__(204);
const tempElementForCssStyles = document.createElement("div");
let requestAnimationFrameQueued = false;
function debouncedRequestAnimationFrame(fn) {
    if (requestAnimationFrameQueued)
        return;
    requestAnimationFrameQueued = true;
    requestAnimationFrame(() => {
        requestAnimationFrameQueued = false;
        fn();
    });
}
exports.debouncedRequestAnimationFrame = debouncedRequestAnimationFrame;
function renderIf(condition, contents) {
    return renderIfElse(condition, contents, null);
}
exports.renderIf = renderIf;
function renderIfElse(condition, contents, elseContents) {
    return (condition)
        ? contents
        : elseContents;
}
exports.renderIfElse = renderIfElse;
// tslint:disable-next-line no-any
function buildStyles(definitions = {}) {
    return definitions;
    // return Object.assign({}, tempElementForCssStyles.style, definitions);
}
exports.buildStyles = buildStyles;
// Below has been nicely robbed from StackOverflow:
// https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
function hexToRgbParts(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    // tslint:disable-next-line no-any
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function hexToRgbaString(hex) {
    const rgbParts = hexToRgbParts(hex);
    return `rgba(${rgbParts.r}, ${rgbParts.g}, ${rgbParts.b}, 1)`;
}
exports.hexToRgbaString = hexToRgbaString;
// Likwise, so has this:
// https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
function decideTextColorFromBgColor(hex) {
    const rgb = hexToRgbParts(hex);
    if ((rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) > 186) {
        return "#000000";
    }
    else {
        return "#ffffff";
    }
}
exports.decideTextColorFromBgColor = decideTextColorFromBgColor;
function linkifyText(text) {
    const linkifiedText = linkifyString(text, {
        target: "_system",
        attributes: {
            onclick: "window.open(this.href, '_system'); return false;"
        }
    });
    return linkifiedText.replace(/&amp;/g, "&");
}
exports.linkifyText = linkifyText;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var BaseEventArgs_1 = __webpack_require__(23);
exports.BaseEventArgs = BaseEventArgs_1.BaseEventArgs;
var CommsEventArgs_1 = __webpack_require__(83);
exports.CommsEventArgs = CommsEventArgs_1.CommsEventArgs;
var UserActivityEventArgs_1 = __webpack_require__(86);
exports.UserActivityEventArgs = UserActivityEventArgs_1.UserActivityEventArgs;
var UserConnectionStatusEventArgs_1 = __webpack_require__(87);
exports.UserConnectionStatusEventArgs = UserConnectionStatusEventArgs_1.UserConnectionStatusEventArgs;
var RoomParticipantUpdateEventArgs_1 = __webpack_require__(85);
exports.RoomParticipantUpdateEventArgs = RoomParticipantUpdateEventArgs_1.RoomParticipantUpdateEventArgs;
var ConnectionStatusEventArgs_1 = __webpack_require__(84);
exports.ConnectionStatusEventArgs = ConnectionStatusEventArgs_1.ConnectionStatusEventArgs;
class BaseEvents {
}
// === Events to request actions to be invoked or messages to be sent === //
BaseEvents._Request_RaiseAlert = "request-raise-alert"; // raise a modal alert message
BaseEvents._Request_CloseAlert = "request-close-alert"; // close a modal alert message
BaseEvents._Request_UpdateUISuppression = "request-update-ui-suppression"; // indicate whether to suppress UI changes
BaseEvents._Request_RedrawAllUIs = "_request-redraw-all-uis"; // request that all components be redrawn
BaseEvents._Request_Logout = "request-logout"; // request that the current user be logged out
BaseEvents._Request_Component_Clear_Data = "request-component-clear-data"; // request that listening components clear their local data / state
BaseEvents._Request_ThemeChange = "request-theme-change"; // request to change the current ui colour theme
// === Events to be handled === //
BaseEvents.ConnectionStatusChange = "connection-status-change"; // raised after the current users connection status has changed
BaseEvents.OtherUserConnectionStatusChange = "other-user-connection-status-change"; // raised when another users connection status has changed
BaseEvents.CurrentUserVCardUpdate = "current-user-vcard-update";
BaseEvents.RoomParticipantUpdate = "room-participant-update"; // raised when the room participants have changed
BaseEvents.UserActivity = "user-activity"; // raised when there is any activity from the current user
BaseEvents.LoginResult = "login-result"; // raised when the user has logged in
BaseEvents.LogoutResult = "logout-result"; // raised when the user has logged out
BaseEvents.LoginFormResult = "login-form-result"; // raised when the user has logged in via the login form
BaseEvents.MoveTaskToBack = "move-task-to-back"; // for back button pressing
exports.BaseEvents = BaseEvents;
// tslint:enable no-any


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
const Models_1 = __webpack_require__(5);
const utils_1 = __webpack_require__(2);
const Keys_1 = __webpack_require__(13);
const ConversationConfigReader_1 = __webpack_require__(14);
function buildConversationParticipants(ownerJids, adminJids, particpantJids) {
    return [
        ...(ownerJids && ownerJids.map(x => ({ jid: x, role: models_1.ChatRole.Owner })) || []),
        ...(adminJids && adminJids.map(x => ({ jid: x, role: models_1.ChatRole.Administrator })) || []),
        ...(particpantJids && particpantJids.map(x => ({ jid: x, role: models_1.ChatRole.Participant })) || [])
    ];
}
exports.buildConversationParticipants = buildConversationParticipants;
function createConversation(id, type, roomJid, participants, subject, description, started, priority, expiryTTL, activityTTL, recs, acks, instigator, hideBefore, replyTemplate, attachments = []) {
    const conversation = {
        id: id,
        roomJid: roomJid,
        type: type,
        participants: participants,
        hasUnread: false,
        preview: null,
        createdTime: parseInt(started),
        instigator: instigator,
        hideBefore: hideBefore,
        config: replyTemplate ? JSON.parse(replyTemplate) : null
    };
    // TODO: Load config from conversation and set options
    if (type === Models_1.ConversationType.Named) {
        conversation.subject = subject;
        conversation.description = description;
        conversation.priority = priority;
        conversation.expiryTTL = expiryTTL;
        conversation.activityTTL = activityTTL;
        conversation.receivedList = recs || [];
        conversation.acknowledgements = acks || [];
        conversation.attachments = attachments.map(x => JSON.parse(x));
    }
    return conversation;
}
exports.createConversation = createConversation;
function createProvisionalDirectConversation(participants, config) {
    return Object.assign({}, createConversation("provisional", Models_1.ConversationType.Direct, null, participants), { isProvisional: true, config: config });
}
exports.createProvisionalDirectConversation = createProvisionalDirectConversation;
function getParticipantHash(participants) {
    return participants
        .map(x => x.jid.toLowerCase())
        .sort()
        .reduce((a, c) => a.concat(c), "");
}
exports.getParticipantHash = getParticipantHash;
function prepareConversationsForList(userLookup, conversations, currentUserJid, filterType = "", filterTerm = "", layer) {
    let preparedConversations = utils_1.deepCloneArray(conversations);
    if (filterType !== "" && filterType.toLowerCase() !== "all") {
        preparedConversations = preparedConversations
            .filter(x => (x.config ? x.config.name : x.type).toLowerCase() === filterType.toLowerCase());
    }
    if (filterTerm) {
        // TODO:KP: is this optimal? should this be using lunar indexing?
        preparedConversations = preparedConversations
            .filter(conversation => {
            const startsWith = [];
            const contains = [];
            conversation.participants.forEach(participant => {
                if (utils_1.jidsMatch(participant.jid, currentUserJid))
                    return;
                const contact = userLookup.get(participant.jid) || null;
                if (!contact)
                    return;
                if (contact.firstName) {
                    startsWith.push(contact.firstName.toLowerCase());
                }
                if (contact.lastName) {
                    startsWith.push(contact.lastName.toLowerCase());
                }
            });
            if (conversation.type === Models_1.ConversationType.Named) {
                contains.push(conversation.subject.toLowerCase());
            }
            const lowercaseFilterTerm = filterTerm.toLowerCase();
            return startsWith.some(token => token.startsWith(lowercaseFilterTerm))
                || contains.some(token => token.includes(lowercaseFilterTerm));
        });
    }
    preparedConversations.sort((a, b) => {
        const aConfig = new ConversationConfigReader_1.ConversationConfigReader(layer, a);
        const bConfig = new ConversationConfigReader_1.ConversationConfigReader(layer, b);
        if (isExpiredConversation(a) && !isExpiredConversation(b)) {
            return 1;
        }
        if (isExpiredConversation(b) && !isExpiredConversation(a)) {
            return -1;
        }
        if (aConfig.alert && !bConfig.alert) {
            return -1;
        }
        if (bConfig.alert && !aConfig.alert) {
            return 1;
        }
        if (aConfig.alert && bConfig.alert) {
            const aPriority = aConfig.sortOrder;
            const bPriority = bConfig.sortOrder;
            if (aPriority !== bPriority) {
                return bPriority - aPriority;
            }
        }
        const aDate = (a.preview && a.preview.date || 0);
        const bDate = (b.preview && b.preview.date || 0);
        return Math.sign(bDate - aDate);
    });
    return preparedConversations;
}
exports.prepareConversationsForList = prepareConversationsForList;
function sortConversationsIntoHash(userLookup, conversations, currentUserJid, filterType = "", filterTerm = "", layer) {
    const hash = {};
    prepareConversationsForList(userLookup, conversations, currentUserJid, filterType, filterTerm, layer)
        .forEach(x => {
        let type = (x.config ? x.config.name : x.type).toLowerCase();
        if (isExpiredConversation(x)) {
            type = `${type} (expired)`;
        }
        if (hash[type]) {
            hash[type].push(x);
        }
        else {
            hash[type] = [x];
        }
    });
    return hash;
}
exports.sortConversationsIntoHash = sortConversationsIntoHash;
function isExpiredConversation(conversation) {
    if (!conversation || !conversation.priority) {
        return false;
    }
    if (!conversation.expiryTTL || conversation.expiryTTL === 0) {
        return false;
    }
    const expiryTime = conversation.createdTime + (conversation.expiryTTL * 1000);
    return new Date().getTime() > expiryTime;
}
exports.isExpiredConversation = isExpiredConversation;
function getConversationTitle(conversation, userLookup, currentUserJid, personalDirectConversationTitle) {
    const isNamedConversation = conversation.type === Models_1.ConversationType.Named;
    const otherParticipants = conversation.participants.filter(x => !utils_1.jidsMatch(x.jid, currentUserJid));
    return isNamedConversation
        ? conversation.subject
        : otherParticipants.length === 0
            ? personalDirectConversationTitle
            : generateConversationTitleFromParticipants(userLookup, otherParticipants, currentUserJid, this._contentLimit);
}
exports.getConversationTitle = getConversationTitle;
function generateConversationTitleFromParticipants(userLookup, participants, currentUserJid, limit = 0) {
    const participatingContacts = participants.map(x => userLookup.get(x.jid));
    const sortedContacts = utils_1.sortUsersByName(participatingContacts);
    let title = sortedContacts
        .map(x => utils_1.formatUserName(x, utils_1.NameFormat.PREFIX_INITIAL_LAST))
        .join(", ");
    if (limit > 0)
        title = title.substr(0, limit);
    return title;
}
exports.generateConversationTitleFromParticipants = generateConversationTitleFromParticipants;
function createChatMessage(id, date, currentUserJid, from, to, messageText, attachments, receivedBy = null, readBy = null, placeholder = null) {
    if (typeof (date) === "string")
        date = parseInt(date, 10);
    const chatMessage = {
        id: id,
        type: models_1.ChatEntryType.Chat,
        date,
        mine: utils_1.jidsMatch(from, currentUserJid),
        from,
        to,
        body: messageText
    };
    if (attachments && attachments.length) {
        chatMessage.attachments = attachments;
    }
    if (receivedBy && receivedBy.length) {
        chatMessage.receivedBy = receivedBy;
    }
    if (readBy && readBy.length) {
        chatMessage.readBy = readBy;
    }
    if (placeholder) {
        chatMessage.placeholder = placeholder;
    }
    return chatMessage;
}
exports.createChatMessage = createChatMessage;
function createMetaEntry(id, date, to, action, instigator, subject, data) {
    if (typeof (date) === "string")
        date = parseInt(date, 10);
    return {
        id,
        type: models_1.ChatEntryType.Meta,
        date,
        to,
        instigator,
        subject,
        action: action.toString(),
        data
    };
}
exports.createMetaEntry = createMetaEntry;
function convertToChatEntry(message, baseLayer) {
    return __awaiter(this, void 0, void 0, function* () {
        const messageType = utils_1.getMessageType(message);
        const parsedMessage = utils_1.parseMessagePayload(message, messageType);
        const handler = baseLayer.getHandlerForMessage(parsedMessage);
        if ("convert" in handler) {
            // tslint:disable-next-line no-any
            const data = parsedMessage.data && parsedMessage.data[handler.messageKey] || null;
            return yield handler["convert"](message, data);
        }
        return null;
    });
}
exports.convertToChatEntry = convertToChatEntry;
function getChatMessageTextForPreview(message, translationProvider) {
    if (message.body && message.body.length > 0) {
        const previewLength = 100;
        const suffix = message.body.length > (previewLength - 3)
            ? "..."
            : "";
        return message.body.substr(0, previewLength) + suffix;
    }
    else if (message.attachments && message.attachments.length > 0) {
        return translationProvider.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ATTATCHMENT_RECEIVED));
    }
    return "";
}
exports.getChatMessageTextForPreview = getChatMessageTextForPreview;
function getChatMetaActivitySummaryText(activity, userLookup, currentUserJid, translationProvider, asHtml = false) {
    let token = null;
    const action = utils_1.enumFromString(activity.action);
    switch (action) {
        case Models_1.ChatMetaActivityType.START:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.START_BY_YOU
                : Keys_1.ChatCommonI18nKeys.START;
            break;
        case Models_1.ChatMetaActivityType.UPDATE:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.UPDATE_BY_YOU
                : Keys_1.ChatCommonI18nKeys.UPDATE;
            break;
        case Models_1.ChatMetaActivityType.ADD:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.ADD_BY_YOU
                : utils_1.jidsMatch(activity.subject, currentUserJid)
                    ? Keys_1.ChatCommonI18nKeys.ADD_YOU
                    : Keys_1.ChatCommonI18nKeys.ADD;
            break;
        case Models_1.ChatMetaActivityType.REMOVE:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.KICK_BY_YOU
                : utils_1.jidsMatch(activity.subject, currentUserJid)
                    ? Keys_1.ChatCommonI18nKeys.KICK_YOU
                    : Keys_1.ChatCommonI18nKeys.KICK;
            break;
        case Models_1.ChatMetaActivityType.CHANGEROLE:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.CHANGE_ROLE_BY_YOU
                : utils_1.jidsMatch(activity.subject, currentUserJid)
                    ? Keys_1.ChatCommonI18nKeys.CHANGE_ROLE_YOU
                    : Keys_1.ChatCommonI18nKeys.CHANGE_ROLE;
            break;
        case Models_1.ChatMetaActivityType.LEFT:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.LEFT_YOU
                : Keys_1.ChatCommonI18nKeys.LEFT;
            break;
        case Models_1.ChatMetaActivityType.END:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.END_YOU
                : Keys_1.ChatCommonI18nKeys.END;
            break;
        case Models_1.ChatMetaActivityType.ACK:
            token = utils_1.jidsMatch(activity.instigator, currentUserJid)
                ? Keys_1.ChatCommonI18nKeys.ACK_BY_YOU
                : Keys_1.ChatCommonI18nKeys.ACK;
            break;
    }
    if (!token)
        return null;
    const getName = jid => {
        const user = userLookup.get(jid);
        if (!user)
            return jid;
        return utils_1.formatUserName(user, utils_1.NameFormat.PREFIX_INITIAL_LAST) || jid;
    };
    // tslint:disable-next-line no-any
    const replacements = {
        date: utils_1.getFriendlyDate(activity.date, translationProvider),
        time: utils_1.getFriendlyTime(activity.date),
        instigator: getName(activity.instigator),
        subject: getName(activity.subject),
        data: activity.data,
        value: activity.subject || "acknowledge"
    };
    if (activity.action === "change_role") {
        switch (activity.data) {
            case models_1.ChatRole.Participant.toString():
                replacements.data = translationProvider.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.PARTICIPANT));
                break;
            case models_1.ChatRole.Administrator.toString():
                replacements.data = translationProvider.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ADMINISTRATOR));
                break;
            case models_1.ChatRole.Owner.toString():
                replacements.data = translationProvider.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.OWNER));
                break;
        }
    }
    let message = translationProvider.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(token));
    Object.keys(replacements).forEach(key => {
        message = message.replace(`{{${key}}}`, replacements[key]);
    });
    return asHtml
        ? message.replace(/\*(.*?)\*/g, "<span class='b'>$1</span>")
        : message.replace(/\*(.*?)\*/g, "$1");
}
exports.getChatMetaActivitySummaryText = getChatMetaActivitySummaryText;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var Metadata_1 = __webpack_require__(90);
exports.Metadata = Metadata_1.Metadata;
var I18nItem_1 = __webpack_require__(89);
exports.I18nItem = I18nItem_1.I18nItem;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var CTCLComponent_1 = __webpack_require__(103);
exports.CTCLComponent = CTCLComponent_1.CTCLComponent;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __webpack_require__(11);
var ChatCommonI18nKeys;
(function (ChatCommonI18nKeys) {
    // tslint:disable no-any
    ChatCommonI18nKeys[ChatCommonI18nKeys["FETCHING_OWN_DATA"] = "Fetching personal data..."] = "FETCHING_OWN_DATA";
    ChatCommonI18nKeys[ChatCommonI18nKeys["UPDATING_CONTACTS"] = "Updating contacts..."] = "UPDATING_CONTACTS";
    ChatCommonI18nKeys[ChatCommonI18nKeys["FETCHING_CONVERSATIONS"] = "Fetching conversations..."] = "FETCHING_CONVERSATIONS";
    ChatCommonI18nKeys[ChatCommonI18nKeys["REMOVED_TITLE"] = "Removed from conversation"] = "REMOVED_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["REMOVED_MESSAGE"] = "You were removed from the conversation \"{{subject}}\""] = "REMOVED_MESSAGE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ENDED_TITLE"] = "Conversation closed"] = "ENDED_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ENDED_MESSAGE"] = "The conversation \"{{subject}}\" has been closed"] = "ENDED_MESSAGE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_SAVING_CHANGES_TITLE"] = "Error saving changes"] = "ERROR_SAVING_CHANGES_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_SAVING_CHANGES_MESSAGE"] = "There was an error saving changes"] = "ERROR_SAVING_CHANGES_MESSAGE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_CREATING_CONVERSATION_TITLE"] = "Unable to create conversation"] = "ERROR_CREATING_CONVERSATION_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_UPDATING_CONVERSATION_TITLE"] = "Unable to update details"] = "ERROR_UPDATING_CONVERSATION_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_ADDING_PARTICIPANTS_TITLE"] = "Unable to add participants"] = "ERROR_ADDING_PARTICIPANTS_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_REMOVING_PARTICIPANTS_TITLE"] = "Unable to remove participants"] = "ERROR_REMOVING_PARTICIPANTS_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_CHANGING_PARTICIPANT_ROLE_TITLE"] = "Unable to change role"] = "ERROR_CHANGING_PARTICIPANT_ROLE_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_LEAVING_CONVERSATION_TITLE"] = "Unable to leave conversation"] = "ERROR_LEAVING_CONVERSATION_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_ENDING_CONVERSATION_TITLE"] = "Unable to end conversation"] = "ERROR_ENDING_CONVERSATION_TITLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_RECEIVING_CONVERSATION"] = "Unable to mark conversation as received"] = "ERROR_RECEIVING_CONVERSATION";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_ACKNOWLEDGING_CONVERSATION"] = "Unable to acknowledge conversation"] = "ERROR_ACKNOWLEDGING_CONVERSATION";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ERROR_DELETING_DIRECT_CONVERSATION"] = "Unable to delete this conversation"] = "ERROR_DELETING_DIRECT_CONVERSATION";
    ChatCommonI18nKeys[ChatCommonI18nKeys["YOU_HAVE_NEW_NOTIFICATIONS"] = "You have new notifications"] = "YOU_HAVE_NEW_NOTIFICATIONS";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ATTATCHMENT_RECEIVED"] = "Image"] = "ATTATCHMENT_RECEIVED";
    ChatCommonI18nKeys[ChatCommonI18nKeys["START"] = "Started *{{date}}* at *{{time}}* by *{{instigator}}*"] = "START";
    ChatCommonI18nKeys[ChatCommonI18nKeys["START_BY_YOU"] = "Started *{{date}}* at *{{time}}* by *you*"] = "START_BY_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["UPDATE"] = "*{{instigator}}* updated the conversation details"] = "UPDATE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["UPDATE_BY_YOU"] = "*You* updated the conversation details"] = "UPDATE_BY_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ADD"] = "*{{subject}}* was added by *{{instigator}}*"] = "ADD";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ADD_YOU"] = "*You* were added by *{{instigator}}*"] = "ADD_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ADD_BY_YOU"] = "*{{subject}}* was added by *you*"] = "ADD_BY_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ACK"] = "*{{instigator}}* responded with: *{{value}}* *{{date}}* at *{{time}}*"] = "ACK";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ACK_BY_YOU"] = "You responded with: *{{value}}* *{{date}}* at *{{time}}*"] = "ACK_BY_YOU";
    // ACK = "*{{instigator}}* has acknowledged: *{{subject}}*" as any,
    // ACK_BY_YOU = "You have acknowledged: *{{subject}}*" as any,
    ChatCommonI18nKeys[ChatCommonI18nKeys["CHANGE_ROLE"] = "*{{subject}}* was made *{{data}}* by *{{instigator}}*"] = "CHANGE_ROLE";
    ChatCommonI18nKeys[ChatCommonI18nKeys["CHANGE_ROLE_YOU"] = "*You* were made *{{data}}* by *{{instigator}}*"] = "CHANGE_ROLE_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["CHANGE_ROLE_BY_YOU"] = "*{{subject}}* was made *{{data}}* by *you*"] = "CHANGE_ROLE_BY_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["KICK"] = "*{{subject}}* was removed by *{{instigator}}*"] = "KICK";
    ChatCommonI18nKeys[ChatCommonI18nKeys["KICK_YOU"] = "*You* were removed by *{{instigator}}*"] = "KICK_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["KICK_BY_YOU"] = "*{{subject}}* was removed by *you*"] = "KICK_BY_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["LEFT"] = "*{{instigator}}* left the conversation"] = "LEFT";
    ChatCommonI18nKeys[ChatCommonI18nKeys["LEFT_YOU"] = "*You* left the conversation"] = "LEFT_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["END"] = "*{{instigator}}* ended the conversation"] = "END";
    ChatCommonI18nKeys[ChatCommonI18nKeys["END_YOU"] = "*You* ended the conversation"] = "END_YOU";
    ChatCommonI18nKeys[ChatCommonI18nKeys["PARTICIPANT"] = "participant"] = "PARTICIPANT";
    ChatCommonI18nKeys[ChatCommonI18nKeys["ADMINISTRATOR"] = "administrator"] = "ADMINISTRATOR";
    ChatCommonI18nKeys[ChatCommonI18nKeys["OWNER"] = "owner"] = "OWNER";
    // tslint:enable no-any
})(ChatCommonI18nKeys = exports.ChatCommonI18nKeys || (exports.ChatCommonI18nKeys = {}));
exports.ChatCommonMetadata = new index_1.Metadata("ChatCommon", ChatCommonI18nKeys);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Models_1 = __webpack_require__(5);
const utils_1 = __webpack_require__(2);
/**
 * Configuration Reader
 *
 * This will take a supplied conversation and then allow you to read configuration values safely.
 * All configuration keys will either supply their value or return a falsey value of null.
 */
class ConversationConfigReader {
    constructor(layer, conversation, config) {
        this._layer = layer;
        this._conversation = conversation;
        this._config = config || this._loadConfiguration();
    }
    /**
     * Loads a conversation configuration in order of priority. The order is from the supplied
     * conversation, from the chatLayer or finally a default direct conversation config.
     */
    _loadConfiguration() {
        let type = "";
        if (this._conversation && this._conversation.config) {
            return this._conversation.config;
        }
        else if (this._conversation) {
            type = this._conversation.type;
            const config = this._layer.config.conversationTypes.find(x => x.id === this._conversation.type);
            if (config) {
                return config;
            }
        }
        switch (type) {
            case "named":
                return Models_1.namedConversationConfig;
            case "direct":
            default:
                return Models_1.directConversationConfig;
        }
    }
    /**
     * Checks and throws an error if there is no config.
     */
    _ensureConfigSet() {
        if (!this._config) {
            throw new Error("Configuration has not been set.");
        }
    }
    // === Public === //
    /**
     * A helper method to create a ConfiguredConversation object that can be sent when a new
     * conversation is started. This is then read by the receiver and will force their app to
     * respect the configured options.
     * @param responseOptions AlertResponseOption
     */
    constructConfigurationToSend(responseOptions, chatEnabled = true) {
        const newConfig = utils_1.deepCloneObject(this._config);
        /**
         * Right now, the only option we need to strip for the receiving user is the alert
         * response options and chat enabled. In the future, we may need to limit more options.
         * They can be added to this method in order for us to easily do that.
         */
        if (responseOptions && newConfig.behaviour.alert) {
            newConfig.behaviour.alert.alertResponseOptions = [responseOptions];
        }
        newConfig.behaviour.chatAvailable = chatEnabled;
        return newConfig;
    }
    // === Configuration Keys === //
    /**
     * Configuration is deliberately flattened in this class. This is so that if the structure of
     * the configuration changes in the future, the code can ask for config values via this class.
     * This means that if the structure does change, the code base does not need to change and only
     * this class does - therefore, hopefully making it easier to manage.
     */
    get id() {
        return this._config.id || null;
    }
    get sortOrder() {
        return this._config.sortOrder || 999;
    }
    get name() {
        return this._config.name || "Direct";
    }
    get shortDescription() {
        return this._config.shortDescription || null;
    }
    get longDescription() {
        return this._config.longDescription || null;
    }
    get descriptionAtTop() {
        return this._config.descriptionAtTop || null;
    }
    get colorCode() {
        return this._config.colorCode || null;
    }
    get displayGroup() {
        return this._config.displayGroup || null;
    }
    get defaultConversationExpiryTTL() {
        if (this._config.defaultConversationExpiryTTL === undefined) {
            return this._layer.config.behaviour.defaultConversationExpiryTTL || 60 * 60;
        }
        return this._config.defaultConversationExpiryTTL;
    }
    get defaultConversationActivityTTL() {
        if (this._config.defaultConversationActivityTTL === undefined) {
            return this._layer.config.behaviour.defaultConversationActivityTTL || 60 * 60 * 24 * 7;
        }
        return this._config.defaultConversationActivityTTL;
    }
    get maxConversationParticipants() {
        return this._config.maxConversationParticipants || this._layer.config.behaviour.maxConversationParticipants || 20;
    }
    get warnWhenNoContacts() {
        if (this._config.behaviour.warnWhenNoContacts === undefined) {
            return false;
        }
        return this._config.behaviour.warnWhenNoContacts;
    }
    get errorWhenNoContacts() {
        if (this._config.behaviour.errorWhenNoContacts === undefined) {
            return false;
        }
        return this._config.behaviour.errorWhenNoContacts;
    }
    get chatAvailable() {
        if (this._config.behaviour.chatAvailable === undefined) {
            return true;
        }
        return this._config.behaviour.chatAvailable;
    }
    get namedSettings() {
        if (this._config.behaviour.namedSettings && Object.keys(this._config.behaviour.namedSettings).length > 0) {
            return true;
        }
        else {
            return null;
        }
    }
    get usePagerUI() {
        return this._config.behaviour.usePagerUI || false;
    }
    get subjectRequired() {
        if (this._config.behaviour.namedSettings) {
            if (this._config.behaviour.namedSettings.subjectRequired === undefined) {
                return true;
            }
            return this._config.behaviour.namedSettings.subjectRequired;
        }
        else {
            return null;
        }
    }
    get subjectFieldLabel() {
        if (this._config.behaviour.namedSettings) {
            return this._config.behaviour.namedSettings.subjectFieldLabel || "Subject";
        }
        else {
            return "Subject";
        }
    }
    get maxSubjectLength() {
        if (this._config.behaviour.namedSettings) {
            return this._config.behaviour.namedSettings.maxSubjectLength || this._layer.config.behaviour.maxSubjectLength;
        }
        else {
            return this._layer.config.behaviour.maxSubjectLength;
        }
    }
    get descriptionRequired() {
        if (this._config.behaviour.namedSettings) {
            return this._config.behaviour.namedSettings.descriptionRequired || false;
        }
        else {
            return false;
        }
    }
    get descriptionFieldLabel() {
        if (this._config.behaviour.namedSettings) {
            return this._config.behaviour.namedSettings.descriptionFieldLabel || `Description${this.descriptionRequired ? "" : " (optional)"}`;
        }
        else {
            return "Description (optional)";
        }
    }
    get maxDescriptionLength() {
        if (this._config.behaviour.namedSettings) {
            return this._config.behaviour.namedSettings.maxDescriptionLength || this._layer.config.behaviour.maxDescriptionLength;
        }
        else {
            return this._layer.config.behaviour.maxDescriptionLength;
        }
    }
    get participantCanLeave() {
        if (this._config.behaviour.participantCanLeave === undefined) {
            return true;
        }
        return this._config.behaviour.participantCanLeave;
    }
    get participantCanDelete() {
        if (this._config.behaviour.participantCanDelete === undefined) {
            return true;
        }
        return this._config.behaviour.participantCanDelete;
    }
    get ownerCanEditAfterSend() {
        if (this._config.behaviour.ownerCanEditAfterSend === undefined) {
            return true;
        }
        return this._config.behaviour.ownerCanEditAfterSend;
    }
    get ownerCanAddAdditionalContacts() {
        if (this._config.behaviour.ownerCanAddAdditionalContacts === undefined) {
            return true;
        }
        return this._config.behaviour.ownerCanAddAdditionalContacts;
    }
    get ownerCanCloseEarly() {
        if (this._config.behaviour.ownerCanCloseEarly === undefined) {
            return true;
        }
        return this._config.behaviour.ownerCanCloseEarly;
    }
    get canSendAttachmentsWithinConversation() {
        if (this._config.behaviour.canSendAttachmentsWithinConversation === undefined) {
            return true;
        }
        return this._config.behaviour.canSendAttachmentsWithinConversation;
    }
    get autoRemoveOnClose() {
        if (this._config.behaviour.autoRemoveOnClose === undefined) {
            return true;
        }
        return this._config.behaviour.autoRemoveOnClose;
    }
    get priorityPush() {
        if (this._config.behaviour.priorityPush) {
            return this._config.behaviour.priorityPush;
        }
        return null;
    }
    get alert() {
        if (this._config.behaviour.alert && Object.keys(this._config.behaviour.alert).length > 0) {
            return true;
        }
        else {
            return null;
        }
    }
    get autoAlert() {
        if (this._config.behaviour.alert) {
            if (this._config.behaviour.alert.autoAlert === undefined) {
                return true;
            }
            return this._config.behaviour.alert.autoAlert;
        }
        else {
            return null;
        }
    }
    get suppressAlertModalWarning() {
        if (this._config.behaviour.alert) {
            return this._config.behaviour.alert.suppressAlertModalWarning || false;
        }
        return false;
    }
    get alertVolume() {
        if (this._config.behaviour.alert) {
            if (this._config.behaviour.alert.alertVolume === undefined) {
                return 100;
            }
            else {
                return this._config.behaviour.alert.alertVolume;
            }
        }
        else {
            return 100;
        }
    }
    get alertSoundFilename() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.alertSoundFilename === undefined) {
            return "Clinical_Messaging_Notification.m4a";
        }
        else {
            return this._config.behaviour.alert.alertSoundFilename;
        }
    }
    get alertSoundLoops() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.alertSoundLoops === undefined) {
            return 1;
        }
        else {
            return this._config.behaviour.alert.alertSoundLoops;
        }
    }
    get alertAudioStream() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.alertAudioStream === undefined) {
            return "notification";
        }
        else {
            return this._config.behaviour.alert.alertAudioStream;
        }
    }
    get vibrate() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.vibrate === undefined) {
            return true;
        }
        else {
            return this._config.behaviour.alert.vibrate;
        }
    }
    get forceVibrate() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.forceVibrate === undefined) {
            return true;
        }
        else {
            return this._config.behaviour.alert.forceVibrate;
        }
    }
    get vibrateDuration() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.vibrateDuration === undefined) {
            return 300;
        }
        else {
            return this._config.behaviour.alert.vibrateDuration;
        }
    }
    get automaticallyPlayAudioOnDownload() {
        if (!this._config.behaviour.alert || this._config.behaviour.alert.automaticallyPlayAudioOnDownload === undefined) {
            return false;
        }
        else {
            return this._config.behaviour.alert.automaticallyPlayAudioOnDownload;
        }
    }
    get allowMute() {
        if (this._config.behaviour.alert) {
            return this._config.behaviour.alert.allowMute || false;
        }
        else {
            return null;
        }
    }
    get snoozeDuration() {
        if (this._config.behaviour.alert) {
            return this._config.behaviour.alert.snoozeDuration || 60;
        }
        else {
            return null;
        }
    }
    get alertResponseOptions() {
        if (this.alert) {
            if (this._config.behaviour.alert.alertResponseOptions) {
                return this._config.behaviour.alert.alertResponseOptions;
            }
        }
        return [];
    }
    get alertResponseOptionTemplates() {
        if (this.alert) {
            if (this.alertResponseOptions.length) {
                return this.alertResponseOptions
                    .reduce((acc, cur) => acc = [...acc, ...cur.options], []);
            }
        }
        return [];
    }
    get attachments() {
        if (this._config.behaviour) {
            if (this._config.behaviour.attachments && Object.keys(this._config.behaviour.attachments).length > 0) {
                return true;
            }
        }
        return null;
    }
    get image() {
        if (this.attachments) {
            return this._config.behaviour.attachments.image;
        }
        return null;
    }
    get allowOpenInFullScreen() {
        if (this.attachments && this.image && Object.keys(this._config.behaviour.attachments.image).length > 0) {
            if (this._config.behaviour.attachments.image.allowOpenInFullScreen === undefined) {
                return true;
            }
            return this._config.behaviour.attachments.image.allowOpenInFullScreen;
        }
        else {
            return true;
        }
    }
    get audio() {
        if (this.attachments) {
            return this._config.behaviour.attachments.audio;
        }
        return null;
    }
    get attachPreRecordedFile() {
        if (this.attachments) {
            if (this.audio && this.audio.attachPreRecordedFile !== undefined) {
                return this.audio.attachPreRecordedFile;
            }
            return true;
        }
        return null;
    }
    get attachLiveRecordedAudio() {
        if (this.attachments) {
            if (this.audio && this.audio.attachLiveRecordedAudio !== undefined) {
                return this.audio.attachLiveRecordedAudio;
            }
            return true;
        }
        return null;
    }
    get video() {
        if (this.attachments) {
            return this._config.behaviour.attachments.video;
        }
        return null;
    }
    get autoPlay() {
        if (this.attachments && this.audio) {
            return this.audio.autoPlay || false;
        }
        return null;
    }
    get limitPlaybackToEarpiece() {
        if (this.attachments && this.audio) {
            return this.audio.limitPlaybackToEarpiece || false;
        }
        return null;
    }
    get shouldOpenConversationAfterResponded() {
        if (this._config.behaviour.alert) {
            if (this._config.behaviour.alert.shouldOpenConversationAfterResponded === undefined) {
                return true;
            }
            return this._config.behaviour.alert.shouldOpenConversationAfterResponded;
        }
        else {
            return true;
        }
    }
    get participantAlertResponsesVisible() {
        if (this._config.behaviour.alert) {
            if (this._config.behaviour.alert.participantAlertResponsesVisible === undefined) {
                return true;
            }
            return this._config.behaviour.alert.participantAlertResponsesVisible;
        }
        else {
            return true;
        }
    }
    get autoIncludeMembersInRoles() {
        if (this._config.behaviour.alert) {
            return this._config.behaviour.alert.autoIncludeMembersInRoles || [];
        }
        return [];
    }
}
exports.ConversationConfigReader = ConversationConfigReader;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = __webpack_require__(11);
/**
 * Used to define a component and handle registration. You can
 * provide this definition parameter which includes the styles
 * for the component, tag definition and optionally the metadata.
 *
 * @param {Object} definition Component definition options
 * @param {String} definition.tag The component tag name
 * @param {Array} definition.styles An array of stylesheet paths
 */
function component(definition) {
    // tslint:disable-next-line no-any
    return (constructor) => {
        const existing = customElements.get(definition.tag);
        if (!existing) {
            customElements.define(definition.tag, constructor);
        }
        constructor.prototype.styles = definition.styles;
        if (definition.i18nKeys) {
            constructor.prototype._metadata = new metadata_1.Metadata(constructor.name, definition.i18nKeys);
            setTranslationData(constructor.name, constructor.prototype._metadata);
        }
        return class extends constructor {
            static get is() {
                return definition.tag;
            }
            static set styles(val) {
                this.styles = val;
            }
            // tslint:disable-next-line no-any
            static set _metadata(val) {
                this._metadata = val;
            }
        };
    };
}
exports.component = component;
function setTranslationData(name, metadata) {
    // tslint:disable no-any
    if (!window.translationData) {
        window.translationData = new Map();
    }
    window.translationData.set(name, metadata);
    // tslint:enable no-any
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
function createIq(operationName, namespace, content) {
    return {
        [operationName]: createIqNode({ xmlns: "urn:commontime:infinity:muc" }, content)
    };
}
exports.createIq = createIq;
function createIqNode(attributes, children = null) {
    const attributesNode = {};
    if (attributes) {
        attributesNode.$attributes = attributes;
    }
    return Object.assign({}, attributesNode, (children || {}));
}
exports.createIqNode = createIqNode;
// tslint:enable no-any


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(2);
// tslint:disable no-any
// tslint:disable no-console
var LoggerTypes;
(function (LoggerTypes) {
    LoggerTypes[LoggerTypes["Connectivity"] = "connectivity"] = "Connectivity";
    LoggerTypes[LoggerTypes["MessageSent"] = "message-sent"] = "MessageSent";
    LoggerTypes[LoggerTypes["MessageReceived"] = "message-received"] = "MessageReceived";
    LoggerTypes[LoggerTypes["MessageUpdated"] = "message-updated"] = "MessageUpdated";
    LoggerTypes[LoggerTypes["MessageChatMarker"] = "message-chat-marker"] = "MessageChatMarker";
    LoggerTypes[LoggerTypes["ProcessingReceived"] = "processing-received"] = "ProcessingReceived";
    LoggerTypes[LoggerTypes["ProcessingUpdated"] = "processing-updated"] = "ProcessingUpdated";
    LoggerTypes[LoggerTypes["ProcessingChatMarker"] = "processing-chat-marker"] = "ProcessingChatMarker";
    LoggerTypes[LoggerTypes["Status"] = "status"] = "Status";
    LoggerTypes[LoggerTypes["Presence"] = "presence"] = "Presence";
    LoggerTypes[LoggerTypes["Participation"] = "participation"] = "Participation";
    LoggerTypes[LoggerTypes["Mam"] = "mam"] = "Mam";
    LoggerTypes[LoggerTypes["CleanUp"] = "clean-up"] = "CleanUp";
    LoggerTypes[LoggerTypes["XmppClient"] = "xmpp-client"] = "XmppClient";
    LoggerTypes[LoggerTypes["Events"] = "events"] = "Events";
    LoggerTypes[LoggerTypes["DataStorage"] = "data-storage"] = "DataStorage";
    LoggerTypes[LoggerTypes["Other"] = "other"] = "Other";
})(LoggerTypes = exports.LoggerTypes || (exports.LoggerTypes = {}));
class Logger {
    constructor(types = null) {
        this._types = types || [];
        this._initialTypes = types;
    }
    log(type, ...logArgs) {
        if (this.shouldLog(type)) {
            console.log.call(null, ...logArgs);
        }
    }
    info(type, ...logArgs) {
        if (this.shouldLog(type)) {
            console.info.call(null, ...logArgs);
        }
    }
    debug(type, ...logArgs) {
        if (this.shouldLog(type)) {
            console.debug.call(null, ...logArgs);
        }
    }
    error(...logArgs) {
        // errors _always_ get logged
        console.error.call(null, ...logArgs);
    }
    group(type, expanded = false, groupName = "", ...logArgs) {
        if (this.shouldLog(type)) {
            if (expanded)
                console.group.call(null, groupName, ...logArgs);
            else
                console.groupCollapsed.call(null, groupName, ...logArgs);
        }
    }
    groupEnd(type) {
        if (this.shouldLog(type)) {
            console.groupEnd.call(null);
        }
    }
    getTypes() {
        return this._types;
    }
    hasInitialTypes() {
        return this._initialTypes && this._initialTypes.length > 0;
    }
    getTypesAsEnumValues() {
        return this._types.map(x => utils_1.enumFromString(x));
    }
    setTypes(types) {
        this._types = types || [];
    }
    resetTypes() {
        this._types = this._initialTypes;
    }
    shouldLog(type) {
        if (!this._types || !this._types.length)
            return false;
        if (this._types.includes("_all_"))
            return true;
        return this._types.includes(type.toString());
    }
}
exports.Logger = Logger;
// tslint:enable no-any
// tslint:enable no-console


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = __webpack_require__(11);
var ChatErrorsI18nKeys;
(function (ChatErrorsI18nKeys) {
    // tslint:disable no-any
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_IQ_TYPE_INVALID"] = "Unknown request"] = "E_IQ_TYPE_INVALID";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_IQ_SUB_EL_MISSING"] = "Request has missing data"] = "E_IQ_SUB_EL_MISSING";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_IQ_SUB_EL_UNKNOWN"] = "Request has unknown data"] = "E_IQ_SUB_EL_UNKNOWN";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CONV_NOT_FOUND"] = "The conversation could not be found"] = "E_CONV_NOT_FOUND";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CONV_TYPE"] = "Unable to perform operation on this type of conversation"] = "E_CONV_TYPE";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CONV_ROLE"] = "You are not permitted to perform that operation"] = "E_CONV_ROLE";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CREATION_FAILED"] = "Could not create conversation"] = "E_CREATION_FAILED";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CREATOR_NOT_PARTICIPANT"] = "Could not create conversation - the creator was not included as a participant"] = "E_CREATOR_NOT_PARTICIPANT";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_PARTICIPANTS_NOT_MEMBERS"] = "Could not create conversation - all participants must be in the participant role"] = "E_PARTICIPANTS_NOT_MEMBERS";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CONV_SELF"] = "You are not permitted to change your own role"] = "E_CONV_SELF";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_CONV_NO_OWNER"] = "You cannot leave this conversation as you are the only owner"] = "E_CONV_NO_OWNER";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_NO_CONNECTION_DELETING_DIRECT"] = "You cannot delete a direct conversation when you are offline."] = "E_NO_CONNECTION_DELETING_DIRECT";
    ChatErrorsI18nKeys[ChatErrorsI18nKeys["E_UNKNOWN"] = "An unknown error occurred"] = "E_UNKNOWN";
    // tslint:enable no-any
})(ChatErrorsI18nKeys = exports.ChatErrorsI18nKeys || (exports.ChatErrorsI18nKeys = {}));
exports.ChatErrorsMetadata = new metadata_1.Metadata("ChatErrors", ChatErrorsI18nKeys);
function getErrorMessage(errorCode, translationProvdier) {
    const i18nErrorKey = ChatErrorsI18nKeys[errorCode] || ChatErrorsI18nKeys.E_UNKNOWN;
    return translationProvdier.translateI18nItem(exports.ChatErrorsMetadata.getI18nItem(i18nErrorKey));
}
exports.getErrorMessage = getErrorMessage;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const Models_1 = __webpack_require__(5);
const components_1 = __webpack_require__(3);
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ONLINE"] = "Online"] = "ONLINE";
    I18nKeys[I18nKeys["OFFLINE"] = "Offline"] = "OFFLINE";
    I18nKeys[I18nKeys["RECONNECTING"] = "Reconnecting"] = "RECONNECTING";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLHeaderMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLHeader, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLHeaderMetadata._instance = null;
exports.CTCLHeaderMetadata = CTCLHeaderMetadata;
class CTCLHeader extends Base_1.CTCLComponent {
    constructor() {
        super();
        this.setMetadata(CTCLHeaderMetadata.instance);
    }
    static get is() {
        return "ct-cl-header";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener(() => {
            clearTimeout(this._reconnectTimeout);
        });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;font-size:1em}:host .header{position:relative;display:flex;align-items:center;height:var(--header-height, 75px);padding:0 20px;background:var(--header-bg, #22b1c8);color:var(--header-text, #fff)}:host .header .left-action{flex:0 0 20px}:host .header .details{flex:1 1 auto;position:relative;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;text-align:center;transition:padding 0.3s ease-out;overflow:hidden}:host .header .details .heading{font-size:1.5em}:host .header .details .sub-heading{font-weight:100}:host .header .details .status{position:absolute;bottom:0;left:50%;transform:translate(-50%, 100%);display:flex;justify-content:center;align-items:center;font-size:.833em;padding:3px 10px;border:1px solid rgba(255,255,255,0.5);border-bottom:0;border-radius:10px 10px 0 0;will-change:transform;transition:transform 0.3s ease-out}:host .header .details .status .icon{margin:0 0 0 5px}:host .header .right-action{flex:0 0 20px}:host .header.offline .details{padding:0 0 20px 0}:host .header.offline .details .status{transform:translate(-50%, 0);cursor:pointer}:host .header.offline .details .status:hover{background:rgba(255,255,255,0.1)}:host .header.disconnecting .details .status,:host .header.connecting .details .status{opacity:0.5;cursor:default}
        `;
    }
    generateComponentMarkup() {
        const cssClasses = [
            "header",
            ...this._getConnectionStatusCssClasses()
        ];
        const headerStyle = renderUtils_1.buildStyles({
            backgroundColor: this.backgroundColor
        });
        return (window.__CTRender("div", { class: cssClasses.join(" "), style: headerStyle },
            window.__CTRender("div", { class: "left-action" },
                window.__CTRender("slot", { name: "left-action" })),
            window.__CTRender("div", { class: "details" },
                window.__CTRender("div", { class: "heading" },
                    window.__CTRender("slot", { name: "heading" })),
                window.__CTRender("div", { class: "sub-heading" },
                    window.__CTRender("slot", { name: "sub-heading" })),
                window.__CTRender("div", { class: "status", onClick: this._onClickReconnectNow.bind(this) },
                    window.__CTRender("div", { class: "label" }, this._getConnectionStatusLabel()),
                    window.__CTRender(components_1.CTIcon, { class: "icon", width: "10", height: "10", icon: Models_1.Icons.UI.Reconnect, spin: this.connectionStatus === models_1.ConnectionStatus.Connecting }))),
            window.__CTRender("div", { class: "right-action" },
                window.__CTRender("slot", { name: "right-action" }))));
    }
    // === Event handlers === //
    _onClickReconnectNow() {
        if (this.connectionStatus === models_1.ConnectionStatus.Disconnected) {
            this.connectionStatus = models_1.ConnectionStatus.Connecting;
            clearTimeout(this._reconnectTimeout);
            this._reconnectTimeout = setTimeout(() => {
                this.layer.attemptReconnect();
            }, 500);
        }
    }
    // === Private functions === //
    _getConnectionStatusCssClasses() {
        switch (this.connectionStatus) {
            case models_1.ConnectionStatus.Disconnected:
                return ["offline disconnected"];
            case models_1.ConnectionStatus.Disconnecting:
                return ["offline disconnecting"];
            case models_1.ConnectionStatus.Connecting:
                return ["offline connecting"];
            case models_1.ConnectionStatus.Connected:
                return ["online connected"];
        }
    }
    _getConnectionStatusLabel() {
        switch (this.connectionStatus) {
            case models_1.ConnectionStatus.Connected:
                return this.translateI18nItem(I18nKeys.ONLINE);
            case models_1.ConnectionStatus.Connecting:
            case models_1.ConnectionStatus.Disconnecting:
            case models_1.ConnectionStatus.Disconnected:
                return this.translateI18nItem(I18nKeys.OFFLINE);
        }
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: null })
], CTCLHeader.prototype, "backgroundColor", void 0);
exports.CTCLHeader = CTCLHeader;
CTCLHeader.register();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __webpack_require__(11);
var CommonI18nKeys;
(function (CommonI18nKeys) {
    // tslint:disable no-any
    CommonI18nKeys[CommonI18nKeys["TODAY"] = "Today"] = "TODAY";
    CommonI18nKeys[CommonI18nKeys["YESTERDAY"] = "Yesterday"] = "YESTERDAY";
    CommonI18nKeys[CommonI18nKeys["ARE_YOU_SURE"] = "Are you sure?"] = "ARE_YOU_SURE";
    CommonI18nKeys[CommonI18nKeys["PLEASE_WAIT"] = "Please wait..."] = "PLEASE_WAIT";
    CommonI18nKeys[CommonI18nKeys["AUTHENTICATING"] = "Authenticating..."] = "AUTHENTICATING";
    CommonI18nKeys[CommonI18nKeys["SYNCING"] = "Syncing with server..."] = "SYNCING";
    CommonI18nKeys[CommonI18nKeys["LOGIN_ERROR_TITLE"] = "Error logging in"] = "LOGIN_ERROR_TITLE";
    CommonI18nKeys[CommonI18nKeys["LOGIN_ERROR_GENERIC"] = "Check your connectivity and credentials and try again."] = "LOGIN_ERROR_GENERIC";
    CommonI18nKeys[CommonI18nKeys["USER_NOT_FOUND"] = "User {{username}} was not found."] = "USER_NOT_FOUND";
    CommonI18nKeys[CommonI18nKeys["FETCH_ERROR"] = "Error fetching data"] = "FETCH_ERROR";
    CommonI18nKeys[CommonI18nKeys["LOGIN_TIMEOUT"] = "Logging in took longer than expected. Please check your connectivity and log in again."] = "LOGIN_TIMEOUT";
    CommonI18nKeys[CommonI18nKeys["LOGOUT_ERROR_TITLE"] = "Error logging out"] = "LOGOUT_ERROR_TITLE";
    CommonI18nKeys[CommonI18nKeys["UPLOAD_ERROR_TITLE"] = "Upload Error"] = "UPLOAD_ERROR_TITLE";
    CommonI18nKeys[CommonI18nKeys["UPLOAD_ERROR_DESCRIPTION"] = "Uploading your file failed. Please try again or try a different file."] = "UPLOAD_ERROR_DESCRIPTION";
    CommonI18nKeys[CommonI18nKeys["ERROR"] = "Error"] = "ERROR";
    // tslint:enable no-any
})(CommonI18nKeys = exports.CommonI18nKeys || (exports.CommonI18nKeys = {}));
exports.CommonMetadata = new index_1.Metadata("Common", CommonI18nKeys);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 25/01/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
// TODO: Fix linting issues
const es6_promise_1 = __webpack_require__(64);
const index_1 = __webpack_require__(42);
const environment_1 = __webpack_require__(43);
const File = __webpack_require__(30);
const Plugin = __webpack_require__(22);
const timer_1 = __webpack_require__(74);
const UsersDirectory_1 = __webpack_require__(73);
const utils_1 = __webpack_require__(31);
const vcard_simple_1 = __webpack_require__(75);
if (!window.Promise) {
    throw new Error("ct-xmpp-client.js has a dependency on Promise, did you forget to include the polyfill?");
}
if (!window.PouchDB) {
    throw new Error("ct-xmpp-client.js has a dependency on PouchDB, please ensure PouchDB is included before ct-xmpp-client.js");
}
class CtXmppClient {
    /**
     * Client constructor method.
     * @param instanceId - Unique identifier for this instance of CtXmppClient
     * @param endpoint - The server location (e.g. wss://chat.commontime.com:5281/websocket)
     * @param options
     */
    constructor(instanceId, endpoint, options) {
        this._userDirectory = null;
        this._includeStanzaFilters = [];
        this._excludeStanzaFilters = [];
        this._pushNodeName = null;
        /**
         * Private method which takes the Strophe status ID and adds a human readable label, saving it to the store
         * @param {number} statusId
         * @param {boolean} dispatch - Whether the status change should be dispatched as an event
         * @private
         */
        this._lastStatusId = null;
        this._pingInterval = null;
        /**
         * Private variable to hold the ping timeout
         */
        this._pingTimeout = null;
        this._alreadyReLoggingIn = false;
        this._reLoginTimeout = null;
        this._reLoginBackOff = 3000;
        /**
         * Method to force a logout and clean up, useful for bailing and cleaning up after a disconnect during login
         */
        this._forcedLogout = false;
        this._sendTimeouts = {};
        this._sendStanzaPromises = {};
        /**
         * Private variable to indicate the databases are being destroyed
         */
        this._destroyingDbs = false;
        this._joinedRooms = {};
        this._saveDebounce = {};
        /**
         * Methods realted to Infinity Bot Communication
         */
        this._botCommandTimeouts = {};
        this._botCommandPromises = {};
        this._initialised = false;
        if (!instanceId) {
            throw new Error("An instance ID must be provided.");
        }
        this._instanceId = instanceId;
        let currentArchiveId = localStorage.getItem(`${this._instanceId}_last_archive_id`);
        if (currentArchiveId === null) {
            currentArchiveId = "0"; // Leave this as a string so we don't have to parseInt
        }
        this._lastArchiveId = currentArchiveId;
        if (!endpoint) {
            throw new Error("XMPP server hostname must be provided.");
        }
        this._serverTimeDiff = null;
        this._eventListeners = {};
        this._options = CtXmppClient._merge({
            sendTimeout: 300000,
            debug: false,
            perfLogging: false,
            mucHost: null,
            uploadHost: null,
            echoHost: null,
            authAttachments: false,
            mam: {
                auto: true,
                defaultTimeLimit: 2.628e+9,
                pageSize: 250
            },
            push: {
                androidEnabled: false,
                packageId: "",
                senderId: "",
                iosEnabled: false
            },
            enablePing: true,
            pingInterval: 5000,
            pingTimeout: 10000,
            connectTimeout: 7000,
            autoLogin: false,
            autoReconnect: true,
            autoMarkMessages: true,
            encryption: false,
            fileEncryption: false,
            autoDownloadAttachmentTime: -1,
            autoPurgeOldMessagesAge: -1,
            autoPurgeOldMessagesCount: -1,
            streamResumption: true,
            useEncodedJidAsResource: false,
            adSpn: null,
            adSecurityPackage: null,
            adTokenPlaceholder: "[[AD_PASSWORD_TOKEN]]",
            updateUserDirectoryOnLogin: false,
            enableMessageCarbons: false,
            maxReconnectBackoff: 300000,
            stropheLogging: false,
            forceIndexedDb: false,
            bringToForegroundOnVoipPush: true,
            updateUserDirectoryInterval: 30 * 1000 * 60,
            useConnectionEvents: true,
            autoResumeTimers: true,
            maxStreamResumptionTime: null,
            alwaysSendPresence: false,
            updateRosterOnLogin: true
        }, options);
        this._endpoint = endpoint;
        this._connection = null;
        this.connected = false;
        this.loggedIn = false;
        this._reLoggingIn = false;
        this._loggingOut = false;
        this._jid = null;
        this.resource = null;
        this._bareJid = null;
        this.username = null;
        this._userDirectory = new UsersDirectory_1.UsersDirectory(this._instanceId, this._options.debug);
        if (this._options.stropheLogging === true) {
            index_1.default.Strophe.log = (level, msg) => {
                this._log(`[${level}]: ${msg}`);
            };
        }
        es6_promise_1.Promise.all([this._getInstallId(), this._initDbs()]).then(() => {
            this._initialised = true;
            this._log("XMPP client successfully initialised.");
            this._dispatchEvent(CtXmppClient.EVENT_TYPES.INITIALISED, null);
            if (this._options.autoLogin === true) {
                const proms = [this._getCacheItem("user_jid"), this._getCacheItem("user_password")];
                es6_promise_1.Promise.all(proms).then((data) => {
                    const jid = data[0];
                    const password = data[1];
                    if (jid !== undefined && password !== undefined) {
                        this._reLogin();
                    }
                }).catch((e) => {
                    this._onError("Unable to get jid/pw: " + e);
                });
            }
        }).catch(e => {
            throw new Error(e);
        });
        // Register events for online/offline
        if (this._options.useConnectionEvents) {
            document.addEventListener("offline", () => {
                this._onOffline();
            }, false);
            document.addEventListener("online", () => {
                this._onOnline();
            }, false);
        }
    }
    /**
     * Method which allows setting the send timeout
     * @param {number} value - The number of milliseconds to wait until marking a message as failed to send
     */
    set sendTimeout(value) {
        if (value === this._options.sendTimeout)
            return;
        this._options.sendTimeout = value;
    }
    /**
     * Getter method which retrieves the current connection status
     */
    get status() {
        this._isMethodReady(true);
        return this._getCacheItem("connection_status");
    }
    /**
     * Getter method to retrieve the bareJid
     * @returns {string}
     */
    get bareJid() {
        return this._bareJid;
    }
    /**
     * Getter method to retrieve the mucHost from _options
     * @returns {string}
     */
    get mucHost() {
        return this._options.mucHost;
    }
    /**
     * Add a filter function that returns true if stanza is NOT to be ignored.
     * @param filter function, takes message, returns boolean
     */
    addIncludeStanzaFilter(filter) {
        this._includeStanzaFilters.push(filter);
    }
    /**
     * Add a filter function that returns true if stanza IS to be ignored.
     * @param filter function, takes message, returns boolean
     */
    addExcludeStanzaFilter(filter) {
        this._excludeStanzaFilters.push(filter);
    }
    /**
     * Run when the device goes offline, and no network is available
     * @private
     */
    _onOffline() {
        // this._connection.disconnect("gone_offline");
        this._connection._doDisconnect();
    }
    /**
     * Run when the device goes online, and network is available
     * @private
     */
    _onOnline() {
        if (!this.connected)
            this.reLoginNow();
    }
    /**
     * Gets us a unique id to use in push and as resource.
     * @returns {Promise<void>}
     * @private
     */
    _getInstallId() {
        const INSTALL_ID = "install_id";
        return new es6_promise_1.Promise((resolve, reject) => {
            const installId = localStorage.getItem(`${this._instanceId}_install_id`);
            if (installId === null) {
                let that = this;
                if (environment_1.getPlatformName() === "ios") {
                    const secureSettings = Plugin.getSource("securesettings");
                    secureSettings.get((value) => {
                        if (typeof value === 'string') {
                            that._installId = value;
                            localStorage.setItem(`${that._instanceId}_install_id`, that._installId);
                            resolve();
                        }
                        else {
                            const newInstallId = utils_1.generateGuid();
                            secureSettings.set(() => {
                                that._installId = newInstallId;
                                localStorage.setItem(`${that._instanceId}_install_id`, that._installId);
                                resolve();
                            }, (error) => {
                                reject(error);
                            }, INSTALL_ID, newInstallId);
                        }
                    }, (error) => {
                        that._log("Secure settings error:", error);
                        reject(error);
                    }, INSTALL_ID);
                }
                else if (environment_1.getPlatformName() === "android") {
                    const devicePlugin = Plugin.getSource("device");
                    this._installId = devicePlugin.uuid;
                    localStorage.setItem(`${this._instanceId}_install_id`, this._installId);
                    resolve();
                }
                else {
                    const newInstallId = utils_1.generateGuid();
                    that._installId = newInstallId;
                    localStorage.setItem(`${this._instanceId}_install_id`, this._installId);
                    resolve();
                }
            }
            else {
                this._installId = installId;
                return resolve();
            }
        });
    }
    /**
     * Private method to create all databases
     * @private
     */
    _initDbs() {
        return new es6_promise_1.Promise((resolve, reject) => {
            const options = {
                auto_compaction: false,
                revs_limit: 1
            };
            this._msgDb = new window.PouchDB(`${this._instanceId}_messages`, options);
            this._contactDb = new window.PouchDB(`${this._instanceId}_contacts`, options);
            this._cacheDb = new window.PouchDB(`${this._instanceId}_cache`, options);
            this._cache = {};
            this._roomDb = new window.PouchDB(`${this._instanceId}_rooms`, options);
            this._participantDb = new window.PouchDB(`${this._instanceId}_participants`, options);
            const compactPromises = [];
            compactPromises.push(this._msgDb.compact());
            compactPromises.push(this._contactDb.compact());
            compactPromises.push(this._cacheDb.compact());
            compactPromises.push(this._roomDb.compact());
            compactPromises.push(this._participantDb.compact());
            es6_promise_1.Promise.all(compactPromises).then((results) => {
                this._log(`Compaction results: ${results}`);
                // Enable encryption if requested
                if (this._options.encryption === true) {
                    utils_1.getEncryptionKey(this._instanceId).then((keyBuffer) => {
                        this._cacheDb.crypto({ "key": keyBuffer });
                        this._msgDb.crypto({ "key": keyBuffer });
                        this._contactDb.crypto({ "key": keyBuffer });
                        this._roomDb.crypto({ "key": keyBuffer });
                        this._participantDb.crypto({ "key": keyBuffer });
                        resolve();
                    }).catch(reject);
                }
                else {
                    console.warn("Encryption has not been enabled! If you have auto-reconnect, auto-login or authenticated attachments enabled your password will be stored unencrypted! ");
                    resolve();
                }
            }).catch((e) => {
                this._log(`Compaction errors: ${e}`);
                reject(e);
            });
        });
    }
    _setStatus(statusId, dispatch = true, condition = null) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (this._lastStatusId === statusId) {
                resolve();
            }
            else {
                const statusObj = {
                    id: statusId,
                    label: null,
                    reason: condition
                };
                switch (statusId) {
                    case index_1.default.Strophe.Status.CONNECTING:
                        statusObj.label = "Connecting";
                        break;
                    case index_1.default.Strophe.Status.CONNFAIL:
                        statusObj.label = "Connection failed";
                        break;
                    case index_1.default.Strophe.Status.DISCONNECTING:
                        statusObj.label = "Disconnecting";
                        break;
                    case index_1.default.Strophe.Status.DISCONNECTED:
                        statusObj.label = "Disconnected";
                        break;
                    case index_1.default.Strophe.Status.CONNECTED:
                        statusObj.label = "Connected";
                        break;
                    case index_1.default.Strophe.Status.AUTHFAIL:
                        statusObj.label = "Authentication failed.";
                        break;
                    case index_1.default.Strophe.Status.ERROR:
                        statusObj.label = condition || "An unknown error occurred.";
                        break;
                }
                if (this._lastStatusId !== statusObj.id && dispatch !== false) {
                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.STATUS, statusObj);
                }
                this._lastStatusId = statusObj.id;
                this._setCacheItem("connection_status", statusObj).then(resolve).catch(reject);
            }
        });
    }
    static _isReasonToReconnect(condition) {
        if (!condition || typeof condition !== "string")
            return true;
        let result = true;
        switch (condition.toLowerCase()) {
            case "kicked by administrator":
            case "replaced by new connection":
            case "conflict":
                result = false;
                break;
        }
        return result;
    }
    static _translateCondition(condition) {
        if (!condition)
            return null;
        switch (condition.toLowerCase()) {
            case "conflict":
                return "You already have an active session. Please log out of any previous sessions or wait for the previous login attempt to timeout.";
            case "system-shutdown":
                return "Remote server was shut down.";
            case "connection-timeout":
                return "The connection to the server timed out.";
            case "socket closed, probably due to no network connectivity.":
            case "invalid username or password":
            case "kicked by administrator":
                return condition;
            default:
                return "Connection closed unexpectedly.";
        }
    }
    /**
     * Private method which is used to initiate a WebSocket connection to the XMPP server using the Strophe API
     * @param {String} jid
     * @param {String} password
     * @returns {Promise}
     * @private
     */
    _connect(jid, password) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (this._connection && this._connection.connected) {
                // tslint-disable-next-line
                // this._connection.disconnect("make_sure", true);
                this._connection._doDisconnect();
            }
            // Create a fresh connection object
            this._connection = new index_1.default.Strophe.Connection(this._endpoint, {
                instance_id: this._instanceId
            });
            // Attach various event handlers
            this._connection.addHandler(this._onStanza.bind(this), null, "message");
            this._connection.addHandler(($xml) => {
                return this._onPresence(CtXmppClient.xmlToJson($xml));
            }, null, "presence");
            this._connection.addHandler(($xml) => {
                return this._onIq(CtXmppClient.xmlToJson($xml));
            }, null, "iq");
            // We only attempt to connect for this duration and assume connection
            // has failed if we reach this limit
            const connectTimeout = setTimeout(() => {
                // Calling private Strophe method to ensure socket is closed.
                this._connection._doDisconnect();
                reject("Connection took more than 5 seconds to be established, connection closed.");
            }, this._options.connectTimeout);
            const prom = (this._options.streamResumption === true) ? this._getCacheItem("stream_management_id") : es6_promise_1.Promise.resolve();
            prom.then((smId) => {
                this._connection.streamManagement.prevId = smId;
                let finished = false;
                // Start the connection process
                if (this._forcedLogout) {
                    if (this._options.useEncodedJidAsResource === true)
                        this._connection.override = true;
                    this._forcedLogout = false;
                }
                this._connection.connect(jid, password, (status, condition) => {
                    if (this._reLoggingIn !== true)
                        this._setStatus(status, true, condition);
                    if (finished === true)
                        return false;
                    switch (status) {
                        case index_1.default.Strophe.Status.ERROR:
                        case index_1.default.Strophe.Status.AUTHFAIL:
                        case index_1.default.Strophe.Status.CONNFAIL:
                        case index_1.default.Strophe.Status.DISCONNECTED:
                            const reason = CtXmppClient._translateCondition(condition);
                            let msg = "Connection Disconnected";
                            if (status === index_1.default.Strophe.Status.ERROR) {
                                msg = "Connection Error";
                                this._onError(msg, reason);
                            }
                            if (status === index_1.default.Strophe.Status.AUTHFAIL) {
                                msg = "Authentication Failed";
                            }
                            if (status === index_1.default.Strophe.Status.CONNFAIL)
                                msg = "Connection Failed";
                            if (reason !== null) {
                                msg += ": " + reason;
                            }
                            const pauseOrEndTimers = (id, timers) => {
                                const timer = timers[id];
                                if (!timer.pauseable) {
                                    // If the timer isn't pauseable then we want to end it
                                    this._log(`Ending timer for request with ID '${id}'...`);
                                    timer.end();
                                }
                                else if (!timer.paused) {
                                    // Otherwise if its not already paused, pause it
                                    this._log(`Pausing timer for request with ID '${id}'...`);
                                    timer.pause();
                                }
                            };
                            // If we have any outstanding send timeouts, pause them until we re-establish a connection
                            if (Object.keys(this._sendTimeouts).length > 0) {
                                Object.keys(this._sendTimeouts).forEach((messageId) => pauseOrEndTimers(messageId, this._sendTimeouts));
                            }
                            // If we have any outstanding bot command timeouts, pause them until we re-establish a connection
                            if (Object.keys(this._botCommandTimeouts).length > 0) {
                                Object.keys(this._botCommandTimeouts).forEach((messageId) => pauseOrEndTimers(messageId, this._botCommandTimeouts));
                            }
                            clearTimeout(connectTimeout);
                            this.connected = false;
                            // Clear any reconnect timeout so it stops trying to reconnect, we've been fully disconnected
                            // so we need to re-login to create a new socket.
                            this._stopPing();
                            // If the user didn't initiate the logout manually, start the re-login process.
                            this._log("Disconnected:", condition);
                            this._alreadyReLoggingIn = false;
                            if (this._loggingOut === false && this._options.autoReconnect === true && status !== index_1.default.Strophe.Status.AUTHFAIL && CtXmppClient._isReasonToReconnect(condition) === true) {
                                // If we've had a disconnect status change then we have lost the WebSocket completely so the "reconnect" phase is over
                                // We now need to re-login to create a new socket.
                                this._log("Attempting to re-login...");
                                this._reLogin();
                            }
                            finished = true;
                            reject({ "msg": msg, "status": status, "condition": condition });
                            break;
                        case index_1.default.Strophe.Status.CONNECTED:
                            clearTimeout(connectTimeout);
                            this.connected = true;
                            resolve(condition);
                    }
                });
            });
        });
    }
    /**
     * Private method used as part of the login process to setup and handle stream management - stream management is a requirement of this XMPP client implementation
     * @returns {Promise}
     * @private
     */
    _enableStreamManagement() {
        return new es6_promise_1.Promise((resolve, reject) => {
            const disconnectCallback = (status) => {
                if (status.id === index_1.default.Strophe.Status.DISCONNECTED) {
                    this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                    reject(`Disconnected during stream management enabling.`);
                }
            };
            this.addEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
            if (this.connected === false || this._connection === null) {
                reject("You must have an active connection to enable stream management");
            }
            else {
                if (!this._connection.streamManagement) {
                    throw new Error("Stream management is required.");
                }
                try {
                    this._connection.addHandler(($stanza) => {
                        this._log("Stream resumption enabled!");
                        this._setCacheItem("stream_management_id", $stanza.getAttribute("id")).then(() => {
                            this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                            resolve();
                        });
                        return false;
                    }, "urn:xmpp:sm:3", "enabled");
                    this._connection.streamManagement.enable(this._options.maxStreamResumptionTime);
                }
                catch (e) {
                    console.error(e);
                    reject();
                }
            }
        });
    }
    /**
     * Private method used as part of the login process to enable message carbons
     * @returns {Promise}
     * @private
     */
    _enableMessageCarbons() {
        return this.sendIq(null, "set", {
            enable: {
                $attributes: {
                    xmlns: CtXmppClient.NAMESPACES.CARBONS
                },
                $value: ""
            }
        });
    }
    /**
     * Method to start the ping process to detect when we lose connection
     * @returns {Promise}
     * @private
     */
    _initialisePing() {
        return new es6_promise_1.Promise((resolve) => {
            if (this._options.enablePing === true) {
                // Clear any existing interval
                if (this._pingInterval !== null)
                    clearInterval(this._pingInterval);
                // Start the interval which sends the ping
                this._pingInterval = setTimeout(() => {
                    this._sendPing().then(() => {
                        this._initialisePing();
                    }).catch(() => {
                        // If a ping fails then start the reconnect process
                        this._log("Ping failed.");
                        // Stop pinging
                        // clearInterval(this._pingInterval);
                        // Start the reconnect process
                        if (this._options.autoReconnect === true) {
                            this._log("Auto-reconnect enabled, so let's try and reconnect!");
                            // if (this._connection) this._connection.disconnect("ping_timeout", true);
                            if (this._connection)
                                this._connection._doDisconnect();
                            this._reLogin();
                        }
                    });
                }, this._options.pingInterval);
            }
            resolve();
        });
    }
    /**
     * Method which sends a ping IQ
     * @returns {Promise}
     * @private
     */
    _sendPing() {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Create our own timeout here because the Strophe timeout for IQ messages doesn't work when the WebSocket dies in Safari
            this._pingTimeout = setTimeout(() => {
                // If we are not connected, just ignore this timeout
                if (!this.connected) {
                    resolve();
                    return;
                }
                this.connected = false;
                this._setStatus(index_1.default.Strophe.Status.DISCONNECTED);
                if (this._options.autoReconnect === true)
                    this._setStatus(index_1.default.Strophe.Status.CONNECTING);
                reject();
            }, this._options.pingTimeout);
            this.sendIq(this._domain, "get", {
                ping: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.PING
                    }
                }
            }).then(() => {
                // Clear any existing timeout
                clearTimeout(this._pingTimeout);
                resolve();
            }).catch(reject);
        });
    }
    _makeParticipantsOffline() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._participantDb.allDocs({ "include_docs": true }).then((results) => {
                const participants = results.rows.filter((row) => {
                    // TODO: Figure out what to do with PouchDB views? Filtering them out for now
                    return (!row.doc.language);
                }).map((row) => {
                    row.doc.online = false;
                    return row.doc;
                });
                this._participantDb.bulkDocs(participants).then(resolve).catch((error) => {
                    this._onError(`Unable to bulk update participants to offline status.`, error);
                    reject(error);
                });
            }).catch((error) => {
                this._onError(`Unable to get participants from database.`, error);
                reject(error);
            });
        });
    }
    _makeContactsOffline() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getContacts().then(contacts => {
                contacts.forEach((contact) => {
                    contact.online = false;
                });
                this._contactDb.bulkDocs(contacts).then(function () {
                    resolve();
                }).catch((error) => {
                    this._onError(`Unable to bulk update contacts to offline status.`, error);
                    reject(error);
                });
            }).catch((error) => {
                this._onError(`Unable to get contacts from database.`, error);
                reject(error);
            });
        });
    }
    resumeTimers() {
        // Resume any send timeouts
        if (Object.keys(this._sendTimeouts).length > 0) {
            Object.keys(this._sendTimeouts).forEach((messageId) => {
                const timer = this._sendTimeouts[messageId];
                if (timer.paused) {
                    this._log(`Resuming send timer for request with ID '${timer.id}'...`);
                    timer.resume();
                }
            });
        }
        // If we have any paused bot command timeouts, resume them
        if (Object.keys(this._botCommandTimeouts).length > 0) {
            Object.keys(this._botCommandTimeouts).forEach((requestId) => {
                const timer = this._botCommandTimeouts[requestId];
                if (timer.paused) {
                    this._log(`Resuming bot command timer for request with ID '${timer.id}'...`);
                    timer.resume();
                }
            });
        }
    }
    reLoginNow() {
        if (this._alreadyReLoggingIn) {
            this._log("Not executing reLoginNow() because _alreadyReLoggingIn is currently 'true'.");
            return;
        }
        this._alreadyReLoggingIn = true;
        // Also call this here incase user calls this method directly
        this._clearReLoginTimeout();
        const proms = [this._getCacheItem("user_jid"), this._getCacheItem("user_password")];
        es6_promise_1.Promise.all(proms).then((data) => {
            const jid = data[0];
            const password = data[1];
            if (jid !== undefined && password !== undefined) {
                this._log(`Auto-logging in with JID '${jid}'.`);
                this._setStatus(index_1.default.Strophe.Status.CONNECTING);
                this._login(jid, password, true).then((resumed) => {
                    // If auto-login is successful reset everything and continue
                    this._reLoginBackOff = 3000;
                    this._log(`Auto-login success.`);
                    this._reLoggingIn = false;
                    this.connected = true;
                    const proms = [];
                    for (let room in this._joinedRooms) {
                        proms.push(this.joinRoom(room));
                    }
                    es6_promise_1.Promise.all(proms).then(() => {
                        this._setStatus(index_1.default.Strophe.Status.CONNECTED).then(() => {
                            // Now we have successfully auto-reconnected resume any paused timers
                            if (this._options.autoResumeTimers !== false)
                                this.resumeTimers();
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.AUTO_RECONNECTED, {
                                resumed: resumed
                            });
                            this._alreadyReLoggingIn = false;
                        }).catch((e) => {
                            this._alreadyReLoggingIn = false;
                            console.error("Couldn't set connection status:", e);
                        });
                    }).catch((e) => {
                        this._onError("Couldn't join all rooms on re-login, logging out.", e);
                        this.logout();
                        this._alreadyReLoggingIn = false;
                    });
                }).catch((e) => {
                    this._alreadyReLoggingIn = false;
                    if (e.status == index_1.default.Strophe.Status.AUTHFAIL) {
                        const statusObj = {
                            "id": index_1.default.Strophe.Status.DISCONNECTED,
                            "label": "Authentication Failed.",
                            "wontReconnect": true,
                            "reason": e.condition
                        };
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.STATUS, statusObj);
                    }
                    else {
                        // If we still cannot login then increase the back off value so we can try again soon
                        this._reLoginBackOff += 3000;
                        if (this._reLoginBackOff > this._options.maxReconnectBackoff) {
                            this._reLoginBackOff = this._options.maxReconnectBackoff;
                        }
                        this._log(`Couldn't re-login, trying again in ${(this._reLoginBackOff) / 1000} seconds...`);
                        this._reLogin();
                    }
                });
            }
        }).catch(e => {
            this._onError("Couldn't get user JID or user password for re-login!", e);
        });
    }
    /**
     * Method used either on app start or after the WebSocket has died
     * @private
     */
    _reLogin() {
        // Don't do this if the user manually logged out
        if (this._loggingOut === true) {
            this._log("Not executing _reLogin because _loggingOut is currently 'true'.");
            return;
        }
        this._reLoggingIn = true;
        this._clearReLoginTimeout();
        this._log("Re-login back off time is:", this._reLoginBackOff);
        if (this._reLoginBackOff > 0) {
            const statusObj = {
                "id": index_1.default.Strophe.Status.DISCONNECTED,
                "label": "Disconnected",
                "reconnectTime": this._reLoginBackOff
            };
            this._dispatchEvent(CtXmppClient.EVENT_TYPES.STATUS, statusObj);
        }
        // Create a timeout with the back off value to retry the login process
        this._reLoginTimeout = setTimeout(() => {
            this._log("Calling reLoginNow()...");
            this.reLoginNow();
        }, this._reLoginBackOff);
    }
    _clearReLoginTimeout() {
        if (this._reLoginTimeout !== null) {
            clearTimeout(this._reLoginTimeout);
            this._reLoginTimeout = null;
        }
    }
    /**
     * Simple method which stops the pinging process
     * @private
     */
    _stopPing() {
        if (this._pingTimeout !== null)
            clearTimeout(this._pingTimeout);
        if (this._pingInterval !== null)
            clearInterval(this._pingInterval);
    }
    /**
     * Convenience method to create a presence object using cached data
     * @returns {Promise}
     * @private
     */
    _createPresenceObject() {
        return new es6_promise_1.Promise((resolve, reject) => {
            const pres = {
                "$attributes": {
                    "from": this._jid,
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                }
            };
            pres.show = "chat";
            pres.status = "Available";
            this._getCacheItem("chat_status").then((statusObject) => {
                if (statusObject !== undefined) {
                    if (statusObject.status) {
                        pres.show = statusObject.status;
                    }
                    if (statusObject.label) {
                        pres.status = statusObject.label;
                    }
                    if (statusObject.metadata) {
                        pres.metadata = CtXmppClient._merge({
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.CT_METADATA
                            }
                        }, statusObject.metadata);
                    }
                }
                resolve(pres);
            }).catch(err => {
                this._onError("Couldn't get chat status to construct presence object!", err);
                reject(err);
            });
        });
    }
    /**
     * Public function to send Presence
     */
    sendPresence() {
        return this._sendPresence();
    }
    /**
     * Uploads a single attachment then returns the uploaded get path as a string.
     * @param filePath The filepath to the file on disk that you wish to upload.
     */
    uploadAttachment(filePath) {
        if (!this._options.uploadHost)
            throw new Error("Cannot send attachments without a upload host configured.");
        let promiseChain = es6_promise_1.Promise.resolve({});
        let file = null;
        promiseChain = promiseChain
            .then(() => {
            return new es6_promise_1.Promise((resolve, reject) => {
                File.getFileInfo(filePath).then((fileInfo) => {
                    file = fileInfo;
                    resolve();
                }).catch(reject);
            });
        })
            .then(() => {
            return new es6_promise_1.Promise((resolve, reject) => {
                // Get the size of the file, if encrypted get the unencrypted file size
                File.getFileSize(file).then((size) => {
                    // Ask for an upload slot for each of the attachments
                    const uploadIq = {
                        "$attributes": {
                            "id": this.getUniqueId(),
                            "to": this._options.uploadHost,
                            "from": this._jid,
                            "type": "get",
                            "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                        },
                        "request": {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.HTTP_UPLOAD,
                            },
                            "filename": file.name.replace(".encrypted", ""),
                            "size": "" + size,
                            "content-type": file.type
                        }
                    };
                    this.sendIq(this._options.uploadHost, "get", uploadIq).then(resolve).catch(reject);
                }).catch(e => {
                    console.error(`Couldn't get file size for file with name '${file.name}'.`, e);
                    reject(e);
                });
            });
        })
            .then((_stanza) => {
            return new es6_promise_1.Promise(resolve => {
                // If the attachment endpoints are authenticated then we need to grab the password from the secure DB
                if (this._options.authAttachments === true) {
                    this._getCacheItem("user_password").then(password => {
                        return this._embellishPasswordWithAdToken(password);
                    }).then(_password => {
                        resolve([_stanza, {
                                "Authorization": "Basic " + btoa(this._bareJid + ":" + _password),
                                "Content-Type": file.type
                            }]);
                    });
                }
                else {
                    // Otherwise we can just do the upload without any auth
                    resolve([_stanza, {
                            "Content-Type": file.type
                        }]);
                }
            });
        })
            .then((result) => {
            const _stanza = result[0];
            const _headers = result[1];
            return new es6_promise_1.Promise((resolve, reject) => {
                const put = _stanza.iq.slot.put;
                const get = _stanza.iq.slot.get;
                File.upload(file.path, put, get, _headers).then(() => {
                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_SUCCESS, file.path);
                    resolve(get);
                }).catch((e) => {
                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_FAILED, file.path);
                    const msg = `Couldn't successfully upload file '${file.path}' to the server:`;
                    this._onError(msg, e);
                    reject({ error: msg });
                });
            });
        });
        return new es6_promise_1.Promise((resolve, reject) => promiseChain.then(resolve).catch(reject));
    }
    /**
     * Convenience method to send presence to contacts and joined rooms
     * @private
     */
    _sendPresence() {
        this._log(`Sending presence...`);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._log(`Creating presence object...`);
            this._createPresenceObject().then(stanza => {
                this._log(`Presence object created:`, stanza);
                this.sendStanza(stanza, false, "presence", false, false).then(() => {
                    this._log(`Presence sent!`);
                    this._log(`Sending presence for all rooms...`);
                    const proms = [];
                    for (let room in this._joinedRooms) {
                        stanza.$attributes["to"] = `${room}@${this._options.mucHost}`;
                        stanza["x"] = {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.MUC
                            }
                        };
                        proms.push(this.sendStanza(stanza, false, "presence", false, false));
                    }
                    es6_promise_1.Promise.all(proms).then(() => {
                        this._log(`Finished sending presence(s).`);
                        resolve();
                    }).catch((e) => {
                        this._onError("Couldn't send all presence objects:", e);
                        reject(e);
                    });
                }).catch((e) => {
                    this._onError("Couldn't send initial presence object:", e);
                    reject(e);
                });
            }).catch((e) => {
                this._onError("Couldn't create presence object:", e);
                reject(e);
            });
        });
    }
    /**
     * Method to get the server time and calculate the difference between the client and server time
     * @returns {Promise}
     */
    getServerTime() {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(this._domain, "get", {
                time: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.TIME
                    }
                }
            }).then((stanza) => {
                if (stanza.iq.time !== undefined && stanza.iq.time.utc) {
                    const server = new Date(stanza.iq.time.utc).valueOf();
                    const client = Date.now();
                    this._serverTimeDiff = (server - client);
                }
                resolve(this._serverTimeDiff);
            }).catch(reject);
        });
    }
    /**
     * Method used to sync a timestamp with the server time
     * @param ts
     * @returns {Number}
     */
    getSyncedTimestamp(ts) {
        // If we don't have a server time to work off then just return the specified ts
        if (this._serverTimeDiff === null)
            return ts;
        const diff = Math.abs(this._serverTimeDiff);
        return (this._serverTimeDiff >= 0) ? (ts + diff) : (ts - diff);
    }
    /**
     * Method to log the user in
     * @param jid
     * @param password
     * @returns {Promise}
     */
    login(jid, password) {
        return this._login(jid, password, false);
    }
    _login(jid, password, isReLogin = false) {
        this._isMethodReady(true);
        if (!jid)
            throw new Error("Parameter 'jid' must be provided.");
        if (!password)
            throw new Error("Parameter 'password' must be provided.");
        if (this._reLoggingIn === true && isReLogin === false) {
            // if we are in a re-logging-in state and a login request has come from a non-re-login source, then reset the flag and clear any pending re-login action
            this._clearReLoginTimeout();
            this._reLoggingIn = false;
        }
        this._loggingOut = false;
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getInstallId().then(() => {
                this._getCacheItem("user_jid").then((previousJid) => {
                    // If we are already logged in with the same user, just continue.
                    if (this.connected === true && this.loggedIn === true && previousJid === index_1.default.Strophe.getBareJidFromJid(jid)) {
                        resolve(false);
                    }
                    else {
                        // Has the resource been specified in the JID? If so, use that and move on.
                        const specifiedResource = index_1.default.Strophe.getResourceFromJid(jid);
                        if (specifiedResource !== null) {
                            this.resource = specifiedResource;
                            this._jid = jid;
                            this._bareJid = index_1.default.getBareJidFromJid(this._jid);
                        }
                        else {
                            this._bareJid = jid;
                            // Are we to use the jid as a resource
                            if (this._options.useEncodedJidAsResource === true) {
                                // If so base64 encode the bareJid and use as the resource
                                this.resource = btoa(this._bareJid);
                            }
                            else {
                                // If not do we have a previously generated one available?
                                const resource = localStorage.getItem(`${this._instanceId}_resource`);
                                // If not, generate one and stash it
                                if (resource === null) {
                                    this.resource = this._installId;
                                    localStorage.setItem(`${this._instanceId}_resource`, this.resource);
                                }
                                else {
                                    this.resource = resource;
                                }
                            }
                            this._jid = this._bareJid + "/" + this.resource;
                        }
                        const onLoginSuccess = () => {
                            // Set the logged-in flag
                            this.loggedIn = true;
                            // Remove the logging-in flag
                            localStorage.removeItem(`${this._instanceId}_logging_in`);
                        };
                        this.username = index_1.default.Strophe.getNodeFromJid(this._jid);
                        this._domain = this._bareJid.split("@")[1];
                        const __completeLogin = () => {
                            let resumed = false;
                            // If the previous login failed then we want to do a force logout to clear the SM ID to prevent stream resumption
                            // This is important because it will then force presence to be sent, the MAM to be queried or other non-resumption processes
                            // which might have not happened due to a login failure
                            const forceLogout = (localStorage.getItem(`${this._instanceId}_logging_in`) !== null);
                            if (forceLogout)
                                this._log("Previous login attempt failed, calling a force logout to clean-up.");
                            // Ensure we are logged out before we try and login
                            this.logout(forceLogout, true).then(() => {
                                // If we need to embellish the password with an AD token otherwise just return the password as is
                                return this._embellishPasswordWithAdToken(password);
                            })
                                .then((_password) => {
                                // Use the password provided from the embellish step in-case it has been modified
                                // We don't overwrite the provided password variable because we want the originally provided password
                                // to be persisted so that on re-connect we new AD token is obtained                                
                                return this._connect(this._jid, _password).then(condition => {
                                    resumed = (condition === "resumed");
                                    localStorage.setItem(`${this._instanceId}_logging_in`, "true");
                                });
                            })
                                .then(() => {
                                // Don't re-enable stream management if we have resumed a stream
                                return (resumed === false) ? this._enableStreamManagement() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // If we resumed we don't need to enable message carbons
                                return (resumed === false && this._options.enableMessageCarbons === true) ? this._enableMessageCarbons() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // If we have resumed we don't need to get the server time again
                                return (resumed === false) ? this.getServerTime() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // If we have resumed we will have the same JID as last time so don't re-cache
                                return (resumed === false) ? this._setCacheItem("user_jid", this._bareJid) : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                return new es6_promise_1.Promise((_resolve, _reject) => {
                                    if (resumed === false && (this._options.autoReconnect === true || this._options.autoLogin === true || this._options.authAttachments === true)) {
                                        this._setCacheItem("user_password", password, true).then(_resolve).catch(_reject);
                                    }
                                    else {
                                        _resolve();
                                    }
                                });
                            })
                                .then(() => {
                                if (!resumed) {
                                    return es6_promise_1.Promise.all([this._makeContactsOffline(), this._makeParticipantsOffline()]);
                                }
                                else {
                                    return;
                                }
                            })
                                .then(() => {
                                return new es6_promise_1.Promise((resolve, reject) => {
                                    if (!resumed && this.isPushEnabled()) {
                                        this._getPushTokens()
                                            .then((tokens) => {
                                            return this.registerForPush(tokens);
                                        }).then(() => {
                                            resolve();
                                        }).catch((e) => {
                                            this._log("Failed to register for push: " + e);
                                            resolve();
                                        });
                                    }
                                    else {
                                        resolve();
                                    }
                                });
                            })
                                .then(() => {
                                return this._initialisePing();
                            })
                                .then(() => {
                                return (this._options.updateUserDirectoryOnLogin === true) ? this.updateUserDirectory() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // Don't request the roster if we have resumed a stream
                                return (resumed === false && this._options.updateRosterOnLogin !== false) ? this._getCacheItem("roster_version").then((value) => {
                                    return this.sendIq(this._bareJid, "get", {
                                        "query": {
                                            "$attributes": {
                                                "xmlns": "jabber:iq:roster",
                                                "ver": value || ""
                                            }
                                        }
                                    });
                                }) : es6_promise_1.Promise.resolve();
                            })
                                .then(($roster) => {
                                return this._processRoster($roster);
                            })
                                .then(() => {
                                return new es6_promise_1.Promise((_resolve, _reject) => {
                                    if (resumed === false && this._options.mam.auto !== false) {
                                        const archiveId = this.getLastArchiveId();
                                        // Now get a list of the users current subscriptions
                                        this.listSubscriptions().then(subscriptions => {
                                            // For each room query the MAM using the last archive ID
                                            const proms = [];
                                            subscriptions.forEach((sub) => {
                                                proms.push(this.queryMamByRoomName(sub.name, true, archiveId));
                                            });
                                            es6_promise_1.Promise.all(proms).then(() => {
                                                // Now get personal items from the MAM
                                                // Have to do this after the room query otherwise the room query will use an archive ID from one of the MAM messages
                                                this.queryMam(null, archiveId).then(_resolve).catch((e) => {
                                                    this._onError(`Unable to query the MAM for missed messages.`, e);
                                                    _reject(e);
                                                });
                                            }).catch(e => {
                                                this._onError(`Unable to query the MAM for missed messages in a subscribed room.`, e);
                                                _reject(e);
                                            });
                                        }).catch(e => {
                                            this._onError(`Unable to get a list of subscriptions.`, e);
                                            _reject(e);
                                        });
                                    }
                                    else {
                                        _resolve();
                                    }
                                });
                            })
                                .then(() => {
                                // if (this._options.alwaysSendPresence || !resumed) {
                                //     this._log("Sending presence....");
                                //     this._sendPresence().then(() => {
                                //         onLoginSuccess();
                                //         this._log("Presence sent.");
                                //         resolve(resumed);
                                //     }).catch(() => {
                                //         const msg: string = "Unable to send presence";
                                //         this._onError(msg);
                                //         reject(msg);
                                //     });    
                                // } else {
                                //     this._log("NOT sending presence.");
                                //     onLoginSuccess();
                                //     resolve(resumed); 
                                // }
                                onLoginSuccess();
                                resolve(resumed);
                            })
                                .catch((e) => {
                                // If we fail part way through the login process and we haven't had a disconnection, fire one.
                                if (this._connection !== null && this._connection.connected === true) {
                                    // this._connection.disconnect("fail_during_login");
                                    this._connection._doDisconnect();
                                    this._connection = null;
                                }
                                this._onError(`Unable to complete login process with JID '${jid}'.`, e.msg);
                                reject(e);
                            });
                        };
                        // If we are logging in with a different person than last time we need to clear out the database
                        if (previousJid !== undefined && previousJid !== this._bareJid) {
                            this._clearDbsForNewUser().then(() => {
                                __completeLogin();
                            });
                        }
                        else {
                            __completeLogin();
                        }
                    }
                }).catch(reject);
            }).catch(reject);
        });
    }
    isPushEnabled() {
        if (this._options.push.androidEnabled && environment_1.getPlatformName() === "android") {
            return true;
        }
        if (this._options.push.iosEnabled && environment_1.getPlatformName() === "ios") {
            return true;
        }
        return false;
    }
    /**
     * Method to initiate the logout process
     * @param forceClean - Force a clean-up which clears user password and stream management ID, this will prevent a reconnect
     * @returns {Promise}
     */
    logout(forceClean = false, dontClearPassword = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const cleanUp = () => {
                this._joinedRooms = {};
                this._reLoggingIn = false;
                this.connected = false;
                this.loggedIn = false;
                this._stopPing();
                this._clearReLoginTimeout();
                localStorage.removeItem(`${this._instanceId}_logging_in`);
                // Remove password and stream_management_id from cache
                const proms = [this._deleteCacheItem("stream_management_id")];
                if (dontClearPassword !== true)
                    proms.push(this._deleteCacheItem("user_password"));
                es6_promise_1.Promise.all(proms).then(() => {
                    this._loggingOut = false;
                    resolve();
                }).catch(reject);
            };
            if (forceClean !== true && (this.connected === false || this._loggingOut === true)) {
                resolve();
            }
            else if (this._connection !== null && this._connection.connected === true && this._loggingOut === false) {
                this._loggingOut = true;
                const doDisconnect = () => {
                    this._stopPing();
                    this._clearReLoginTimeout();
                    this._connection.disconnect("user_logout");
                    this._connection = null;
                    cleanUp();
                };
                if (this.isPushEnabled()) {
                    this.disablePush()
                        .then(() => {
                        doDisconnect();
                    }).catch((e) => {
                        this._log(`Unable to disable push notifications: ${e}`);
                        doDisconnect();
                    });
                }
                else {
                    doDisconnect();
                }
            }
            else {
                cleanUp();
            }
        });
    }
    forceLogout() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._forcedLogout = true;
            this._loggingOut = true;
            this._joinedRooms = {};
            this._reLoggingIn = false;
            this.connected = false;
            this.loggedIn = false;
            this._stopPing();
            this._clearReLoginTimeout();
            localStorage.removeItem(`${this._instanceId}_logging_in`);
            if (this._connection) {
                this._connection.disconnect("user_logout");
                this._connection = null;
            }
            es6_promise_1.Promise.all([
                this._deleteCacheItem("stream_management_id"),
                this._deleteCacheItem("user_password")
            ]).then(() => {
                this._loggingOut = false;
                resolve();
            }).catch(reject);
        });
    }
    /**
     * Method to (re)send a message given its id
     * @param messageId
     * @returns {Promise}
     */
    resendMessage(messageId) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getMessageById(messageId).then(message => {
                this._log(`Resending message with ID '${messageId}':`, message);
                const stanza = {
                    "$attributes": {
                        "id": message._id,
                        "to": message.recipient_id,
                        "from": message.sender_id,
                        "type": message.type,
                        "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                    },
                    "markable": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.CHAT_MARKERS
                        }
                    },
                    "body": message.body,
                    "data": message.data,
                    "attachments": []
                };
                if (message.addresses !== undefined) {
                    stanza.addresses = {
                        $attributes: {
                            xmlns: CtXmppClient.NAMESPACES.ADDRESS
                        },
                        address: message.addresses
                    };
                }
                message.attachments.forEach((attachment) => {
                    stanza.attachments.push({
                        name: attachment.name,
                        type: attachment.type,
                        size: "" + attachment.size,
                        get: attachment.get
                    });
                });
                this.sendStanza(stanza).then(() => {
                    resolve(message);
                }).catch(reject);
            }).catch(reject);
        });
    }
    _stanzaResponseHandler(messageId, error) {
        if (this._sendTimeouts[messageId]) {
            this._log(`Clearing send timeout for message with ID '${messageId}'.`);
            this._sendTimeouts[messageId].cancel();
            delete this._sendTimeouts[messageId];
        }
        if (!error) {
            this._resolveSendStanzaPromise(messageId);
        }
        else {
            this._rejectSendStanzaPromise(messageId, error);
        }
    }
    _resolveSendStanzaPromise(messageId, data) {
        if (!this._sendStanzaPromises[messageId])
            return;
        this._log(`Resolving send stanza promise for message with ID '${messageId}'.`);
        this._sendStanzaPromises[messageId].resolve(data);
        delete this._sendStanzaPromises[messageId];
        if (this._sendTimeouts[messageId])
            delete this._sendTimeouts[messageId];
    }
    _rejectSendStanzaPromise(messageId, data) {
        if (!this._sendStanzaPromises[messageId])
            return;
        this._log(`Rejecting send stanza promise for message with ID '${messageId}'.`);
        this._sendStanzaPromises[messageId].reject(data);
        delete this._sendStanzaPromises[messageId];
        if (this._sendTimeouts[messageId])
            delete this._sendTimeouts[messageId];
    }
    /**
     * Method which converts a JSON stanza to XML and then sends it over the socket
     * @param stanza
     * @param store - Hint to ejabberd that this message should be stored in the MAM
     * @param type - What node should this stanza be? Defaults to <message>, overridden when sending a <presence>
     * @param pauseableTimer - If the timer can be paused when we get a disconnect, if not the timer will be ended on a disconnect
     * @returns {Promise}
     */
    sendStanza(stanza, store = true, type = "message", timestamp = true, pauseableTimer = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            // Add stanza ID if it doesn't already have one
            if (!stanza.$attributes)
                stanza.$attributes = {};
            if (stanza.$attributes.id === undefined) {
                stanza.$attributes.id = this.getUniqueId();
            }
            let messageId = stanza.$attributes.id;
            if (this.connected === true && this._connection !== null) {
                this._sendStanzaPromises[messageId] = {
                    resolve: resolve,
                    reject: reject
                };
                // Create a timer for each sent stanza to ensure the promise gets resolved if there is no response from the server
                this._sendTimeouts[messageId] = new timer_1.default(messageId, () => {
                    const msg = `${type.replace(/^\w/, c => c.toUpperCase())} with ID '${messageId}' was not received by the server within ${this._options.sendTimeout}ms.`;
                    this._log(msg, stanza);
                    this._rejectSendStanzaPromise(messageId, msg);
                }, this._options.sendTimeout, pauseableTimer);
                try {
                    if (stanza.$attributes === undefined) {
                        stanza.$attributes = {};
                    }
                    if (stanza.$attributes.from === undefined) {
                        stanza.$attributes.from = this._jid;
                    }
                    if (store === true) {
                        // Add the store hint to ensure all messages get persisted in the MAM
                        stanza.store = {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.HINTS
                            },
                            "$value": ""
                        };
                    }
                    if (timestamp === true) {
                        // Add a client timestamp to all messages
                        stanza.timestamp = {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.CT_CLIENT_TIMESTAMP
                            },
                            "$value": Date.now()
                        };
                    }
                    const $xml = CtXmppClient.jsonToXml(type, stanza);
                    this._connection.send($xml);
                }
                catch (e) {
                    const msg = `Unable to send XMPP ${type}`;
                    this._onError(msg, e);
                    this._rejectSendStanzaPromise(messageId, msg);
                }
            }
            else {
                const msg = "You're not currently connected, please connect and try again.";
                this._onError(msg);
                this._rejectSendStanzaPromise(messageId, msg);
            }
        });
    }
    /**
     * Upload a message's attachments and then send the message
     * @param message
     * @param files
     * @returns {Promise<U>}
     * @private
     */
    _sendMessageWithAttachments(message, files) {
        if (!this._options.uploadHost)
            throw new Error("Cannot send attachments without a upload host configured.");
        this._log(`Sending message with ID ${message._id} with attachments:`, files);
        let promiseChain = es6_promise_1.Promise.resolve({});
        files.forEach((file, index) => {
            promiseChain = promiseChain
                .then(() => {
                return new es6_promise_1.Promise((resolve, reject) => {
                    // Get the size of the file, if encrypted get the unencrypted file size
                    File.getFileSize(file).then((size) => {
                        // Ask for an upload slot for each of the attachments
                        const uploadIq = {
                            "$attributes": {
                                "id": this.getUniqueId(),
                                "to": this._options.uploadHost,
                                "from": this._jid,
                                "type": "get",
                                "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                            },
                            "request": {
                                "$attributes": {
                                    "xmlns": CtXmppClient.NAMESPACES.HTTP_UPLOAD,
                                },
                                "filename": file.name.replace(".encrypted", ""),
                                "size": "" + size,
                                "content-type": file.type
                            }
                        };
                        this.sendIq(this._options.uploadHost, "get", uploadIq).then(resolve).catch(reject);
                    }).catch(e => {
                        console.error(`Couldn't get file size for file with name '${file.name}'.`, e);
                        reject(e);
                    });
                });
            })
                .then((_stanza) => {
                return new es6_promise_1.Promise(resolve => {
                    // If the attachment endpoints are authenticated then we need to grab the password from the secure DB
                    if (this._options.authAttachments === true) {
                        this._getCacheItem("user_password").then(password => {
                            return this._embellishPasswordWithAdToken(password);
                        }).then(_password => {
                            resolve([_stanza, {
                                    "Authorization": "Basic " + btoa(this._bareJid + ":" + _password),
                                    "Content-Type": file.type
                                }]);
                        });
                    }
                    else {
                        // Otherwise we can just do the upload without any auth
                        resolve([_stanza, {
                                "Content-Type": file.type
                            }]);
                    }
                });
            })
                .then((result) => {
                const _stanza = result[0];
                const _headers = result[1];
                return new es6_promise_1.Promise((resolve, reject) => {
                    // The spec appears not to match reality - there are no headers?
                    // But here is the code that would match the XEP spec
                    // const headers = {};
                    //
                    // if (_stanza.iq.slot.put.header) {
                    //     _stanza.iq.slot.put.header.forEach(function (header) {
                    //         headers[header.name] = header.value;
                    //     });
                    // }
                    const put = _stanza.iq.slot.put;
                    const get = _stanza.iq.slot.get;
                    File.upload(file.path, put, get, _headers).then(() => {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_SUCCESS, message);
                        resolve(["transferred", get, put]);
                    }).catch((e) => {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_FAILED, message);
                        const msg = `Couldn't successfully upload file '${file.path}' to the server:`;
                        this._onError(msg, e);
                        reject({ error: msg, message });
                    });
                });
            })
                .then((result) => {
                const _state = result[0];
                const _get = result[1];
                const _put = result[2];
                return new es6_promise_1.Promise((resolve, reject) => {
                    this.saveMessage(message._id, (_message) => {
                        _message.attachments[index].state = _state;
                        _message.attachments[index].get = _get;
                        _message.attachments[index].put = _put;
                        if (environment_1.isBrowser()) {
                            // If we are in the browser we always want to read from the get URL
                            _message.attachments[index].path = _get;
                        }
                        return _message;
                    }).then(resolve).catch(reject);
                });
            });
        });
        return promiseChain.then(() => {
            return this.resendMessage(message._id);
        });
    }
    _prepareMessageAttachmentsForSend(stanza, attachments) {
        this._log("Preparing to send the following attachments:", attachments);
        return new es6_promise_1.Promise((resolve, reject) => {
            const proms = [];
            attachments.forEach((filePath) => {
                proms.push(new es6_promise_1.Promise((_resolve, _reject) => {
                    this._log("Getting file information for file:", filePath);
                    File.getFileInfo(filePath).then((fileInfo) => {
                        this._log("Got file info for file:", fileInfo);
                        _resolve(Object.assign({ get: "", put: "", state: "transferring" }, fileInfo));
                    }).catch(_reject);
                }));
            });
            es6_promise_1.Promise.all(proms).then((_attachments) => {
                // Put the message in the database, we don't want to send it until the attachments have finished uploading to the server
                this._messageStanzaToDbObject({
                    "message": stanza
                }, {
                    "mine": true,
                    "attachments": _attachments
                }).then((message) => {
                    // Tell outer application that the upload process has started, so the UI can be refreshed
                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_STARTED, message);
                    // Upload and send the message
                    this._sendMessageWithAttachments(message, _attachments).then(resolve).catch(reject);
                }).catch(reject);
            });
        });
    }
    /**
     * Abstraction of the sendMessage method to make sending a peer-to-peer chat message easier
     * @param to {string}
     * @param body {string}
     * @param data {object}
     * @param attachments {string[]} - Array of file paths to be sent as attachments
     * @returns {Promise}
     */
    sendChatMessage(to, body, data, attachments = [], markable = true) {
        this._isMethodReady(true, true);
        if (!to)
            throw new Error("Parameter 'to' is required.");
        if (this._options.mucHost && to.indexOf(this._options.mucHost) > -1)
            throw new Error("You are trying to send a peer-to-peer chat message to a room, please use the 'sendGroupChatMessage' method instead.");
        return new es6_promise_1.Promise((resolve, reject) => {
            // Construct the message stanza
            const stanza = {
                "$attributes": {
                    "id": this.getUniqueId(),
                    "from": this._jid,
                    "to": to,
                    "type": "chat",
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                }
            };
            if (markable === true) {
                stanza.markable = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CHAT_MARKERS
                    }
                };
            }
            if (body !== null) {
                stanza.body = body;
            }
            if (data !== null) {
                stanza.data = data;
            }
            // If we don't have any attachments, just send the message
            if (attachments.length < 1) {
                this.sendMessage(stanza).then(resolve).catch(reject);
                // If we do then prepare the attachments and message object then start the upload and send process
            }
            else {
                this._prepareMessageAttachmentsForSend(stanza, attachments).then(resolve).catch(reject);
            }
        });
    }
    /**
     * Send a multicast message
     * @param addresses {object[]} - in the form [{ type, jid, desc },...]
     * @param body {string}
     * @param data {object}
     * @param attachments {string[]}
     * @param markable {Boolean}
     * @returns {Promise}
     */
    sendMulticastMessage(addresses, body, data, attachments = [], markable = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            const stanza = {
                "$attributes": {
                    "id": this.getUniqueId(),
                    "from": this._jid,
                    "to": `${this._options.multicastHost}`,
                    "type": "chat",
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                },
                "addresses": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.ADDRESS
                    },
                    "address": addresses.map((address) => {
                        return {
                            "$attributes": address
                        };
                    })
                }
            };
            if (markable === true) {
                stanza.markable = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CHAT_MARKERS
                    }
                };
            }
            if (body !== null) {
                stanza.body = body;
            }
            if (data !== null) {
                stanza.data = data;
            }
            // If we don't have any attachments, just send the message
            if (attachments.length < 1) {
                this.sendMessage(stanza).then(resolve).catch(reject);
                // If we do then prepare the attachments and message object then start the upload and send process
            }
            else {
                this._prepareMessageAttachmentsForSend(stanza, attachments).then(resolve).catch(reject);
            }
        });
    }
    /**
 * Abstraction of the sendStanza method to make sending a group message easier
 * @param roomName {string}
 * @param body {string}
 * @param data {object}
 * @param attachments {string[]}
 * @param markable {boolean}
 * @returns {Promise}
 */
    sendGroupChatMessage(roomName, body, data, attachments = [], markable = true, personalMam = false) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' is required.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const stanza = {
                $attributes: {
                    id: this.getUniqueId(),
                    from: this._jid,
                    to: `${roomName}@${this._options.mucHost}`,
                    type: "groupchat",
                    xmlns: CtXmppClient.NAMESPACES.JABBER_CLIENT
                }
            };
            if (markable === true) {
                stanza.markable = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CHAT_MARKERS
                    }
                };
            }
            if (body !== null) {
                stanza.body = body;
            }
            if (data !== null) {
                stanza.data = data;
            }
            if (personalMam !== true) {
                stanza.exclude = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.INFINITY_MAM,
                        archive: "user"
                    }
                };
            }
            // If we don't have any attachments, just send the message
            if (attachments.length < 1) {
                this.sendMessage(stanza).then(resolve).catch(reject);
                // If we do then prepare the attachments and message object then start the upload and send process
            }
            else {
                this._prepareMessageAttachmentsForSend(stanza, attachments).then(resolve).catch(reject);
            }
        });
    }
    sendMessage(stanza) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // First save the message locally
            this._messageStanzaToDbObject({
                "message": stanza
            }, {
                state: { "sent": false },
                mine: true
            }).then((result) => {
                // Then attempt to send
                this.sendStanza(stanza).then(() => {
                    // If it gets sent successfully then update the message state to sent = true
                    this.saveMessage(result._id, (message) => {
                        message.state.sent = true;
                        return message;
                    }).then(resolve).catch(reject);
                }).catch(reject);
            }).catch(reject);
        });
    }
    /**
     * Method to send an IQ message over the socket and return its response
     * @param to
     * @param type
     * @param payload
     * @param timeout
     * @param id
     * @returns {Promise}
     */
    sendIq(to, type, payload, timeout = this._options.sendTimeout || 25000, id) {
        this._isMethodReady(true, true);
        const _id = (id === undefined) ? this.getUniqueId() : id;
        return new es6_promise_1.Promise((resolve, reject) => {
            const disconnectCallback = (status) => {
                if (status.id === index_1.default.Strophe.Status.DISCONNECTED) {
                    this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                    reject(`Disconnected during IQ request.`);
                }
            };
            this.addEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
            let _iq = null;
            try {
                _iq = {
                    "$attributes": {
                        "id": _id,
                        "type": type,
                        "from": this._connection.jid
                    }
                };
                if (to) {
                    _iq.$attributes.to = to;
                }
                for (let key in payload) {
                    _iq[key] = payload[key];
                }
            }
            catch (e) {
                this._onError("Couldn't construct IQ message:", e);
                reject(e);
            }
            if (_iq !== null) {
                const $xml = CtXmppClient.jsonToXml("iq", _iq);
                this._connection.sendIQ($xml, ($stanza) => {
                    try {
                        this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                        resolve(CtXmppClient.xmlToJson($stanza));
                    }
                    catch (e) {
                        this._onError("Couldn't convert IQ response to JSON.", e);
                        reject(e);
                    }
                }, reject, timeout);
            }
        });
    }
    /**
     * Download stored JSON from Private XML Storage
     * @returns {Promise}
     * @private
     */
    getPrivateData() {
        this._isMethodReady(true, true);
        this._log("Fetching Private XML Data for:", this._bareJid);
        const query = {
            "privatexmldata": {
                "$attributes": {
                    "xmlns": CtXmppClient.NAMESPACES.CT_PRIVATE_XML_STORAGE
                }
            }
        };
        return new es6_promise_1.Promise((resolve, reject) => {
            return this._getPrivateXMLStorage(query).then((result) => {
                if (result !== undefined && result.privatexmldata !== undefined && result.privatexmldata.json !== undefined) {
                    resolve(JSON.parse(result.privatexmldata.json));
                }
                else {
                    reject("No private data found, or unable to fetch");
                }
            });
        });
    }
    /**
     * Download the private XML Storage for the supplied XML query
     * @param queryXML
     * @returns {Promise}
     * @private
     */
    _getPrivateXMLStorage(queryXML) {
        this._log("Fetching Private XML Storage Data for: ", this._bareJid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(this._bareJid, "get", {
                "query": Object.assign({ "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.PRIVATE_XML_STORAGE
                    } }, queryXML)
            }).then((result) => {
                this._log("Fetched Private XML Storage Data for:", this._bareJid);
                resolve(result.iq.query);
            }).catch((e) => {
                reject("Unable to send IQ for Private XML Storage");
            });
        });
    }
    /**
     * Given some JSON, wrap it in XML and then set it in Private XML Storage
     * @param data: A js object, that will be stringified and stored in Private XML Storage for the current user
     * @returns {Promise}
     * @private
     */
    setPrivateData(data) {
        this._isMethodReady(true, true);
        this._log("Setting Private XML data for:", this._bareJid);
        const strData = JSON.stringify(data);
        const queryData = {
            "privatexmldata": {
                "$attributes": {
                    "xmlns": CtXmppClient.NAMESPACES.CT_PRIVATE_XML_STORAGE
                },
                "json": strData
            }
        };
        return this._setPrivateXMLStorage(queryData);
    }
    /**
     * Given some XML (as json) use it to set in private XML Storage
     * @param jsonXml
     * @returns {Promise<void>}
     * @private
     */
    _setPrivateXMLStorage(jsonXml) {
        const query = {
            "query": Object.assign({ "$attributes": {
                    "xmlns": CtXmppClient.NAMESPACES.PRIVATE_XML_STORAGE
                } }, jsonXml)
        };
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(null, "set", query)
                .then((result) => {
                resolve();
                this._log("Set Private XML Storage for:", this._bareJid);
            }).catch(reject);
        });
    }
    /**
     * Download a vCard by jid, return a Promise to the vCard as a string.
     * @param jid
     * @returns {Promise}
     * @private
     */
    _getvCard(jid) {
        this._log(" Fetching vCard for:", jid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(jid, "get", {
                "vCard": {
                    "$attributes": {
                        "xmlns": "vcard-temp"
                    }
                }
            })
                .then((result) => {
                this._log("Fetched vCard for:", jid);
                resolve(result.iq.vCard);
            }).catch((e) => {
                reject("Unable to send IQ for vCard");
            });
        });
    }
    /**
     * Upload Changed vCard to the server
     * @param jid
     * @param vCardStr
     * @returns {Promise}
     * @private
     */
    _setvCard(jid, vCardStr) {
        this._log(" Setting vCard for:", jid);
        const doc = (new DOMParser()).parseFromString(vCardStr, 'text/xml');
        const jsonIq = CtXmppClient.xmlToJson(doc);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(null, "set", jsonIq["#document"])
                .then((result) => {
                resolve();
                this._log(" Set vCard for:", jid);
            }).catch(reject);
        });
    }
    /**
     * Method used to add an event listener for valid event types
     * @param type
     * @param callback
     */
    addEventListener(type, callback) {
        if (!CtXmppClient._validateEventType(type)) {
            throw new Error("Invalid event type provided.");
        }
        if (type === CtXmppClient.EVENT_TYPES.INITIALISED && this._initialised === true) {
            callback(null);
        }
        else {
            if (this._eventListeners[type] === undefined) {
                this._eventListeners[type] = [];
            }
            this._eventListeners[type].push(callback);
        }
    }
    /**
     * Method used to remove event listeners
     * @param type
     * @param callback
     */
    removeEventListener(type, callback) {
        if (!CtXmppClient._validateEventType(type)) {
            throw new Error("Invalid event type provided.");
        }
        if (this._eventListeners[type] !== undefined) {
            this._eventListeners[type].forEach((cCallback, idx) => {
                if (cCallback === callback) {
                    this._eventListeners[type].splice(idx, 1);
                }
            });
        }
    }
    /**
     * Base method used to search all databases
     * @param db
     * @param query
     * @param sortFields
     * @param includeFields
     * @param limit
     * @param skip
     * @returns {Promise}
     * @private
     */
    _searchDb(db, query, sortFields, includeFields, limit, skip) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const fields = [];
            for (let field in query) {
                if (field.indexOf("$") !== 0) {
                    fields.push(field);
                }
                else if (["$or", "$and", "$not", "$nor", "$all"].indexOf(field) > -1 && Array.isArray(query[field]) && query[field].length > 0) {
                    query[field].forEach((o) => {
                        for (let k in o) {
                            fields.push(k);
                        }
                    });
                }
            }
            if (fields.length > 0) {
                db.createIndex({
                    index: {
                        "fields": fields
                    }
                }).then(() => {
                    let findObj = {
                        "selector": query
                    };
                    if (Array.isArray(sortFields) && sortFields.length > 0) {
                        findObj.sort = sortFields;
                    }
                    if (Array.isArray(includeFields) && includeFields.length > 0) {
                        findObj.fields = includeFields;
                    }
                    if (skip) {
                        findObj.skip = skip;
                    }
                    if (limit) {
                        findObj.limit = limit;
                    }
                    db.find(findObj).then((result) => {
                        resolve(result.docs);
                    }).catch(reject);
                }).catch(reject);
            }
        });
    }
    /**
     * Interactions with the messages database
     */
    /**
     * Method to query the messages database to retrieve specific messages
     * @param {Object} query An object signature to match messages on
     * @param {string[]} [sortFields] Defines a list of fields defining how you want to sort. Note that sorted fields also have to be selected in the query.
     * @param {string[]} [includeFields] Defines a list of fields that you want to receive. If omitted, you get the full documents.
     * @param {number} [skip] Number of docs to skip before returning.
     * @param {number} [limit] Maximum number of documents to return.
     * @returns {Promise}
     */
    findMessages(query, sortFields, includeFields, limit, skip) {
        this._isMethodReady(true);
        return this._searchDb(this._msgDb, query, sortFields, includeFields, limit, skip);
    }
    /**
     * Convenience method to get all message IDs in the local database
     */
    getAllMessageIds() {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._msgDb.allDocs().then((results) => {
                let ids = [];
                if (results.rows && results.rows.length > 0) {
                    ids = results.rows.map((row) => {
                        return row.id;
                    });
                }
                resolve(ids);
            }).catch(reject);
        });
    }
    /**
     * Convenience method to get all messages in the local database
     */
    getAllMessages() {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._msgDb.allDocs({
                include_docs: true
            }).then((results) => {
                const messages = results.rows.map(row => row.doc);
                resolve(messages);
            }).catch(reject);
        });
    }
    /**
     * Method used to fetch chat history for a specific recipient
     * @param recipient
     * @param sortFields
     * @param unread
     * @param limit
     * @param skip
     * @returns {Promise}
     */
    getChatHistory(recipient, sortFields, unread, limit, skip) {
        this._isMethodReady(true);
        // Sort is current broken in PouchDB :(
        // if (!sortFields) {
        //     sortFields = [{"ts": "desc"}];
        // }
        let query = {
            "$or": [
                { "sender_id": recipient },
                { "recipient_id": recipient }
            ]
        };
        if (unread === true) {
            query["state.read"] = true;
        }
        return new es6_promise_1.Promise((resolve, reject) => {
            this.findMessages(query, sortFields, null, limit, skip).then(results => {
                const messages = results.sort((a, b) => {
                    return a.ts - b.ts;
                });
                resolve(messages);
            }).catch(reject);
        });
    }
    getMessagesById(ids) {
        return this._msgDb.allDocs({ include_docs: true }).then(docs => {
            return docs.rows.filter(doc => {
                return ids.includes(doc.id);
            });
        });
    }
    /**
     * Get a message by its ID
     * @param id
     */
    getMessageById(id) {
        this._isMethodReady(true);
        if (!id)
            throw new Error(`A message ID must be provided.`);
        return this._msgDb.get(id);
    }
    /**
     * Method used to delete a single message by passing in the message object
     * @param message
     * @returns {Promise}
     */
    deleteMessage(message, deleteAttachments = true) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            // Ignore if no message provided to method
            if (!message) {
                resolve();
            }
            else {
                const proms = [];
                if (deleteAttachments) {
                    // Also delete any attached files
                    if (message.attachments !== undefined) {
                        message.attachments.forEach((file) => {
                            if (file.path !== undefined) {
                                proms.push(new es6_promise_1.Promise((resolve) => {
                                    if (environment_1.getPlatformName() === "ios" && !file.path.includes("file://")) {
                                        file.path = `file://${file.path}`;
                                    }
                                    return File.deleteFile(file.path).then(resolve).catch(err => {
                                        this._onError(`Couldn't delete attachment: '${file.name}':`, err);
                                        resolve();
                                    });
                                }));
                            }
                        });
                    }
                }
                es6_promise_1.Promise.all(proms).then(() => {
                    this._msgDb.remove(message).then(() => {
                        this._log("Message successfully deleted with ID:", message._id);
                        if (window.PushNotification && window.PushNotification.removeFromIgnoreList) {
                            if (message.data && message.data.conversationstarted) {
                                const cs = JSON.parse(message.data.conversationstarted);
                                const timestamp = cs.started;
                                window.PushNotification.removeFromIgnoreList(() => { }, () => { }, timestamp);
                            }
                        }
                        resolve();
                    }).catch(e => {
                        this._onError(`Couldn't delete message with ID '${message._id}'.`, e);
                        reject(e);
                    });
                }).catch(e => {
                    this._onError(`Couldn't delete attachment(s) for message with ID '${message._id}':`, e);
                    reject(e);
                });
            }
        });
    }
    /**
     * Delete a message locally by the _id
     * @param {string} id
     * @param [deleteAttachments] - defaults to true
     * @returns {Promise}
     */
    deleteMessageById(id, deleteAttachments = true) {
        this._isMethodReady(true);
        this._log("Deleting message with ID:", id);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getMessageById(id).then(message => {
                this.deleteMessage(message, deleteAttachments).then(resolve).catch(reject);
            }).catch(e => {
                this._onError(`Couldn't get message with ID '${id}' to delete it.`, e);
                reject(e);
            });
        });
    }
    /**
     * Delete multiple messages locally based on a search query
     * @param {object} query
     * @returns {Promise}
     */
    deleteMessages(query) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._searchDb(this._msgDb, query).then((results) => {
                this._log(" There are " + results.length + " messages to delete");
                const proms = [];
                results.forEach((message) => {
                    proms.push(this.deleteMessage(message));
                });
                es6_promise_1.Promise.all(proms).then(resolve).catch((e) => {
                    this._onError(`Couldn't delete messages from database.`, e);
                    reject(e);
                });
            });
        });
    }
    /**
     * Method to be DEPRECATED
     * @param {string} roomName - The name of the room for which all messages should be deleted
     * @returns {Promise}
     */
    deleteMessagesByRoom(roomName) {
        console.warn("This method is going to be DEPRECATED, please use 'deleteMessagesByRoomName' instead.");
        return this.deleteMessages({
            "$or": [
                { "sender_id": roomName },
                { "recipient_id": roomName }
            ]
        });
    }
    /**
     * Method to delete all messages from a single room by the room name
     * @param {string} roomName - The name of the room for which all messages should be deleted
     * @returns {Promise}
     */
    deleteMessagesByRoomName(roomName) {
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return this.deleteMessages({
            "$or": [
                { "sender_id": `${roomName}@${this._options.mucHost}` },
                { "recipient_id": `${roomName}@${this._options.mucHost}` }
            ]
        });
    }
    /**
     * Used for efficient partial updates to a message object
     * @param messageId - The ID of the message
     * @param delta - Function which provides the current message as an argument and should return the updated message
     */
    saveMessage(messageId, delta) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._saveObject(CtXmppClient.OBJECT_TYPES.MESSAGE, messageId, delta, (object) => {
                resolve(object);
            }, (e) => {
                reject(e);
            });
        });
    }
    /**
     * Private method to be used when a different user logs in
     * @returns {Promise}
     * @private
     */
    _clearDbsForNewUser() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this.destroyDbs(false).then(() => {
                this._dispatchEvent(CtXmppClient.EVENT_TYPES.AUTO_DBS_DESTROYED, null);
                resolve();
            }).catch(reject);
        });
    }
    /**
     * Convenience method used to destroy all databases
     * @param dispatch {Boolean} - Whether to dispatch the DBS_DESTROYED event
     * @param keepCache {Boolean} - Whether to NOT remove the cache database
     * @returns {Promise}
     */
    destroyDbs(dispatch = true, keepCache = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Don't destroy if we're already doing so
            if (this._destroyingDbs) {
                resolve();
                return;
            }
            this._log(" Destroying all databases and data...");
            this._destroyingDbs = true;
            // Destroy any localStorage items also
            this._lastArchiveId = null;
            localStorage.removeItem(`${this._instanceId}_last_archive_id`);
            this.resource = null;
            localStorage.removeItem(`${this._instanceId}_resource`);
            localStorage.removeItem(`${this._instanceId}_counters`);
            // Remove the encryption key if stashed in local storage
            if (keepCache !== true)
                localStorage.removeItem(`${this._instanceId}_key`);
            // Remove the login in flag used to detect a failed login
            localStorage.removeItem(`${this._instanceId}_logging_in`);
            // Remove the presence needed flag
            localStorage.removeItem(`${this._instanceId}_presence_needed`);
            const proms = [this._msgDb.destroy(), this._contactDb.destroy(), this._roomDb.destroy(), this._participantDb.destroy()];
            if (Plugin.getSource("file") !== false)
                proms.push(File.deleteAttachments());
            if (keepCache !== true)
                proms.push(this._cacheDb.destroy());
            proms.push(new es6_promise_1.Promise((resolve, reject) => {
                if (this._userDirectory.initialised) {
                    localStorage.removeItem(`${this._instanceId}_ud_iv`);
                    this._userDirectory.destroy().then(() => {
                        resolve();
                    }).catch(reject);
                }
                else {
                    resolve();
                }
            }));
            es6_promise_1.Promise.all(proms).then(() => {
                this._initDbs().then(() => {
                    if (dispatch === true)
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.DBS_DESTROYED, null);
                    this._log(" Successfully destroyed all data.");
                    this._destroyingDbs = false;
                    resolve();
                }).catch(e => {
                    this._destroyingDbs = false;
                    reject(e);
                });
            }).catch(e => {
                this._destroyingDbs = false;
                reject(e);
            });
        });
    }
    deleteAttachments() {
        return File.deleteAttachments();
    }
    deleteFile(url) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (url !== undefined) {
                if (environment_1.getPlatformName() === "ios" && !url.includes("file://")) {
                    url = `file://${url}`;
                }
                return File.deleteFile(url).then(resolve).catch(err => {
                    this._onError(`Couldn't delete attachment at: '${url}':`, err);
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Set the users current chat status
     * @param status
     * @param label
     * @param send
     * @param metadata
     * @returns {Promise}
     */
    setChatStatus(status, label, send, metadata) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            if (CtXmppClient._validateChatStatus(status)) {
                const statusObject = {
                    status: status,
                    label: label,
                    metadata: metadata
                };
                if (!statusObject.label) {
                    switch (status) {
                        case CtXmppClient.CHAT_STATUSES.CHAT:
                            statusObject.label = "Available";
                            break;
                        case CtXmppClient.CHAT_STATUSES.AWAY:
                            statusObject.label = "Away";
                            break;
                        case CtXmppClient.CHAT_STATUSES.XA:
                            statusObject.label = "Extended Away";
                            break;
                        case CtXmppClient.CHAT_STATUSES.DND:
                            statusObject.label = "Do Not Disturb";
                            break;
                    }
                }
                this._setCacheItem("chat_status", statusObject).then(() => {
                    if (send === true) {
                        this._sendPresence().then(() => resolve(statusObject)).catch(reject);
                    }
                    else {
                        resolve(statusObject);
                    }
                }).catch(reject);
            }
            else {
                reject("Invalid chat status provided, one of 'away', 'chat', 'dnd' or 'xa' should be specified.");
            }
        });
    }
    /**
     * Method to return the users current chat status
     * @returns {Promise}
     */
    getChatStatus() {
        this._isMethodReady(true);
        return this._getCacheItem("chat_status");
    }
    /**
     * Method to set the client state
     * @param type
     */
    setClientState(type) {
        this._isMethodReady(true, true);
        if (!CtXmppClient._validateConstants(CtXmppClient.CLIENT_STATES, type))
            throw new Error("Invalid client state specified.");
        const $xml = CtXmppClient.jsonToXml(type, {
            $attributes: {
                xmlns: CtXmppClient.NAMESPACES.CLIENT_STATE_INDICATION
            }
        });
        return this._connection.send($xml);
    }
    /**
     * Interactions with the roster database
     */
    /**
     * Method to query the roster database to retrieve specific contacts
     * @param {Object} query An object signature to match contacts on
     * @param {string[]} [sortFields] Defines a list of fields defining how you want to sort. Note that sorted fields also have to be selected in the query.
     * @param {string[]} [includeFields] Defines a list of fields that you want to receive. If omitted, you get the full documents.
     * @param {number} [skip] Number of docs to skip before returning.
     * @param {number} [limit] Maximum number of documents to return.
     * @returns {Promise}
     */
    findContacts(query, sortFields, includeFields, limit, skip) {
        this._isMethodReady(true);
        return this._searchDb(this._contactDb, query, sortFields, includeFields, limit, skip);
    }
    /**
     * Method used to return a list of the users contacts
     * @returns {Promise}
     */
    getContacts() {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._contactDb.allDocs({ "include_docs": true }).then((results) => {
                const contacts = results.rows.filter((row) => {
                    //TODO: Figure out what to do with PouchDB views? Filtering them out for now
                    return (!row.doc.language);
                }).map((row) => {
                    return row.doc;
                });
                resolve(contacts);
            }).catch((error) => {
                this._onError(`Unable to get contacts from database.`, error);
                reject(error);
            });
        });
    }
    /**
     * Method to replace the token placeholder
     * @param {string} password
     * @returns {Promise<string | null>}
     * @private
     */
    _embellishPasswordWithAdToken(password) {
        if (!password)
            throw new Error("Password must be provided.");
        return new es6_promise_1.Promise((resolve, reject) => {
            // Determine if we need to acquire an AD token from the current user session on desktop
            if (environment_1.isElectron() === true &&
                environment_1.isWindows() === true &&
                this._options.adTokenPlaceholder &&
                this._options.adSecurityPackage &&
                this._options.adSpn &&
                password.indexOf(this._options.adTokenPlaceholder) > -1) {
                const sspi = Plugin.getSource("sspiclient");
                if (sspi !== false) {
                    sspi.Helper.getUserToken((token) => {
                        resolve(password.replace(this._options.adTokenPlaceholder, token));
                    }, reject, this._options.adSpn, this._options.adSecurityPackage);
                }
                else {
                    reject("Couldn't access sspiclient plugin.");
                }
            }
            else {
                resolve(password);
            }
        });
    }
    /**
     * Methods to deal with chat markers: Read & Acknowledged
     */
    /**
     * Convenience method to determine if a message should be marked or not
     * @param message
     * @param type
     * @returns {boolean}
     * @private
     */
    _shouldMarkMessage(message, type) {
        let result = true;
        // Don't mark a message if it isn't markable
        if (message.markable === false)
            return false;
        // We need to figure out if we've already marked this message with this type
        message.state.markers.every((marker) => {
            if (marker.type === type) {
                if (message.type === "groupchat" && marker.sender_resource === this.username) {
                    result = false;
                    return false;
                }
                else if (marker.sender_id === this._jid) {
                    result = false;
                    return false;
                }
            }
            return true;
        });
        return result;
    }
    /**
     * Mark a single message
     * @param {Object} message - The entire message object to be marked as received
     * @param {String} type - The type of marker (i.e. received, read or acknowledged)
     * @param {Boolean} dispatch - Whether or not to dispatch the message updated event
     * @returns {Promise}
     */
    _markMessage(message, type, dispatch = true) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // If this is our message, or if this message has already been marked with this type before, or if the message hasn't been flagged as markable just resolve
            if (message.mine === true || this._shouldMarkMessage(message, type) === false) {
                resolve(message);
            }
            else {
                // Mark the message as received via chat markers
                const markerMessage = {
                    "$attributes": {
                        "id": this.getUniqueId(),
                        "to": index_1.default.Strophe.getBareJidFromJid(message.stanza.message.$attributes.from),
                        "from": this._connection.jid,
                    },
                    "timestamp": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.CT_CLIENT_TIMESTAMP
                        },
                        "$value": Date.now()
                    },
                };
                markerMessage[type] = {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.CHAT_MARKERS,
                        "id": message._id
                    }
                };
                if (message.type === "groupchat") {
                    markerMessage.$attributes.type = "groupchat";
                }
                this.sendStanza(markerMessage).then(() => {
                    this.saveMessage(message._id, (doc) => {
                        doc.state[type] = true;
                        return doc;
                    }).then((message) => {
                        if (dispatch !== false)
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                        resolve(message);
                    }).catch(reject);
                }).catch(reject);
            }
        });
    }
    /**
     * Mark Message Read
     */
    /**
     * Abstraction of the markMessage method to quickly mark a single message as read
     * @param message - The message object
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageRead(message) {
        this._isMethodReady(true, true);
        // If we are on a device and the device is in the background then we don't want to mark the message read
        if (environment_1.isDevice() && utils_1.isInBackground())
            return;
        return this._markMessage(message, CtXmppClient.MARKER_TYPES.READ);
    }
    /**
     * Abstraction of the markMessage method to quick mark a single message as read by message ID
     * @param messageId - The ID of the message
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageReadById(messageId) {
        this._isMethodReady(true, true);
        return this.getMessageById(messageId).then((message) => {
            return this.markMessageRead(message);
        });
    }
    /**
     * Mark Message Acknowledged
     */
    /**
     * Abstraction of the markMessage method to quickly mark a single message as acknowledged
     * @param message - The message object
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageAcknowleged(message) {
        this._isMethodReady(true, true);
        return this._markMessage(message, CtXmppClient.MARKER_TYPES.ACKNOWLEDGED);
    }
    /**
     * Abstraction of the markMessage method to quick mark a single message as acknowledged by message ID
     * @param messageId - The ID of the message
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageAcknowledgedById(messageId) {
        this._isMethodReady(true, true);
        return this.getMessageById(messageId).then((message) => {
            return this.markMessageAcknowleged(message);
        });
    }
    /**
     * Private method used to dispatch an event of a specific type
     * @param type
     * @param data
     * @private
     */
    _dispatchEvent(type, data) {
        if (!CtXmppClient._validateEventType(type)) {
            throw new Error("Invalid event type provided.");
        }
        if (this._eventListeners[type] !== undefined) {
            this._eventListeners[type].forEach((callback) => {
                callback(data);
            });
        }
    }
    /**
     * MUCSub - Multi-User Chat Subscription
     * Methods which interface with MUCSub allowing for the creation of and subscription to chat rooms
     */
    /**
     * Method used to create a non-anonymous room
     * @param roomName
     * @returns {Promise}
     */
    createRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            let $pres = {
                "$attributes": {
                    "to": `${to}/${this.username}`,
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                },
                "x": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC
                    }
                }
            };
            this._connection.addHandler($stanza => {
                const stanza = CtXmppClient.xmlToJson($stanza);
                if (stanza.$attributes !== undefined && stanza.$attributes.type === "error") {
                    const error = new Error(`Failed to create room '${roomName}'.`);
                    this._onError(`Unable to create room with name '${roomName}'.`, error);
                    reject(error);
                }
                else {
                    // Query the room for configuration options
                    this.sendIq(to, "get", {
                        "query": {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.MUC_OWNER
                            }
                        }
                    }).then(() => {
                        // Set the whois configuration to be anyone so we can get users actual JIDs
                        this.sendIq(to, "set", {
                            "query": {
                                "$attributes": {
                                    "xmlns": CtXmppClient.NAMESPACES.MUC_OWNER
                                },
                                "x": {
                                    "$attributes": {
                                        "xmlns": CtXmppClient.NAMESPACES.X_DATA,
                                        "type": "submit"
                                    },
                                    "field": [
                                        {
                                            "$attributes": {
                                                "var": "muc#roomconfig_whois"
                                            },
                                            "value": "anyone"
                                        }
                                    ]
                                }
                            }
                        }).then(() => {
                            // TODO: Handle room creation errors and on success add new room to local DB
                            this._log(`Room '${roomName}' successfully created.`);
                            resolve();
                        }).catch((error) => reject);
                    }).catch((error) => reject);
                }
                return false;
            }, CtXmppClient.NAMESPACES.MUC, "presence", null, null, `${to}/${this.username}`, { ignoreNamespaceFragment: true });
            this._connection.send(CtXmppClient.jsonToXml("presence", $pres));
        });
    }
    /**
     * Method used to destroy a room on the server
     * @param roomName
     * @returns {Promise}
     */
    destroyRoom(roomName) {
        this._isMethodReady(true, true);
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${roomName}@${this._options.mucHost}`, "set", {
                "query": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_OWNER
                    },
                    "destroy": {}
                }
            }).then(() => {
                // TODO: Handle room destroy errors and on success remove room from local DB
                resolve();
            }).catch((error) => reject);
        });
    }
    /**
     * Method used to list all rooms the client knows about and also query the server for the list of rooms
     * @param queryServer
     * @returns {Promise}
     */
    listRooms(queryServer) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const fetchFromDb = () => {
                this._roomDb.allDocs({
                    include_docs: true
                }).then(docs => {
                    const rooms = docs.rows.map(row => {
                        return row.doc;
                    });
                    resolve(rooms);
                }).catch(error => {
                    this._onError(`Couldn't fetch list of rooms from database.`, error);
                    reject(error);
                });
            };
            // If we don't have an active connection or the user request we don't contact the server then we just get the local results
            if (this.connected === true && queryServer !== false) {
                // Otherwise contact the server and merge any updates to the local database
                this.sendIq(this._options.mucHost, "get", {
                    "query": {
                        "$attributes": {
                            "xmlns": "http://jabber.org/protocol/disco#items"
                        }
                    }
                }).then((stanza) => {
                    if (stanza.iq && stanza.iq.query && stanza.iq.query.item) {
                        let rooms = [];
                        // If there are multiple rooms then iterate over them
                        if (Array.isArray(stanza.iq.query.item)) {
                            rooms = stanza.iq.query.item.map((room) => {
                                return {
                                    "_id": room.$attributes.jid,
                                    "name": index_1.default.Strophe.getNodeFromJid(room.$attributes.jid)
                                };
                            });
                            // Or if there is just one, add it to the array
                        }
                        else {
                            rooms = [{
                                    "_id": stanza.iq.query.item.$attributes.jid,
                                    "name": index_1.default.Strophe.getNodeFromJid(stanza.iq.query.item.$attributes.jid)
                                }];
                        }
                        this._roomDb.allDocs({
                            include_docs: true
                        }).then(docs => {
                            const proms = [];
                            // Go through each of the current rooms and compare against the rooms from the server
                            // to figure out which ones we want need to delete
                            docs.rows.forEach((row) => {
                                let cRoom = row.doc;
                                let nRoom = null;
                                rooms.every((room) => {
                                    if (room._id === cRoom._id) {
                                        nRoom = room;
                                        return false;
                                    }
                                    return true;
                                });
                                if (nRoom === null) {
                                    // Room doesn't exist on the server anymore, so delete it locally
                                    proms.push(this._roomDb.remove(cRoom));
                                }
                            });
                            // For either of the new rooms, either add them or update them
                            rooms.forEach((nRoom) => {
                                const update = new es6_promise_1.Promise((resolve, reject) => {
                                    this.saveRoom(nRoom._id, (cRoom) => {
                                        if (cRoom._id !== undefined) {
                                            // Need to update the room
                                            if (cRoom.name !== nRoom.name) {
                                                cRoom.name = nRoom.name;
                                            }
                                            cRoom.updated_at = this.getSyncedTimestamp(Date.now());
                                        }
                                        else {
                                            // Need to create the room
                                            cRoom = {
                                                "_id": nRoom._id,
                                                "name": nRoom.name,
                                                "ts": this.getSyncedTimestamp(Date.now()),
                                                "updated_at": null
                                            };
                                        }
                                        return cRoom;
                                    }).then(resolve).catch(reject);
                                });
                                proms.push(update);
                            });
                            es6_promise_1.Promise.all(proms).then(() => {
                                fetchFromDb();
                            }).catch((e) => {
                                this._onError("Couldn't merge list of rooms from server with locally stored list of rooms.", e);
                                reject(e);
                            });
                        });
                        resolve(rooms);
                    }
                    else {
                        // No rooms on the server
                        resolve([]);
                    }
                }).catch(reject);
            }
            else {
                fetchFromDb();
            }
        });
    }
    /**
     * Method used to list users MUC subscriptions
     * @returns {Promise}
     */
    listSubscriptions() {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            // If no mucHost registered then just return an empty result set
            if (!this._options.mucHost) {
                resolve([]);
            }
            else {
                this.sendIq(this._options.mucHost, "get", {
                    "subscriptions": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.MUC_SUB
                        }
                    }
                }).then((stanza) => {
                    let subscriptions = [];
                    if (stanza.iq && stanza.iq.subscriptions && stanza.iq.subscriptions.subscription) {
                        if (Array.isArray(stanza.iq.subscriptions.subscription)) {
                            subscriptions = stanza.iq.subscriptions.subscription.map(sub => {
                                if (sub.$attributes && sub.$attributes.jid) {
                                    return {
                                        "name": index_1.default.Strophe.getNodeFromJid(sub.$attributes.jid),
                                        "jid": sub.$attributes.jid
                                    };
                                }
                            });
                        }
                        else {
                            if (stanza.iq.subscriptions.subscription.$attributes && stanza.iq.subscriptions.subscription.$attributes.jid) {
                                subscriptions = [{
                                        "name": index_1.default.Strophe.getNodeFromJid(stanza.iq.subscriptions.subscription.$attributes.jid),
                                        "jid": stanza.iq.subscriptions.subscription.$attributes.jid
                                    }];
                            }
                        }
                    }
                    resolve(subscriptions);
                }).catch(reject);
            }
        });
    }
    /**
     * Method used to join a room by name as a participant
     * @param roomName
     * @returns {Promise}
     */
    joinRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        return new es6_promise_1.Promise((resolve, reject) => {
            // NOTE: I've not implemented reserved nick functionality, see https://xmpp.org/extensions/xep-0045.html#reservednick
            // The reason for this is that the current XMPP server doesn't appear to support this it returns "service-unavailable"
            // and we don't yet have a requirement for this
            const roomJid = `${roomName}@${this._options.mucHost}`;
            this._createPresenceObject().then(($pres) => {
                $pres.$attributes.to = `${roomJid}/${this.username}`;
                $pres.x = {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC
                    },
                    "history": {
                        "$attributes": {
                            "maxchars": 0 // Don't get any history from the room we will do this with the MAM so we can get chat markers too
                        }
                    }
                };
                // Handler used to catch initial room join presence
                this._connection.addHandler(($stanza) => {
                    try {
                        const stanza = CtXmppClient.xmlToJson($stanza);
                        if (!stanza.presence || stanza.presence.error !== undefined) {
                            this._onError(`Couldn't join room '${roomName}' with nick '${this.username}'.`, $stanza);
                            reject($stanza);
                        }
                        else {
                            this.saveRoom(roomJid, (_room) => {
                                //TODO: Merge duplicate code with listRooms
                                if (_room._id !== undefined) {
                                    if (_room.name !== roomName) {
                                        _room.name = roomName;
                                        _room.updated_at = this.getSyncedTimestamp(Date.now());
                                    }
                                }
                                else {
                                    // Need to create the room
                                    _room = {
                                        "_id": roomJid,
                                        "name": roomName,
                                        "ts": this.getSyncedTimestamp(Date.now()),
                                        "updated_at": null
                                    };
                                }
                                return _room;
                            }).then((room) => {
                                // Add this room to the _joinedRooms object so we know what rooms to send presence to
                                this._joinedRooms[roomName] = Date.now();
                                if (this._options.mam.auto !== false) {
                                    // Query the MAM for any missed messages
                                    this.queryMamByRoomName(roomName).then(() => {
                                        resolve(room);
                                    }).catch(reject);
                                }
                                else {
                                    resolve(room);
                                }
                            }).catch(reject);
                        }
                    }
                    catch (e) {
                        this._onError("Couldn't convert stanza XML to JSON", e);
                        reject(e);
                    }
                    return false;
                }, CtXmppClient.NAMESPACES.JABBER_CLIENT, "presence", null, null, `${roomName}@${this._options.mucHost}/${this.username}`, { ignoreNamespaceFragment: true });
                this._connection.send(CtXmppClient.jsonToXml("presence", $pres));
            });
        });
    }
    /**
     * Method used to leave an already joined room
     * @param roomName
     * @returns {Promise}
     */
    leaveRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        return new es6_promise_1.Promise((resolve) => {
            const $pres = {
                "$attributes": {
                    "from": this._jid,
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT,
                    "to": `${roomName}@${this._options.mucHost}/${this.username}`,
                    "type": "unavailable"
                }
            };
            this._connection.send(CtXmppClient.jsonToXml("presence", $pres));
            // Remove the room from the _joinedRoom object
            delete this._joinedRooms[roomName];
            resolve();
        });
    }
    /**
     * Method used to create a new subscription to a room by name
     * @param roomName
     * @param nodes
     * @returns {Promise}
     */
    subscribeToRoom(roomName, nodes) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const payload = {
                "subscribe": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_SUB,
                        "nick": this.username
                    }
                }
            };
            if (!nodes) {
                nodes = [];
                for (let key in CtXmppClient.MUC_NODES) {
                    nodes.push(CtXmppClient.MUC_NODES[key]);
                }
            }
            if (nodes.length > 0) {
                payload.subscribe.event = [];
                nodes.forEach((node) => {
                    payload.subscribe.event.push({
                        "$attributes": {
                            "node": node
                        }
                    });
                });
            }
            this.sendIq(`${roomName}@${this._options.mucHost}`, "set", payload).then((stanza) => {
                if (stanza.iq && stanza.iq.subscribe) {
                    resolve(stanza);
                }
                else {
                    this._onError(`Couldn't subscribe to room '${roomName}.'`, stanza);
                }
            }).catch(reject);
        });
    }
    /**
     * Method used to list the JIDs of user which are currently subscribed to the specified room - room moderator privileges required
     * @param roomName
     * @returns {Promise}
     */
    listSubscribedUsersForRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${roomName}@${this._options.mucHost}`, "get", {
                "subscriptions": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_SUB
                    },
                }
            }).then((stanza) => {
                let jids = [];
                if (stanza.iq && stanza.iq.subscriptions !== undefined) {
                    if (Array.isArray(stanza.iq.subscriptions.subscription)) {
                        jids = stanza.iq.subscriptions.subscription.map((sub) => {
                            if (sub.$attributes && sub.$attributes.jid !== undefined) {
                                return sub.$attributes.jid;
                            }
                        });
                    }
                    else if (stanza.iq.subscriptions.subscription !== undefined) {
                        const sub = stanza.iq.subscriptions.subscription;
                        if (sub.$attributes && sub.$attributes.jid !== undefined) {
                            jids = [sub.$attributes.jid];
                        }
                    }
                }
                resolve(jids);
            }).catch(reject);
        });
    }
    /**
     * Method used to remove a subscription to a room by name
     * @param roomName
     * @returns {Promise}
     */
    unsubscribeFromRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${roomName}@${this._options.mucHost}`, "set", {
                "unsubscribe": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_SUB
                    },
                }
            }).then(resolve).catch(reject);
        });
    }
    /**
     * Get a room by its DB ID (_id)
     * @param id
     */
    getRoomById(id) {
        this._isMethodReady(true);
        if (!id)
            throw new Error(`A room ID must be provided.`);
        this._log("Getting room with ID:", id);
        return this._roomDb.get(id);
    }
    /**
     * Method to query the room database to retrieve specific rooms
     * @param {Object} query An object signature to match rooms on
     * @param {string[]} [sortFields] Defines a list of fields defining how you want to sort. Note that sorted fields also have to be selected in the query.
     * @param {string[]} [includeFields] Defines a list of fields that you want to receive. If omitted, you get the full documents.
     * @param {number} [skip] Number of docs to skip before returning.
     * @param {number} [limit] Maximum number of documents to return.
     * @returns {Promise}
     */
    findRooms(query, sortFields, includeFields, limit, skip) {
        this._isMethodReady(true);
        return this._searchDb(this._roomDb, query, sortFields, includeFields, limit, skip);
    }
    /**
     * User to either save a new room object or udpate an existing one
     * @param roomJid - The JID of the room
     * @param delta - Function which provides the current room as an argument and should return the updated room
     */
    saveRoom(roomJid, delta) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._saveObject(CtXmppClient.OBJECT_TYPES.ROOM, roomJid, delta, (object) => {
                resolve(object);
            }, (e) => {
                reject(e);
            });
        });
    }
    /**
     * User to either save a new room object or udpate an existing one
     * @param participantRoomJid - The participants room JID (e.g. test_room@conference.commontime.com/john_doe)
     * @param delta - Function which provides the current room as an argument and should return the updated room
     */
    saveParticipant(participantRoomJid, delta) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._saveObject(CtXmppClient.OBJECT_TYPES.PARTICIPANT, participantRoomJid, delta, (object) => {
                resolve(object);
            }, (e) => {
                reject(e);
            });
        });
    }
    /**
     * Method use to list all participants assoicated to a room
     * @param roomName
     * @returns {Promise}
     */
    listParticipantsByRoom(roomName) {
        this._isMethodReady(true);
        return this._searchDb(this._participantDb, {
            "room_name": roomName
        });
    }
    /**
     * Method to get a single participant by room name and user JID
     * @param roomName
     * @param jid
     * @returns {Promise}
     */
    getParticipantByRoomAndJid(roomName, jid) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            return this._searchDb(this._participantDb, {
                "room_name": roomName,
                "jid": jid
            }).then((results) => {
                if (results.length > 0) {
                    resolve(results[0]);
                }
                else {
                    resolve(null);
                }
            }).catch(reject);
        });
    }
    /**
     * Convenience method used to clean up the list of room participants based on a timestamp
     * @param ts
     * @returns {Promise}
     */
    purgeParticipantsByUpdatedAt(ts) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._searchDb(this._participantDb, {
                "updated_at": {
                    "$lt": ts
                }
            }).then((results) => {
                const proms = results.map((doc) => {
                    return this._participantDb.remove(doc);
                });
                es6_promise_1.Promise.all(proms).then(resolve).catch(reject);
            }).catch((e) => {
                console.error(e);
            });
        });
    }
    getServerVersion() {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${this._domain}`, "get", {
                "query": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.SOFTWARE_VERSION
                    },
                }
            }).then((result) => {
                if (result.iq && result.iq.query) {
                    resolve({
                        name: result.iq.query.name || "",
                        os: result.iq.query.os || "",
                        version: result.iq.query.version
                    });
                }
            }).catch(reject);
        });
    }
    /**
     * Methods interfacing with the Message Archive (XEP-0313)
     */
    /**
     * Private method to make recursive requests to the MAM to retrieve results, including paging through sets of data.
     * @param to {String}
     * @param archiveId {String}
     * @param backward {Boolean}
     * @param jid {String}
     * @param timestamp {Number}
     * @returns {Promise}
     * @private
     */
    _requestMessagesFromMam(to, archiveId = null, backward = false, jid = null, timestamp, max = this._options.mam.pageSize) {
        const _recursiveRequest = (successCallback, errorCallback, queryId, startDate, endDate, stanzas = [], _archiveId = null) => {
            const payload = {
                "query": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MAM,
                        "queryid": queryId
                    },
                    "x": {
                        "$attributes": {
                            "xmlns": "jabber:x:data",
                            "type": "submit"
                        },
                        "field": [
                            {
                                "$attributes": {
                                    "var": "FORM_TYPE",
                                    "type": "hidden"
                                },
                                "value": CtXmppClient.NAMESPACES.MAM
                            }
                        ]
                    },
                    "set": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.RESULT_SET_MANAGEMENT
                        },
                        "max": "" + max
                    }
                }
            };
            this._log(`Querying the message archive for start date '${startDate}' and end date '${endDate}'.`);
            if (startDate !== null || backward === true) {
                let value = "";
                if (backward === true) {
                    // Enable conversation mode
                    value += "inf_conv_mode";
                }
                if (startDate !== null) {
                    value += startDate.toISOString();
                }
                payload.query.x.field.push({
                    "$attributes": {
                        "var": "start"
                    },
                    "value": value
                });
            }
            if (endDate !== null) {
                payload.query.x.field.push({
                    "$attributes": {
                        "var": "end"
                    },
                    "value": endDate.toISOString()
                });
            }
            if (_archiveId !== null) {
                payload.query.set[(backward === true) ? "before" : "after"] = _archiveId;
            }
            if (jid !== null) {
                payload.query.x.field.push({
                    "$attributes": {
                        "var": "with"
                    },
                    "value": jid
                });
            }
            // Set-up the connection handler to listen for the MAM messages
            this._connection.addHandler(($stanza) => {
                // Convert the stanza to JSON
                const stanza = CtXmppClient.xmlToJson($stanza);
                // Add any processable stanzas to the array
                try {
                    if (stanza.message.result !== undefined && stanza.message.result.forwarded !== undefined && stanza.message.result.forwarded.message !== undefined) {
                        const messageStanza = stanza.message.result.forwarded;
                        // HACK (Leon Revill): For some reason the server doesn't provide the archived node for multi-cast messages when fetched from the MAM
                        // we are assuming this is a server bug and patching it for now.
                        if (stanza.message.result.forwarded.message.archived === undefined && stanza.message.result !== undefined && stanza.message.result.$attributes !== undefined && stanza.message.result.$attributes.id !== undefined) {
                            messageStanza.message.archived = {
                                $attributes: {
                                    by: index_1.default.Strophe.getBareJidFromJid(messageStanza.message.$attributes.from),
                                    id: stanza.message.result.$attributes.id,
                                    xmlns: CtXmppClient.NAMESPACES.MAM_TMP
                                }
                            };
                        }
                        stanzas.push(messageStanza);
                    }
                }
                catch (e) {
                    // Message not in the expected format
                    errorCallback(e);
                    return false;
                }
                // Detect when we get the finished message from the MAM query so we know when we've got everything we asked for
                const finished = (stanza.message.fin !== undefined && stanza.message.fin.$attributes !== undefined && stanza.message.fin.$attributes.xmlns === CtXmppClient.NAMESPACES.MAM);
                // If we've finished then its time to process the messages
                if (finished === true) {
                    // Have we got all the messages?
                    if (stanza.message.fin.$attributes.complete == "true" || backward === true) {
                        // Yes so even if we haven't hit the limit yet we don't have any more to fetch
                        // Just return what we have
                        this._log(`Finished paging through result set, got a total of '${stanzas.length}' items.`);
                        successCallback(stanzas);
                    }
                    else {
                        this._log(`Paging through result set to get a total of '${stanza.message.fin.set.count}' items.`);
                        this._log(`Got '${stanzas.length}' items so far...`);
                        // No, continue to page through the results specifying the archive ID of the last message in the current page
                        _recursiveRequest(successCallback, errorCallback, queryId, startDate, endDate, stanzas, stanza.message.fin.set.last);
                    }
                }
                // Stop listening for message when we get the <fin> node (i.e. the server has finished sending messages from the MAM)
                return !finished;
            }, CtXmppClient.NAMESPACES.JABBER_CLIENT, "message", null, null, to);
            // Send the actual MAM query to start the whole process
            this.sendIq(to, "set", payload, null).catch((e) => {
                this._onError("Couldn't query the MAM:", e);
                errorCallback(e);
            });
        };
        let startDate = null;
        let endDate = null;
        return new es6_promise_1.Promise((resolve, reject) => {
            if (timestamp !== null) {
                this.getServerTime().then(() => {
                    const endTs = this.getSyncedTimestamp(Date.now() + 60000);
                    if (timestamp >= endTs) {
                        reject(`The start timestamp (${timestamp}) cannot be equal to or larger than the end timestamp (${endTs}).`);
                    }
                    else {
                        startDate = new Date(timestamp);
                        endDate = new Date(endTs);
                        _recursiveRequest(resolve, reject, this.getUniqueId(), startDate, endDate, [], archiveId);
                    }
                });
            }
            else {
                _recursiveRequest(resolve, reject, this.getUniqueId(), startDate, endDate, [], archiveId);
            }
        });
    }
    /**
     * Method to initialise the MAM query, process the messages and emit events
     * @param to - The room JID or null if you want all messages
     * @param archiveId {Number} - The archive ID from the last message which the server should return messages from
     * @param jid {String} - The JID which each returned message should include
     * @param timeLimitTs {Number} - (ms) The maximum number of milliseconds (e.g. 3.6e+6 for 1 hour)
     * @param dispatch
     * @returns {Promise}
     */
    queryMam(to, archiveId = null, jid = null, timeLimitTs, dispatch = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            const limit = (timeLimitTs || this._options.mam.defaultTimeLimit);
            const timestamp = (Date.now() - limit);
            const timestampWithPadding = this.getSyncedTimestamp(timestamp - 60000); // Minus 1 minute to account for any slight time difference and latency when asking for the server time
            this._log(`Starting the MAM query process...`);
            this._perfStart("requestMessagesFromMam", "Starting the first request for MAM messages", "color: blue;");
            this._requestMessagesFromMam(to, archiveId, false, jid, timestampWithPadding).then((stanzasToProcess) => {
                this._perfEnd("requestMessagesFromMam", "Finished getting all messages from the MAM", "color: blue;");
                this._processMamStanzas(stanzasToProcess, dispatch, false).then(resolve).catch(reject);
            }).then(() => {
                if (this._options.autoPurgeOldMessagesAge > 0) {
                    return this.purgeMessagesOlderThan(this._options.autoPurgeOldMessagesAge);
                }
            }).then(() => {
                if (this._options.autoPurgeOldRetainMessageCount > 0) {
                    return this.purgeOldestMessagesLeavingCount(this._options.autoPurgeOldRetainMessageCount);
                }
            }).catch(reject);
        });
    }
    /**
     * Private method to process stanzas (as objects) which have come from the MAM
     */
    _processMamStanzas(stanzasToProcess, dispatch = true, injected = false, backward = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Array of message IDs we need to post-process (i.e. Mark any that don't already have markers)
            const _messagesToPostProcess = [];
            const _markersToPostProcess = [];
            if (stanzasToProcess.length === 0) {
                resolve([]);
            }
            else {
                this._perfStart("processMamMessages", "Starting to process all messages received from the MAM", "color: yellow; background: black;");
                this._perfStart("preProcessMamMessages", "Starting to pre-process all messages received from the MAM", "color: darkgreen; background: grey;");
                let queriesBiggestArchiveId = "0";
                // Now we've got all the historic messages from the MAM we can go back and mark any we've not seen before
                stanzasToProcess.forEach((stanza) => {
                    const defaults = {
                        state: {
                            sent: true
                        },
                        fromMam: (injected === false),
                        injected: (injected === true)
                    };
                    // If the message doesn't have a timestamp node then we should use the one provided by the MAM
                    let messageTs = false;
                    try {
                        messageTs = (stanza.message.timestamp !== undefined);
                    }
                    catch (e) {
                    }
                    if (messageTs === false) {
                        if (stanza.delay && stanza.delay.$attributes.stamp) {
                            let ts = null;
                            try {
                                ts = new Date(stanza.delay.$attributes.stamp).getTime();
                            }
                            catch (e) {
                                console.error("Couldn't parse stanza timestamp to integer.");
                            }
                            if (ts !== null) {
                                defaults.ts = ts;
                            }
                        }
                    }
                    const stanzasArchiveId = this._getArchiveIdFromStanza(stanza);
                    if (stanzasArchiveId > queriesBiggestArchiveId)
                        queriesBiggestArchiveId = stanzasArchiveId;
                    if (CtXmppClient._isMarkerMessage(stanza)) {
                        this._stanzaResponseHandler(stanza.message.$attributes.id);
                        _markersToPostProcess.push(stanza);
                    }
                    else if (stanza.message.$attributes && stanza.message.$attributes.type === "chat") {
                        _messagesToPostProcess.push(this._messageDelta(stanza, {}, defaults));
                    }
                    else if (stanza.message.$attributes && stanza.message.$attributes.type === "groupchat") {
                        // As this is a groupchat message it might be an echo so clear any send timeouts waiting
                        this._stanzaResponseHandler(stanza.message.$attributes.id);
                        _messagesToPostProcess.push(this._messageDelta(stanza, {}, defaults));
                    }
                    else if (stanza.message.call && stanza.message.call.$attributes && stanza.message.call.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                        // Bot command message success
                        // We don't want to process these bot command messages but we do want to clear any associated timers
                        this._log(`Processing bot command response from the MAM with request ID '${stanza.message.call.$attributes["request-id"]}':`, stanza);
                        this._botCommandResponseHandler(stanza.message.call.$attributes["request-id"], stanza);
                    }
                    else if (stanza.message.error && stanza.message.error.$attributes && stanza.message.error.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                        // Bot command message error
                        this._botCommandResponseHandler(stanza.message.error.$attributes["request-id"], stanza);
                    }
                    else if (stanza.message.ack && stanza.message.ack.$attributes && stanza.message.ack.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_ACK) {
                        // Peer-to-peer/multicast ack message
                        // We don't want to process this message just check for any outstanding send timeouts
                        this._stanzaResponseHandler(stanza.message.ack.$attributes["original-id"]);
                    }
                });
                // Once we've processed all the messages its time to go back and mark any messages using chat markers
                // We have to do this after the fact because otherwise we won't know if the next message in the MAM query is actually a chat marker
                // for the message we want to mark and we'd end up marking it twice
                this._perfEnd("preProcessMamMessages", "Finished pre-processing messages from the MAM.", "color: darkgreen; background: grey;");
                this._perfStart("postProcessMamMessages", "Start post-processing messages received from the MAM", "color: lightgreen; background: grey;");
                this._perfStart("addMarkersToMamMessages", "Adding markers to messages", "color: brown; background: #E1E1E1;");
                const markerProms = [];
                let requireNewMessageEvent = {};
                const markerStanzasByMessageId = {};
                _markersToPostProcess.forEach((markerStanza) => {
                    const markerType = CtXmppClient._getMarkerType(markerStanza);
                    const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                    if (!markerStanzasByMessageId[messageId])
                        markerStanzasByMessageId[messageId] = [];
                    markerStanzasByMessageId[messageId].push(markerStanza);
                });
                for (let messageId in markerStanzasByMessageId) {
                    const markers = markerStanzasByMessageId[messageId];
                    // Do we have the message in memory
                    let messageInMemory = null;
                    _messagesToPostProcess.every(message => {
                        if (message._id === messageId) {
                            messageInMemory = message;
                            return false;
                        }
                        return true;
                    });
                    // If so use it
                    if (messageInMemory !== null) {
                        markers.forEach(markerStanza => {
                            const markerType = CtXmppClient._getMarkerType(markerStanza);
                            const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                            const markerUpdateResult = this._updateMessageMarkers(markerStanza, markerType, messageInMemory);
                            if (markerUpdateResult !== false) {
                                requireNewMessageEvent[messageInMemory._id] = true;
                                messageInMemory = markerUpdateResult;
                            }
                        });
                    }
                    else {
                        // If not we need to look in the database
                        markerProms.push(new es6_promise_1.Promise(resolve => {
                            this.getMessageById(messageId).then(messageInDatabase => {
                                markers.forEach(markerStanza => {
                                    const markerType = CtXmppClient._getMarkerType(markerStanza);
                                    const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                                    const markerUpdateResult = this._updateMessageMarkers(markerStanza, markerType, messageInDatabase);
                                    if (markerUpdateResult !== false) {
                                        _messagesToPostProcess.push(markerUpdateResult);
                                    }
                                    else {
                                        // If we are not saving this to the db then we need to at least mark we've dealt with this message already
                                        this._setLastArchiveId(this._getArchiveIdFromStanza(markerStanza));
                                    }
                                });
                                resolve();
                            }).catch(() => {
                                // If the message doesn't exist locally then create a placeholder incase we see the message later
                                this._log(`Not found message with id '${messageId}', creating message placeholder...`);
                                let placeholder = Object.assign({}, CtXmppClient._messageSkeleton(), { _id: messageId, placeholder: true, markable: true, type: null });
                                markers.forEach(markerStanza => {
                                    const markerType = CtXmppClient._getMarkerType(markerStanza);
                                    const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                                    const res = this._updateMessageMarkers(markerStanza, markerType, placeholder);
                                    if (res !== false) {
                                        placeholder = res;
                                    }
                                });
                                _messagesToPostProcess.push(placeholder);
                                resolve();
                            });
                        }));
                    }
                }
                es6_promise_1.Promise.all(markerProms).then(() => {
                    this._log("Messages to save from the MAM:", _messagesToPostProcess);
                    if (_messagesToPostProcess.length === 0) {
                        resolve([]);
                    }
                    else {
                        this._perfEnd("addMarkersToMamMessages", "Finished adding markers to messages", "color: brown; background: #E1E1E1;");
                        const proms = [];
                        if (backward === true) {
                            // If we are going backwards we might have message placeholders with chat markers for some or all of these messages                                                
                            _messagesToPostProcess.forEach((message, index, arr) => proms.push(this.saveMessage(message._id, current => {
                                // Check to see if we already have this in the database, if not, return
                                if (!current._id)
                                    return;
                                // We've found the message so lets remove it from the array
                                arr.splice(index, 1);
                                // We want to keep the state on the placeholder object, this contains all the chat markers
                                delete message.state;
                                // Return the new object updated with the new message content
                                return Object.assign({}, current, message);
                            })));
                        }
                        es6_promise_1.Promise.all(proms).then(results => {
                            // Filter out messages we've already processed and saved
                            const messagesToSave = _messagesToPostProcess.filter(message => {
                                // Return true if this message ID doesn't exist within the results array
                                return results.filter(result => {
                                    if (!result)
                                        return false;
                                    return result._id === message._id;
                                }).length === 0;
                            });
                            this._msgDb.bulkDocs(messagesToSave).then((messageIds) => {
                                // Now all the messages have been persisted, update the last archive ID with the biggest from this query
                                // if this is bigger than the current last archive ID
                                this._setLastArchiveId(queriesBiggestArchiveId);
                                const finished = function (messages) {
                                    resolve([...messages, ...results].filter(msg => msg !== null));
                                };
                                if (messageIds.length > 0) {
                                    this._msgDb.bulkGet({
                                        docs: messageIds
                                    }).then(response => {
                                        let messages = response.results.map((result) => {
                                            const message = result.docs[0]["ok"];
                                            if (message === undefined)
                                                return null;
                                            // Dispatch an event to indicate a new or updated message as we suppressed these earlier
                                            if (dispatch !== false) {
                                                // Is it new?
                                                if (message.updated_at === null || requireNewMessageEvent[message._id] === true) {
                                                    // Yes
                                                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.NEW_MESSAGE, message);
                                                }
                                                else {
                                                    // No, so its an update
                                                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                                                }
                                            }
                                            // Mark the message if we haven't already
                                            if (this._options.autoMarkMessages === true)
                                                this._markMessage(message, CtXmppClient.MARKER_TYPES.RECEIVED, dispatch);
                                            return message;
                                        });
                                        requireNewMessageEvent = {};
                                        this._perfEnd("postProcessMamMessages", "Finished post-processing messages received from the MAM", "color: lightgreen; background: grey;");
                                        this._perfEnd("processMamMessages", "Finished processing messages received from the MAM", "color: yellow; background: black;");
                                        finished(messages);
                                    });
                                }
                                else {
                                    finished([]);
                                }
                            }).catch(e => {
                                console.error(e);
                                reject(e);
                            });
                        });
                    }
                });
            }
        });
    }
    processXmlStanzaStringsFromMam(stanzas, dispatch = true) {
        const parser = new DOMParser();
        // Convert the strings to XML Nodes
        const xmlNodes = stanzas.map(xmlStr => parser.parseFromString(xmlStr, "text/xml").childNodes[0]);
        // Convert the XML Nodes to JSON
        const stanzasToProcess = xmlNodes.map(xmlNode => CtXmppClient.xmlToJson(xmlNode));
        // Categorise each message into a room
        const rooms = {};
        stanzasToProcess.forEach(stanza => {
            // Find the room name and ID for each message
            try {
                const messageId = stanza.message.$attributes.id;
                const roomName = stanza.message.$attributes.to.split("@")[0];
                if (rooms[roomName] === undefined)
                    rooms[roomName] = [];
                rooms[roomName].push(messageId);
            }
            catch (e) {
                console.error("The stanza wasn't in the expected format:", e);
            }
        });
        // Get all the messages in the DB
        return this.getAllMessages().then((allMessages) => {
            let proms = [];
            // If we don't have any messages at all then there is nothing to do here
            if (allMessages.length > 0) {
                proms = Object.keys(rooms).map(roomName => {
                    // Find all the messages in the room
                    const messagesInRoom = allMessages.filter((message) => message.recipient_id === `${roomName}@${this.mucHost}` || message.sender_id === `${roomName}@${this.mucHost}`);
                    // If there are no messages in the room at all, do nothing.
                    if (messagesInRoom.length === 0)
                        return;
                    const roomMessageIds = rooms[roomName];
                    // Do we have any of the messages passed in already stored in the room
                    const messagesWeKnowAbout = roomMessageIds.filter((id) => {
                        return messagesInRoom.filter(message => message._id === id).length > 0;
                    });
                    // If we do then there are no gaps so don't do anything
                    if (messagesWeKnowAbout.length > 0)
                        return;
                    // Otherwise there is probably a gap so delete all messages in the room
                    return this.deleteMessagesByRoomName(roomName);
                });
            }
            // Once all thats done, process the stanzas as normal
            return es6_promise_1.Promise.all(proms).then(() => {
                return this._processMamStanzas(stanzasToProcess, dispatch, true);
            });
        });
    }
    /**
     * Clean up messages, removes messages older than configured age ms
     * @param age
     * @returns {Promise}
     */
    purgeOldMessages() {
        this._isMethodReady(true);
        return this.purgeMessagesOlderThan(this._options.autoPurgeOldMessagesAge);
    }
    /**
     * Clean up messages, removes messages older than 'age' ms
     * @param age
     * @returns {Promise}
     */
    purgeMessagesOlderThan(age) {
        this._isMethodReady(true);
        this._log(" Removing messages older than: " + age);
        return this.purgeMessagesFromBefore(this.getSyncedTimestamp(Date.now()) - age);
    }
    /**
     * Clean up messages, removes messages with a timestamp from before 'ts'
     * @param ts
     * @returns {Promise}
     */
    purgeMessagesFromBefore(ts) {
        this._isMethodReady(true);
        this._log(" Removing messages with timestamp before: " + new Date(ts).toISOString());
        return this.deleteMessages({
            "ts": {
                "$lt": ts
            }
        });
    }
    /**
     * Clean up messages, remove the oldest messages, leaving the newest 'count' behind
     * @param count
     */
    purgeOldestMessagesLeavingCount(count) {
        this._isMethodReady(true);
        this._log(" Want to restrict to: " + count + " messages in DB");
        return this._msgDb.info().then((info) => {
            this._log(" There are: " + info.doc_count + " messages in DB");
            const countToDelete = info.doc_count - count;
            if (countToDelete > 0) {
                this._log(" Going to delete: " + countToDelete + " messages from DB");
                return this.purgeOldestMessagesCount(countToDelete);
            }
        });
    }
    /**
     * Clean up messages, remove the oldest 'count' messages
     * @param count
     */
    purgeOldestMessagesCount(count) {
        this._isMethodReady(true);
        return this._msgDb.createIndex({ index: { fields: ['ts'] } }).then(() => {
            this._msgDb.find({ selector: {},
                sort: ['ts'],
                limit: count,
                fields: ['_id']
            }).then(messageIds => {
                let promiseChain = es6_promise_1.Promise.resolve();
                messageIds.docs.forEach(doc => {
                    promiseChain = promiseChain.then(() => {
                        this._log(" Deleting message: " + doc._id);
                        return this.deleteMessageById(doc._id).then(() => {
                            this._log(" Deleted message: " + doc._id);
                        });
                    });
                });
                return promiseChain;
            });
        });
    }
    _setLastArchiveId(archiveId) {
        if (archiveId > this._lastArchiveId) {
            this._lastArchiveId = archiveId;
            localStorage.setItem(`${this._instanceId}_last_archive_id`, archiveId);
        }
    }
    getLastArchiveId() {
        return this._lastArchiveId;
    }
    getLastArchiveIdForRoom(roomName) {
        this._isMethodReady(true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            let archiveId = "0";
            this.getChatHistory(to).then((results) => {
                if (results.length > 0) {
                    // Chat history only sorts by the timestamp, we also need to filter on updated_at so we know when we last stanza
                    // for this room was received. We also want the last message first.
                    const filteredItems = results.sort((a, b) => {
                        // Sort on the updated_at field
                        const x = b.updated_at - a.updated_at;
                        // Then sort on the ts field
                        return (x === 0) ? b.ts - a.ts : x;
                    });
                    const lastMessage = filteredItems[0];
                    archiveId = lastMessage.archive_id;
                }
                resolve(archiveId);
            }).catch(reject);
        });
    }
    getFirstArchiveIdForRoom(roomName) {
        this._isMethodReady(true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            let archiveId = "0";
            this.getChatHistory(to).then((results) => {
                if (results.length > 0) {
                    // Chat history only sorts by the timestamp, we also need to filter on updated_at so we know when we last stanza
                    // for this room was received. We also want the last message first.
                    const filteredItems = results.sort((a, b) => {
                        return a.ts - b.ts;
                    });
                    const firstMessage = filteredItems[0];
                    archiveId = firstMessage.archive_id;
                }
                resolve(archiveId);
            }).catch(reject);
        });
    }
    /**
     * Method to get missed messages for a specific room
     * @param roomName {String}
     * @param dispatch {Boolean}
     * @param archiveId {String|null} - Archive ID to use for MAM query instead of querying the room messages
     * @returns {Promise}
     */
    queryMamByRoomName(roomName, dispatch = true, archiveId = null) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        this._perfStart("queryMamByRoomName", `- Querying the MAM for room '${roomName}'`, "color: green;");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            const doQuery = (archiveId) => {
                this.queryMam(to, archiveId, null, null, dispatch).then((res) => {
                    this._perfEnd("queryMamByRoomName", `- Finished querying the MAM for message in room '${roomName}'.`, "color: green;");
                    resolve(res);
                }).catch(reject);
            };
            if (archiveId === null) {
                this.getLastArchiveIdForRoom(roomName).then(_archiveId => {
                    doQuery(_archiveId);
                }).catch(resolve);
            }
            else {
                doQuery(archiveId);
            }
        });
    }
    /**
     * Method to query room history by name
     * @param roomName {String} - The name of the room
     * @param beforeArchiveId {String|null} - Get messages from before this archive ID
     * @param dispatch {Boolean} - Whether to dispatch events as messages are processed
     * @returns {Promise}
     */
    queryMamRoomHistoryByName(roomName, beforeArchiveId = null, count = 5, dispatch = true, timestamp = null) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        this._perfStart("queryMamRoomHistoryByName", `Querying MAM history for room '${roomName}'`, "color: purple;");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            this._requestMessagesFromMam(to, beforeArchiveId, true, null, timestamp, count).then((stanzasToProcess) => {
                this._perfEnd("queryMamRoomHistoryByName", `Finished querying the MAM history for '${count}' messages in the '${roomName}' room.`, "color: purple;");
                this._processMamStanzas(stanzasToProcess, dispatch, false, true).then(resolve).catch(reject);
            }).then(() => {
                if (this._options.autoPurgeOldMessagesAge > 0) {
                    return this.purgeMessagesOlderThan(this._options.autoPurgeOldMessagesAge);
                }
            }).then(() => {
                if (this._options.autoPurgeOldRetainMessageCount > 0) {
                    return this.purgeOldestMessagesLeavingCount(this._options.autoPurgeOldRetainMessageCount);
                }
            }).catch(reject);
        });
    }
    /**
     * Convenience method to retrieve messages from the MAM by recipient
     * @param recipient
     * @param dispatch
     * @returns {Promise}
     */
    queryMamByRecipient(recipient, dispatch = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getChatHistory(recipient).then((results) => {
                let archiveId = null;
                if (results.length > 0) {
                    // Chat history only sorts by the timestamp, we also need to filter on updated_at so we know when we last stanza
                    // for this room was received. We also want the last message first.
                    const filteredItems = results.sort((a, b) => {
                        // Sort on the updated_at field
                        const x = b.updated_at - a.updated_at;
                        // Then sort on the ts field
                        return (x === 0) ? b.ts - a.ts : x;
                    });
                    const lastMessage = filteredItems[0];
                    archiveId = lastMessage.archive_id;
                }
                this.queryMam(null, archiveId, recipient, null, dispatch).then(resolve).catch(reject);
            }).catch((e) => console.error);
        });
    }
    /**
     * Base method used to persist objects to a database
     * @param object
     * @param id
     * @param delta
     * @param successCb
     * @param errorCb
     * @private
     */
    _saveObject(object, id, delta, successCb, errorCb) {
        // Don't try and save if we are in the process of destroying the DBs
        if (this._destroyingDbs) {
            this._log(`Couldn't save '${object}' because the databases are being destroyed.`);
            if (errorCb)
                errorCb(CtXmppClient.ERROR_CODES.DESTROYING_DBS);
            return;
        }
        let _db = null;
        switch (object) {
            case CtXmppClient.OBJECT_TYPES.MESSAGE:
                _db = this._msgDb;
                break;
            case CtXmppClient.OBJECT_TYPES.CONTACT:
                _db = this._contactDb;
                break;
            case CtXmppClient.OBJECT_TYPES.ROOM:
                _db = this._roomDb;
                break;
            case CtXmppClient.OBJECT_TYPES.PARTICIPANT:
                _db = this._participantDb;
                break;
            case CtXmppClient.OBJECT_TYPES.CACHE_ITEM:
                _db = this._cacheDb;
                break;
        }
        if (_db === null)
            throw new Error(`The object type provided (${object}) is not valid.`);
        if (this._saveDebounce[object] === undefined)
            this._saveDebounce[object] = {};
        if (!this._saveDebounce[object][id]) {
            this._saveDebounce[object][id] = true;
            _db.upsert(id, delta).then((res) => {
                // There might be a case where we returned false in the upsert delta and therefore a message was never created
                // if that's the case there won't be a revision and nothing to get, so just ignore
                if (res.rev !== undefined) {
                    _db.get(id).then((doc) => {
                        delete this._saveDebounce[object][id];
                        if (successCb)
                            successCb(doc);
                    }).catch((e) => {
                        this._onError(`Couldn't get ${object} with ID '${id}' after performing an update.`, e);
                        delete this._saveDebounce[object][id];
                        if (errorCb)
                            errorCb(e);
                    });
                }
                else {
                    delete this._saveDebounce[object][id];
                    if (successCb)
                        successCb(null);
                }
            }).catch((e) => {
                this._log(`Couldn't update ${object} with ID '${id}'.`, e);
                delete this._saveDebounce[object][id];
                if (errorCb)
                    errorCb(e);
            });
        }
        else {
            setTimeout(() => {
                this._saveObject(object, id, delta, successCb, errorCb);
            }, 250);
        }
    }
    /**
     * Private method used to perform the actual download and figure out if Basic Authentication is needed
     * @param url {String}
     * @returns {Promise}
     * @private
     */
    doDownload(url) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const __doDownload = headers => {
                File.download(url, headers).then((result) => {
                    var fileEncryption = Plugin.getSource("fileEncryption");
                    if (environment_1.isDevice() && this._options.fileEncryption && fileEncryption) {
                        fileEncryption.encrypt(function (encryptedUri) {
                            result.source = encryptedUri;
                            resolve(result);
                        }, function (error) {
                            reject(error);
                        }, result.source);
                    }
                    else {
                        resolve(result);
                    }
                }).catch(reject);
            };
            if (this._options.authAttachments === true) {
                this._getCacheItem("user_password").then(password => {
                    return this._embellishPasswordWithAdToken(password);
                }).then(_password => {
                    __doDownload({
                        "Authorization": "Basic " + btoa(this._bareJid + ":" + _password)
                    });
                });
            }
            else {
                __doDownload(null);
            }
        });
    }
    /**
     * Download a specific attachment, from a message and an attachment number.
     * @param message - the message object with the attachent
     * @param attachmentNumber - 0 indexed attachment number
     * @param dispatch - fire event when message is updated with attachment
     * @returns {Promise}
     */
    downloadAttachment(message, attachmentNumber, dispatch = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            if (attachmentNumber > message.attachments.length - 1) {
                return reject("No such attachment: " + attachmentNumber);
            }
            const attachment = message.attachments[attachmentNumber];
            if (attachment.path === undefined) {
                this.doDownload(attachment.get).then((result) => {
                    attachment.path = result.source;
                    attachment.state = "transferred";
                    this.saveMessage(message._id, (oldMessage) => {
                        // Update message with attachments by returning the updated object
                        oldMessage.attachments[attachmentNumber] = attachment;
                        return oldMessage;
                    }).then((_message) => {
                        if (dispatch !== false) {
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, _message);
                        }
                        resolve();
                    });
                }).catch(reject);
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Method used to manually initialise the user directory, searchUsers and updateUserDirectory methods call this automatically
     * @returns {Promise<void | string>}
     */
    initUserDirectory() {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Check to see if the index has already been initialised
            if (this._userDirectory.initialised === true) {
                // If so just resolve
                resolve();
            }
            else {
                // If not let's initialise it
                // Create an IV
                let ivArr = null;
                let iv = localStorage.getItem(`${this._instanceId}_ud_iv`);
                if (iv == null) {
                    ivArr = window.crypto.getRandomValues(new Uint8Array(16));
                    let stringArray = [];
                    for (let i = 0; i < 16; i++) {
                        stringArray.push(String.fromCharCode(ivArr[i]));
                    }
                    const str = stringArray.join("");
                    localStorage.setItem(`${this._instanceId}_ud_iv`, str);
                }
                else {
                    const bufView = new Uint8Array(16);
                    for (let i = 0; i < iv.length; i++) {
                        bufView[i] = iv.charCodeAt(i);
                    }
                    ivArr = bufView;
                }
                utils_1.getEncryptionKey(this._instanceId).then((key) => {
                    this._userDirectory.initialise(key, ivArr, this._options.userDirectoryEncryptionBlockSize || 2000).then(resolve).catch(reject);
                });
            }
        });
    }
    _updateUserDirectoryTimer() {
        setTimeout(() => {
            this.updateUserDirectory().then((result) => {
                this._log(` Updated user directory: ${result}`);
            }).catch((e) => {
                this._log(` Couldn't update user directory: ${e.message}`);
            });
        }, this._options.updateUserDirectoryInterval);
    }
    /**
     * Method used to get any updates to the user directory from the server
     * @returns {Promise<DirectoryUser[]>}
     */
    updateUserDirectory() {
        // Initialise the index if not already done
        return this.initUserDirectory().then(() => {
            this._log(" Updating user directory...");
            // Get the user_directory_hash if we have one
            return this._getCacheItem("user_directory_hash").then(hash => {
                // Construct the payload
                const payload = {
                    query: {
                        $attributes: {
                            xmlns: CtXmppClient.NAMESPACES.DIRECTORY
                        }
                    }
                };
                // Include the hash if we have one
                if (hash)
                    payload.query.$attributes.hash = hash;
                // Do the IQ request to obtain the download URL to be passed to the worker for download and indexing
                return this.sendIq(this._domain, "get", payload).then((res) => {
                    try {
                        // Grab the download URL from the response
                        const url = res.iq.query.$attributes.url;
                        // If the url is undefined then there is no change so just return
                        if (url === undefined) {
                            this._updateUserDirectoryTimer();
                            return `No change since last update.`;
                        }
                        // Get the user password to pass to the worker to do the download
                        return this._getCacheItem("user_password").then(password => {
                            return this._embellishPasswordWithAdToken(password);
                        }).then(_password => {
                            // Call the user's class to do the download and indexing
                            return this._userDirectory.update(this._bareJid, _password, url).then(data => {
                                // Cache the hash returned from the JSON response to be used on the next request
                                return this._setCacheItem("user_directory_hash", data.hash).then(() => {
                                    this._log(" User directory successfully updated.");
                                    this._updateUserDirectoryTimer();
                                    // Return the message
                                    return data.msg;
                                });
                            });
                        });
                    }
                    catch (e) {
                        this._updateUserDirectoryTimer();
                        return es6_promise_1.Promise.reject("Couldn't obtain directory URL from server.");
                    }
                });
            });
        }).catch(e => {
            return this._getCacheItem("user_directory_hash").then(hash => {
                if (hash !== undefined) {
                    return this._deleteCacheItem("user_directory_hash").then(() => {
                        return this.updateUserDirectory().then((data) => {
                            return es6_promise_1.Promise.resolve(data);
                        }).catch((e) => {
                            return es6_promise_1.Promise.reject(e);
                        });
                    });
                }
                else {
                    return es6_promise_1.Promise.reject(e);
                }
            });
        });
    }
    /**
     * Method used to do a full-text search on all users in the user directory. Searchable fields are jid, prefix, firstName, lastName and title
     * @param query {String}
     * @param fields {Array}
     * @returns {Promise<any>}
     */
    searchUsers(query, fields) {
        return this.initUserDirectory().then(() => {
            return this._userDirectory.search(query, fields);
        });
    }
    /**
     * Method used to return all users from the user directory - use at your own risk if there are many users.
     * @returns {Promise<any>}
     */
    getAllUsers(excludeDeleted = false) {
        return this.initUserDirectory().then(() => {
            return this._userDirectory.getAllUsers(excludeDeleted);
        });
    }
    /**
     * Method used to get a single user from the user directory by the JID
     * @param jid {String}
     * @returns {Promise<any>}
     */
    getUserByJid(jid) {
        return this.initUserDirectory().then(() => {
            return this._userDirectory.getUserByJid(jid);
        });
    }
    downloadAttachments(message, dispatch = true) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (Array.isArray(message.attachments) && message.attachments.length > 0) {
                // Download attachments
                let promiseChain = es6_promise_1.Promise.resolve({});
                message.attachments.forEach((attachment, index) => {
                    promiseChain = promiseChain.then(() => {
                        return new es6_promise_1.Promise((resolve, reject) => {
                            // Only download the file if we haven't done already
                            if (attachment.path === undefined) {
                                this.doDownload(attachment.get).then((result) => {
                                    message.attachments[index].path = result.source;
                                    message.attachments[index].mediaType = File.getMediaTypeFromExtension(result.source);
                                    message.attachments[index].state = "transferred";
                                    resolve();
                                }).catch(reject);
                            }
                            else {
                                resolve();
                            }
                        });
                    });
                });
                promiseChain.then(() => {
                    this.saveMessage(message._id, () => {
                        // Update message with attachments by returning the updated object
                        return message;
                    }).then((_message) => {
                        // Dispatch the appropriate event
                        if (dispatch !== false) {
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, _message);
                        }
                        this._log(`Successfully updated message '${_message._id}' with attachments.`, _message);
                        resolve(_message);
                    }).catch((e) => {
                        this._onError(`Unable to update message '${message._id}' with attachments:`, e);
                        reject(e);
                    });
                }).catch((e) => {
                    this._onError("Unable to download all message attachments:", e);
                    reject(e);
                });
            }
            else {
                // No attachments so no modifications needed
                resolve(message);
            }
        });
    }
    /**
     * Private method used to internally process a new message
     * @param stanza
     * @param overrides
     * @param mark
     * @param dispatch
     * @returns {Promise}
     * @private
     */
    _processNewMessage(stanza, overrides, mark = true, dispatch = true) {
        this._perfStart(`processNewMessage (${stanza.message.$attributes.id.split("-")[0]})`, "Starting to process a new message", "color: purple;");
        return new es6_promise_1.Promise((resolve, reject) => {
            this._setLastArchiveId(this._getArchiveIdFromStanza(stanza));
            this._messageStanzaToDbObject(stanza, overrides)
                .then((message) => {
                // Dispatch the appropriate event
                if (dispatch !== false) {
                    if (message.updated_at === null) {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.NEW_MESSAGE, message);
                    }
                    else {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                    }
                }
                // Check message timestamp to see if we want to download attachments
                // TODO: Put as function shouldDownloadAttachments
                const diff = this.getSyncedTimestamp(new Date().getTime()) - message.ts;
                if (diff < this._options.autoDownloadAttachmentTime || this._options.autoDownloadAttachmentTime == -1) {
                    return this.downloadAttachments(message, dispatch);
                }
                else {
                    return message;
                }
            })
                .then((message) => {
                // Only mark the message if the sender say's it can be marked based on XEP-0333 and its not our message
                if (stanza.message.markable && mark === true && this._options.autoMarkMessages === true) {
                    this._markMessage(message, CtXmppClient.MARKER_TYPES.RECEIVED, dispatch).then((res) => {
                        this._perfEnd(`processNewMessage (${stanza.message.$attributes.id.split("-")[0]})`, "Finished processing a new message", "color: purple;");
                        resolve(res);
                    }).catch(reject);
                }
                else {
                    this._perfEnd(`processNewMessage (${stanza.message.$attributes.id.split("-")[0]})`, "Finished processing a new message", "color: purple;");
                    resolve(message);
                }
            }).catch(reject);
        });
    }
    /**
     * Abstraction of the _processNewMessage method to specifically handle group messages
     * @param stanza
     * @param overrides
     * @param mark
     * @param dispatch
     * @returns {Promise}
     * @private
     */
    _processGroupMessage(stanza, overrides, mark = true, dispatch = true) {
        // Get the nickname from the room JID to determine if we sent this message
        const _overrides = CtXmppClient._merge({
            type: "groupchat",
            mine: (index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from) === this._bareJid || index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from) === this.username)
        }, overrides);
        try {
            this._stanzaResponseHandler(stanza.message.$attributes.id);
        }
        catch (e) {
            this._onError(`Couldn't process stanza response handler for stanza:`, stanza);
        }
        return this._processNewMessage(stanza, _overrides, mark, dispatch);
    }
    _updateMessageMarkers(stanza, markerType, message) {
        // If the message doesn't already exists then ignore
        if (!message._id)
            return false;
        // Don't mark the message unless its been marked as markable
        if (!message.markable)
            return false;
        const from = index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from);
        const resource = index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from);
        // If we've already had a marker of this type for this message from the same person, ignore it.
        const ignore = message.state.markers.some((_marker) => {
            if (_marker.type === markerType && ((_marker.sender_id === from && _marker.sender_resource === resource) || (_marker.sender_resource === this.bareJid))) {
                return true;
            }
        });
        if (ignore === true)
            return false;
        const marker = {
            type: markerType,
            sender_id: from,
            sender_resource: resource,
            recipient_id: stanza.message.$attributes.to,
            ts: this._getTimestampFromStanza(stanza),
            priority: CtXmppClient.MARKER_PRIORITIES[markerType]
        };
        // Add the new marker to the markers array
        message.state.markers.push(marker);
        // Sort the markers based on priority and then timestamp
        message.state.markers = message.state.markers.sort(function (a, b) {
            if (a.priority !== b.priority) {
                return (a.priority - b.priority);
            }
            else if (b.ts !== null && a.ts !== null) {
                return (b.ts - a.ts);
            }
        });
        // Update the flag to indicate we have had at least one of this type of marker
        message.state[markerType] = true;
        // If the message wasn't marked sent we know it has been because we have received a marker for it
        if (message.state.sent !== true)
            message.state.sent = true;
        // Update the messages updated_at
        message.updated_at = this.getSyncedTimestamp(Date.now());
        return message;
    }
    static _getMarkerType(stanza) {
        // Figure out if and which type of chat marker we are dealing with
        let markerType = null;
        if (stanza.message.received) {
            markerType = CtXmppClient.MARKER_TYPES.RECEIVED;
        }
        else if (stanza.message.read) {
            markerType = CtXmppClient.MARKER_TYPES.READ;
        }
        else if (stanza.message.acknowledged) {
            markerType = CtXmppClient.MARKER_TYPES.ACKNOWLEDGED;
        }
        return markerType;
    }
    static _getMarkerMessageId(stanza, markerType) {
        return (stanza.message[markerType].$attributes !== undefined && stanza.message[markerType].$attributes.id !== undefined) ? stanza.message[markerType].$attributes.id : null;
    }
    /**
     * Private method used to process incoming marker messages and mark local messages accordingly
     * @param stanza
     * @param dispatch
     * @returns {Promise}
     * @private
     */
    _processMarkerMessage(stanza, dispatch = true) {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._setLastArchiveId(this._getArchiveIdFromStanza(stanza));
            // Figure out if and which type of chat marker we are dealing with
            const markerType = CtXmppClient._getMarkerType(stanza);
            // If we are dealing with a chat marker then let's do it
            if (markerType !== null) {
                // We've received a chat marker telling us the recipient has either received, read or acknowledged one of our messages, let's find that message and mark it so
                const messageId = CtXmppClient._getMarkerMessageId(stanza, markerType);
                if (messageId !== null) {
                    this._log(`Processing marker of type '${markerType}' for message with ID '${messageId}':`, stanza);
                    this._stanzaResponseHandler(stanza.message.$attributes.id);
                    const from = index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from);
                    const resource = index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from);
                    this.saveMessage(messageId, (message) => {
                        return this._updateMessageMarkers(stanza, markerType, message);
                    }).then((message) => {
                        if (message !== null) {
                            const receipt = {
                                message_id: message._id,
                                message: message,
                                type: markerType,
                                sender_id: from,
                                sender_resource: resource
                            };
                            if (dispatch !== false)
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, receipt);
                            if (dispatch !== false)
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                            resolve(receipt);
                        }
                        else {
                            // We got a marker for a message we don't know about, so just ignore it
                            resolve(null);
                        }
                    }).catch(reject);
                }
            }
        });
    }
    /**
     * Private method used to process error stanzas
     * @param stanza
     * @returns {Promise}
     * @private
     */
    _processErrorMessage(stanza) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const messageId = (stanza.message.$attributes && stanza.message.$attributes.id) ? stanza.message.$attributes.id : null;
            if (messageId !== null) {
                const msg = (stanza.message.error && stanza.message.error.text && stanza.message.error.text.$value) ? stanza.message.error.text.$value : `The server returned an error for stanza with ID '${messageId}'.`;
                this._onError(msg, Object.assign({}, stanza.message.error, { messageId }));
                this._stanzaResponseHandler(messageId, msg);
                this.saveMessage(messageId, (message) => {
                    // We only want to update existing messages
                    if (message._id === undefined)
                        return false;
                    // There was an error so mark it as failed to send (Unless we've had a received or read marker)
                    if (message.state.read !== true && message.state.received !== true && message.state.acknowledged !== true) {
                        message.state.sent = false;
                    }
                    else if (message.state.sent !== true) {
                        // If we've had a marker but the message was never marked sent, mark it sent.
                        message.state.sent = true;
                    }
                    return message;
                }).then(() => {
                    resolve({
                        id: messageId,
                        msg: msg
                    });
                }).catch(reject);
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Private method used to process ack stanzas
     * @param stanza
     * @returns {Promise}
     * @private
     */
    _processAckMessage(stanza) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (stanza.message.ack && stanza.message.ack.$attributes && stanza.message.ack.$attributes["original-id"]) {
                const messageId = stanza.message.ack.$attributes["original-id"];
                this._stanzaResponseHandler(messageId);
                this._dispatchEvent(CtXmppClient.EVENT_TYPES.ACK_RECEIVED, messageId);
                // Find the message this ack is for and update the sent flag if not done already
                this.saveMessage(messageId, (message) => {
                    // We only want to update existing messages
                    if (message._id === undefined)
                        return false;
                    if (message.state.sent !== true)
                        message.state.sent = true;
                    return message;
                }).then(resolve).catch(reject);
            }
            else {
                resolve();
            }
        });
    }
    _onIq(json) {
        if (json && json.iq) {
            if (json.iq.ping && json.iq.$attributes && json.iq.$attributes.from && json.iq.$attributes.id) {
                // Use a setTimeout here to that it fails to respond if Android has gone into Limbo mode.
                setTimeout(() => {
                    this.sendIq(json.iq.$attributes.from, "result", {}, undefined, json.iq.$attributes.id);
                }, 0);
            }
        }
        return true;
    }
    /**
     * Method used to handle incoming messages
     * @param $stanza
     * @returns {boolean}
     * @private
     */
    _onStanza($stanza) {
        // If any stanza is received then we must be connected
        this.connected = true;
        this._setStatus(index_1.default.Strophe.Status.CONNECTED);
        try {
            const stanza = CtXmppClient.xmlToJson($stanza);
            if (this._isFilteredOut(stanza)) {
                return true;
            }
            this._log(`[1] - Processing stanza with ID '${stanza.message.$attributes.id}':`, stanza);
            // Process a carbon copy of a message this user has sent on another device
            if (stanza.message.$attributes && stanza.message.$attributes.type === "chat" && stanza.message.sent !== undefined && stanza.message.sent.$attributes !== undefined && stanza.message.sent.$attributes.xmlns === CtXmppClient.NAMESPACES.CARBONS && stanza.message.sent.forwarded !== undefined) {
                this._processNewMessage(stanza.message.sent.forwarded, { state: { sent: true } });
                // Process a standard XMPP chat message
            }
            else if (stanza.message.$attributes && stanza.message.$attributes.type === "chat") {
                // Save the message to the database and mark the message if it is markable (Chat Markers)
                this._processNewMessage(stanza);
                // Process a groupchat message received as a room subscription (MUC/Sub)
            }
            else if (stanza.message.event && stanza.message.event.items) {
                const __processItem = (item) => {
                    if (CtXmppClient._isMarkerMessage(item)) {
                        this._log(`[2] - Processing stanza with ID '${stanza.message.$attributes.id}':`, stanza);
                        this._processMarkerMessage(item);
                    }
                    else {
                        this._processGroupMessage(item);
                    }
                };
                if (Array.isArray(stanza.message.event.items.item)) {
                    stanza.message.event.items.forEach(item => {
                        if (item.message && item.message.$attributes && item.message.$attributes.type === "groupchat") {
                            __processItem(item);
                        }
                        else if (item.presence) {
                            this._onPresence(item);
                        }
                    });
                }
                else if (typeof stanza.message.event.items.item === "object" && stanza.message.event.items.item.message && stanza.message.event.items.item.message.$attributes && stanza.message.event.items.item.message.$attributes.type === "groupchat") {
                    __processItem(stanza.message.event.items.item);
                }
                else if (typeof stanza.message.event.items.item === "object" && stanza.message.event.items.item.presence) {
                    this._onPresence(stanza.message.event.items.item);
                }
                // Deal with chat markers
            }
            else if (CtXmppClient._isMarkerMessage(stanza)) {
                this._log(`[3] - Processing stanza with ID '${stanza.message.$attributes.id}':`, stanza);
                this._processMarkerMessage(stanza);
                // Process a groupchat message received as a room participant (MUC)
            }
            else if (stanza.message.$attributes && stanza.message.$attributes.type === "groupchat" && stanza.message.$attributes.id) {
                this._processGroupMessage(stanza);
            }
            else if (stanza.message.$attributes && stanza.message.$attributes.type === "error") {
                this._processErrorMessage(stanza);
            }
            else if (stanza.message.ack !== undefined) {
                this._processAckMessage(stanza);
            }
            else if (stanza.message.call && stanza.message.call.$attributes && stanza.message.call.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                // Bot command message success
                this._log(`Processing bot command response with request ID '${stanza.message.call.$attributes["request-id"]}':`, stanza);
                this._botCommandResponseHandler(stanza.message.call.$attributes["request-id"], stanza);
            }
            else if (stanza.message.error && stanza.message.error.$attributes && stanza.message.error.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                // Bot command message error
                this._botCommandResponseHandler(stanza.message.error.$attributes["request-id"], stanza);
            }
        }
        catch (error) {
            this._onError("An error occurred when processing an incoming message stanza:", error);
        }
        return true;
    }
    /**
     * Returns true if message is filtered out by inclusive or exclusive filters
     *
     * @param stanza
     * @returns {boolean}
     * @private
     */
    _isFilteredOut(stanza) {
        let filteredIn = true;
        if (this._includeStanzaFilters.length > 0) {
            filteredIn = false;
            // If any filter returns true then always include this message, if a filter function throws an exception then do not include
            if (this._includeStanzaFilters.some((filter) => {
                try {
                    return filter(stanza);
                }
                catch (e) {
                    this._log("Include filter function failed: " + e);
                    this._onError("Include filter function failed: " + e);
                    return false;
                }
            })) {
                filteredIn = true;
            }
        }
        // If any filter returns true then always exclude this message, if a filter function throws an exception then do not exclude
        if (this._excludeStanzaFilters.some((filter) => {
            try {
                return filter(stanza);
            }
            catch (e) {
                this._log("Exclude filter function failed: " + e);
                this._onError("Exclude filter function failed: " + e);
                return false;
            }
        })) {
            filteredIn = false;
        }
        return !filteredIn;
    }
    /**
     * Convenience method used to determine if a message is in a group chat
     * @param messageStanza
     * @returns {string|boolean}
     * @private
     */
    _messageIsGroupChat(messageStanza) {
        return (this._options.mucHost && messageStanza.$attributes && typeof messageStanza.$attributes.from === "string" && messageStanza.$attributes.from.indexOf(this._options.mucHost) > -1);
    }
    /**
     * Private method used to handle all incoming presence updates
     * @param json
     * @returns {boolean}
     * @private
     */
    _onPresence(json) {
        if (json.presence !== undefined) {
            const presence = json.presence;
            if (presence.$attributes !== undefined && presence.$attributes.from !== undefined) {
                if (presence.$attributes.type === "error") {
                    this._onError("An error from the server was received in a presence stanza:", presence);
                    return true;
                }
                // Ensure the jid is present and its not the currently logged in user
                const jid = index_1.default.Strophe.getBareJidFromJid(presence.$attributes.from);
                if (!jid)
                    return true;
                // Check to see if this presence update is from the currently logged in user on another device
                if (jid === this._bareJid) {
                    // If it is then we need to update the current clients chat status based on this new information
                    this.setChatStatus(presence.show, presence.status, false, presence.metadata);
                }
                else {
                    // Figure out if we are dealing with room presence or standard presence
                    const domain = CtXmppClient.getDomainFromJid(jid);
                    if (this._options.mucHost === domain) {
                        this.saveParticipant(presence.$attributes.from, (participant) => {
                            if (participant._id !== undefined) {
                                // Update
                                try {
                                    participant.show = presence.show;
                                    participant.status = presence.status;
                                    participant.online = (presence.$attributes.type !== "unavailable");
                                    participant.affiliation = presence.x.item.$attributes.affiliation;
                                    participant.room_role = presence.x.item.$attributes.role;
                                    participant.last_stanza = presence;
                                    if (presence.metadata !== undefined) {
                                        const metadata = presence.metadata;
                                        delete metadata.$attributes;
                                        participant.metadata = metadata;
                                    }
                                    participant.updated_at = this.getSyncedTimestamp(Date.now());
                                }
                                catch (e) {
                                    this._onError(`Presence stanza wasn't in the expected format when trying to update participant with ID '${participant._id}' and JID '${participant.jid}'.`, e);
                                }
                            }
                            else {
                                // Create
                                try {
                                    participant._id = presence.$attributes.from;
                                    participant.jid = index_1.default.Strophe.getBareJidFromJid(presence.x.item.$attributes.jid);
                                    participant.is_current_user = (participant.jid === this._jid);
                                    participant.username = index_1.default.Strophe.getNodeFromJid(participant.jid);
                                    participant.room_name = index_1.default.Strophe.getNodeFromJid(presence.$attributes.from);
                                    participant.affiliation = presence.x.item.$attributes.affiliation;
                                    participant.room_role = presence.x.item.$attributes.role;
                                    // Flag if the user is online/offline
                                    participant.online = (presence.$attributes.type !== "unavailable");
                                    participant.show = presence.show;
                                    participant.status = presence.status;
                                    participant.ts = this.getSyncedTimestamp(Date.now());
                                    if (presence.metadata !== undefined) {
                                        const metadata = presence.metadata;
                                        delete metadata.$attributes;
                                        participant.metadata = metadata;
                                    }
                                    participant.updated_at = null;
                                    participant.last_stanza = presence;
                                }
                                catch (e) {
                                    this._onError(`Presence stanza wasn't in the expected format when trying to create a new participant with ID '${participant._id}' and JID '${participant.jid}'.`, e);
                                }
                            }
                            return participant;
                        }).then((participant) => {
                            if (participant.updated_at === null) {
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.NEW_PARTICIPANT, participant);
                            }
                            else {
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.PARTICIPANT_UPDATED, participant);
                            }
                        }).catch((e) => {
                            this._onError("Couldn't upsert participant database.", e);
                        });
                    }
                    else {
                        this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, jid, (contact) => {
                            if (contact !== undefined) {
                                // Flag if the user is online/offline
                                contact.online = (presence.$attributes.type !== "unavailable");
                                if (presence.show !== undefined) {
                                    contact.show = presence.show;
                                }
                                if (presence.status !== undefined) {
                                    contact.status = presence.status;
                                }
                                if (presence.metadata !== undefined) {
                                    const metadata = presence.metadata;
                                    delete metadata.$attributes;
                                    contact.metadata = metadata;
                                }
                            }
                            return contact;
                        }, (contact) => {
                            let vCardUpdate = false;
                            // If there has been a vCard avatar update, fetch the new vCard
                            if (presence.x && presence.x.$attributes && presence.x.$attributes.xmlns && presence.x.$attributes.xmlns === CtXmppClient.NAMESPACES.VCARD_UPDATE) {
                                if (presence.x.photo !== undefined && typeof presence.x.photo === "string") {
                                    if (contact.avatarHash === undefined || contact.avatarHash !== presence.x.photo) {
                                        vCardUpdate = true;
                                        // This contact's avatar has changed.  Fetch new vcard for them
                                        this._log(" Avatar update for:", jid);
                                        this._log(" New avatar hash:", presence.x.photo);
                                        this.updatevCardForContact(jid).then(() => {
                                            // Contact updated.
                                            this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, jid, (contact) => {
                                                contact.avatarHash = presence.x.photo;
                                                return contact;
                                            }, (contact) => {
                                                // Contact updated with avatar hash
                                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, contact);
                                            }, (e) => {
                                                this._onError("Couldn't update contact with vCard: ", e);
                                            });
                                        }).catch((e) => {
                                            this._onError("Couldn't get updated vCard for contact: ", e);
                                        });
                                    }
                                }
                            }
                            if (vCardUpdate === false) {
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, contact);
                            }
                        }, (e) => {
                            this._onError("Couldn't upsert contacts database.", e);
                        });
                    }
                }
            }
        }
        return true;
    }
    /**
     * Fetch a contact by it's jid
     * @param {string} jid
     * @returns {Promise<Contact>}
     */
    getContactByJid(jid) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.findContacts({
                "id": jid
            }).then((results) => {
                let contact = results[0];
                if (contact !== undefined) {
                    resolve(contact);
                }
                else {
                    reject("No contact found: " + jid);
                }
            }).catch(reject);
        });
    }
    /**
     * Fetch a vCard for a user, store it on their contact
     * @param jid
     * @returns {Promise}
     */
    updatevCardForContact(jid) {
        this._isMethodReady(true, true);
        this._log(" Updating vCard for Contact:", jid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.findContacts({
                "id": jid
            }).then((results) => {
                let contact = results[0];
                if (contact !== undefined) {
                    return contact;
                }
                else {
                    this._log(" No contact:", jid);
                    reject("No contact found: " + jid);
                }
            }).then((contact) => {
                this._getvCard(jid).then((vCardStr) => {
                    if (vCardStr !== undefined) {
                        const card = vcard_simple_1.VCardSimple.fromXml(vCardStr);
                        if (card !== undefined) {
                            this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, jid, (contact) => {
                                contact.vCard = card.toJSON();
                                return contact;
                            }, (contact) => {
                                this._log(" vCard Updated:", jid);
                                resolve(contact);
                            }, (e) => {
                                this._log(" Couldn't save contact:", jid);
                                reject("Couldn't save contact: " + e);
                            });
                        }
                        else {
                            this._log(" Bad vCard:", jid);
                            reject("Bad vCard");
                        }
                    }
                    else {
                        this._log(" No vCard:", jid);
                        resolve(null);
                    }
                }).catch(reject);
            }).catch(reject);
        });
    }
    /**
     * Private method to process the roster and convert items to contacts
     * @param roster
     * @returns {Promise}
     * @private
     */
    _processRoster(roster) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (roster !== undefined && roster.iq !== undefined && roster.iq.query !== undefined) {
                // Cache the current roster version if we've been given one by the server
                if (roster.iq.query.$attributes !== undefined && roster.iq.query.$attributes.ver !== undefined) {
                    this._setCacheItem("roster_version", roster.iq.query.$attributes.ver).catch(reject);
                }
                if (roster.iq.query.item !== undefined) {
                    const items = (Array.isArray(roster.iq.query.item)) ? roster.iq.query.item : [roster.iq.query.item];
                    const contacts = [];
                    items.forEach((item) => {
                        if (item.$attributes["jid"] !== undefined) {
                            const contact = {
                                id: item.$attributes["jid"],
                                subscription: item.$attributes["subscription"],
                                online: false
                            };
                            if (item.group !== undefined) {
                                if (typeof item.group === "string") {
                                    contact.groups = [item.group];
                                }
                                else if (Array.isArray(item.group)) {
                                    contact.groups = item.group;
                                }
                            }
                            contacts.push(contact);
                        }
                    });
                    // Get the local list of contacts
                    this._contactDb.allDocs({
                        "include_docs": true
                    }).then((docs) => {
                        const proms = [];
                        // Go through each of the current contacts and compare against the contacts from the server
                        docs.rows.forEach((row) => {
                            let cContact = row.doc;
                            let nContact = null;
                            contacts.every((contact, idx) => {
                                if (contact.id === cContact.id) {
                                    nContact = contact;
                                    // Remove the nContact from the contacts array so we know which ones are new
                                    delete contacts[idx];
                                    return false;
                                }
                                return true;
                            });
                            if (nContact === null) {
                                // Contact doesn't exist on the server anymore, so delete it locally
                                proms.push(this._contactDb.remove(cContact));
                                // If something has changed then merge the new contact into the current one
                            }
                            else if (cContact.subscription !== nContact.subscription || !CtXmppClient._arraysEqual(cContact.groups, nContact.groups)) {
                                // Server is the master, update properties changed on the server but don't remove local properties
                                cContact = CtXmppClient._merge(cContact, nContact);
                                this._log("MERGED CONTACT:", cContact);
                                // Save the updated contact to the database
                                proms.push(this._contactDb.post(cContact));
                            }
                        });
                        // Find out which contacts are left, these are new ones which need adding
                        contacts.forEach((contact) => {
                            this._log("ADDING NEW CONTACT:", contact);
                            proms.push(new es6_promise_1.Promise((resolve, reject) => {
                                this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, contact.id, (noContact) => {
                                    return contact;
                                }, (doc) => {
                                    this._log("CONTACT ADDED:", contact.id);
                                    resolve(doc);
                                }, (e) => {
                                    this._log("CONTACT ADD FAILED:" + contact.id + ": " + e);
                                    reject(e);
                                });
                            }));
                        });
                        es6_promise_1.Promise.all(proms).then(resolve).catch((error) => {
                            this._onError("Couldn't merge contacts from server with locally sorted contacts.", error);
                            reject(error);
                        });
                    });
                }
                else {
                    // Nothing in the roster to process so just resolve
                    resolve();
                }
            }
            else {
                // We could get an empty response because we are using roster versioning
                // An empty response means nothing has changed since we last requested the roster
                resolve();
            }
        });
    }
    /**
     * Fetch vCards for all contacts, storing them as 'vCard' on contacts object
     * @returns {Promise}
     */
    getvCardsForAllContacts() {
        this._isMethodReady(true, true);
        this._log(" Fetching all vCards...");
        return new es6_promise_1.Promise((resolve1, reject1) => {
            this.getContacts().then((contacts) => {
                const proms = [];
                contacts.forEach((contact, index) => {
                    this._log(" Fetching vCard for:", contact.id);
                    proms.push(new es6_promise_1.Promise((resolve2, reject2) => {
                        this.updatevCardForContact(contact.id).then(() => {
                            this._log(" Fetched vCard for:", contact.id);
                            resolve2();
                        }).catch((e) => {
                            // Ignore error - move on to next contact
                            resolve2();
                        });
                    }));
                });
                es6_promise_1.Promise.all(proms).then(resolve1).catch(reject1);
            });
        });
    }
    /**
     * Retrieves current user vCard as JSON
     * @returns {Promise}
     */
    getOurvCard() {
        this._isMethodReady(true, true);
        this._log(" Fetching vCard for:", this._bareJid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getvCard(this._bareJid).then((vCardStr) => {
                if (vCardStr === undefined || vCardStr.length < 1) {
                    return reject("No vCard");
                }
                const card = vcard_simple_1.VCardSimple.fromXml(vCardStr);
                if (card !== undefined) {
                    this._log(" Fetched vCard: ", card.toJSON());
                    resolve(card.toJSON());
                }
                else {
                    this._log(" Bad vCard: ", this._bareJid);
                    reject("Bad vCard");
                }
            }).catch(reject);
        });
    }
    /**
     * save a replacement vCard back to the server
     * @param cardJSON
     * @returns {Promise}
     */
    saveOurvCard(cardJSON) {
        this._isMethodReady(true, true);
        this._log(" Saving vCard for:", this._bareJid);
        return new es6_promise_1.Promise((resolve, reject) => {
            const card = vcard_simple_1.VCardSimple.fromJSON(cardJSON);
            this._setvCard(this._bareJid, card.toXML(true)).then(() => {
                this._log(" Saved vCard for:", this._bareJid);
                resolve();
            }).catch(reject);
        });
    }
    /**
     * Private method used to dispatch error events
     * @param errorDesc
     * @param errorObj
     * @private
     */
    _onError(errorDesc, errorObj) {
        console.error(errorDesc, errorObj || "");
        this._dispatchEvent(CtXmppClient.EVENT_TYPES.ERROR, errorObj);
    }
    /**
     * Private method used to set an item in the cache
     * @param id
     * @param value
     * @param secret
     * @returns {Promise}
     * @private
     */
    _setCacheItem(id, value, secret = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const save = () => {
                this._saveObject(CtXmppClient.OBJECT_TYPES.CACHE_ITEM, id, (item) => {
                    if (item.value === value)
                        return false;
                    item.value = value;
                    item.secret = (secret === true);
                    return item;
                }, (item) => {
                    const value = item.value;
                    if (item.secret === false) {
                        this._cache[id] = value;
                    }
                    resolve(item.value);
                }, (e) => {
                    // If the databases are being destoryed then we don't care so just resolve
                    // so we don't get any unwanted errors
                    if (e === CtXmppClient.ERROR_CODES.DESTROYING_DBS) {
                        resolve();
                    }
                    else {
                        this._onError(`Couldn't set cache item '${id}' with value '${value}'.`);
                        reject(e);
                    }
                });
            };
            // If the current value is the same we don't want to try and save it
            this._getCacheItem(id).then(currentValue => {
                if (currentValue === value) {
                    resolve(currentValue);
                }
                else {
                    save();
                }
            }).catch(save);
        });
    }
    /**
     * Private method used to get an item from the cache
     * @param id
     * @param attempts
     * @returns {Promise}
     * @private
     */
    _getCacheItem(id, attempts = 0) {
        const MAX_ATTEMPTS = 5;
        return new es6_promise_1.Promise((resolve) => {
            if (this._cache[id] !== undefined) {
                resolve(this._cache[id]);
            }
            else {
                this._cacheDb.get(id).then((item) => {
                    if (this._options.encryption && !item.hasOwnProperty("value")) {
                        // it is possible that the db isn't yet decripted - if this is the case, try again in 100ms
                        attempts = attempts + 1;
                        if (attempts === MAX_ATTEMPTS) {
                            // we've tried enough - bail with an undefined value
                            resolve();
                        }
                        else {
                            setTimeout(() => {
                                this._getCacheItem(id, attempts).then(resolve);
                            }, 100);
                        }
                    }
                    else {
                        const value = item.value;
                        if (item.secret === false) {
                            this._cache[id] = value;
                        }
                        resolve(value);
                    }
                }).catch(() => {
                    // Cache item doesn't exist, resolve nothing.
                    resolve();
                });
            }
        });
    }
    /**
     * Private method used to delete an item from the cache
     * @param id
     * @returns {Promise}
     * @private
     */
    _deleteCacheItem(id) {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._cacheDb.get(id).then((item) => {
                this._cacheDb.remove(item).then(() => {
                    delete this._cache[id];
                    resolve();
                }).catch(reject);
            }).catch(() => {
                // Cache item doesn't exist, resolve nothing.
                resolve();
            });
        });
    }
    _messageDelta(stanza, message, defaults) {
        const fullJid = stanza.message.$attributes.from;
        const senderId = index_1.default.Strophe.getBareJidFromJid(fullJid);
        const senderResource = index_1.default.Strophe.getResourceFromJid(fullJid);
        // Does the message already exist?
        if (message._id !== undefined) {
            // Yes, so update the bits which need updating
            if (stanza !== message.stanza) {
                message.stanza = stanza;
            }
            if (stanza.message.body !== undefined && stanza.message.body !== message.body) {
                message.body = stanza.message.body;
            }
            if (message.type === null) {
                message.type = stanza.message.$attributes.type;
            }
            if (message.type === "groupchat") {
                message.state.sent = true;
            }
            if (message.jid === null) {
                message.jid = fullJid;
            }
            if (message.sender_id === null) {
                message.sender_id = senderId;
            }
            if (message.sender_resource === null) {
                message.sender_resource = senderResource;
            }
            if (message.recipient_id === null) {
                message.recipient_id = stanza.message.$attributes.to;
            }
            if (stanza.message.data !== undefined && stanza.message.data !== message.data) {
                message.data = stanza.message.data;
            }
            if (message.ts === null || (stanza.message.timestamp && stanza.message.timestamp.length > 1)) {
                message.ts = this._getTimestampFromStanza(stanza);
            }
            if (message.mine === null) {
                message.mine = (senderId === this._bareJid);
            }
            message.placeholder = false;
            message.archive_id = this._getArchiveIdFromStanza(stanza);
            message.updated_at = this.getSyncedTimestamp(Date.now());
            message = CtXmppClient._merge(message, defaults);
        }
        else {
            // No, so create a new one        
            let attachments = [];
            if (stanza.message.attachments !== undefined) {
                if (!Array.isArray(stanza.message.attachments)) {
                    attachments.push(stanza.message.attachments);
                }
                else {
                    attachments = stanza.message.attachments;
                }
            }
            let messageSkeleton = {
                _id: stanza.message.$attributes.id,
                stanza: stanza,
                archive_id: this._getArchiveIdFromStanza(stanza),
                jid: fullJid,
                sender_id: senderId,
                sender_resource: senderResource,
                recipient_id: stanza.message.$attributes.to,
                body: stanza.message.body || null,
                updated_at: null,
                ts: this._getTimestampFromStanza(stanza),
                state: {
                    sent: null,
                    markers: [],
                    received: null,
                    read: null,
                    acknowledged: null
                },
                data: stanza.message.data || {},
                attachments: attachments,
                type: stanza.message.$attributes.type || "chat",
                mine: (senderId === this._bareJid),
                markable: (stanza.message.markable !== undefined),
                fromMam: false,
                injected: false,
                placeholder: false
            };
            let addresses = [];
            if (stanza.message.addresses !== undefined) {
                if (!Array.isArray(stanza.message.addresses.address)) {
                    addresses.push(stanza.message.addresses.address);
                }
                else {
                    addresses = stanza.message.addresses.address;
                }
            }
            message = Object.assign({}, CtXmppClient._messageSkeleton(), {
                _id: stanza.message.$attributes.id,
                stanza: stanza,
                archive_id: this._getArchiveIdFromStanza(stanza),
                jid: fullJid,
                sender_id: senderId,
                sender_resource: senderResource,
                recipient_id: stanza.message.$attributes.to,
                body: stanza.message.body,
                ts: this._getTimestampFromStanza(stanza),
                data: stanza.message.data,
                attachments: attachments,
                type: stanza.message.$attributes.type,
                mine: (senderId === this._bareJid),
                markable: (stanza.message.markable !== undefined),
                addresses: addresses
            });
        }
        if (stanza.message.$attributes && stanza.message.$attributes.type === "groupchat") {
            message.type = "groupchat";
            message.mine = (index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from) === this._bareJid || index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from) === this.username);
        }
        return CtXmppClient._merge(message, defaults);
    }
    static _messageSkeleton() {
        return {
            _id: null,
            stanza: null,
            archive_id: null,
            jid: null,
            sender_id: null,
            sender_resource: null,
            recipient_id: null,
            body: null,
            updated_at: null,
            ts: null,
            state: {
                sent: null,
                markers: [],
                received: null,
                read: null,
                acknowledged: null
            },
            data: {},
            attachments: [],
            type: "chat",
            mine: null,
            markable: false,
            fromMam: false,
            placeholder: false,
            injected: false
        };
    }
    /**
     * Convenience method used to convert an XMPP stanza to a message database object
     * @param stanza
     * @param defaults
     * @param persist
     * @returns {Promise}
     * @private
     */
    _messageStanzaToDbObject(stanza, defaults) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (stanza.message !== undefined && stanza.message.$attributes !== undefined) {
                this.saveMessage(stanza.message.$attributes.id, (message) => {
                    return this._messageDelta(stanza, message, defaults);
                }).then(resolve).catch((e) => {
                    this._onError("Unable to convert message stanza to DB object.", e);
                    reject(e);
                });
            }
            else {
                const msg = "No message part present in the stanza.";
                this._onError(msg);
                reject(msg);
            }
        });
    }
    _getTimestampFromStanza(stanza) {
        let ts = null;
        if (stanza.message !== undefined && stanza.message.timestamp !== undefined) {
            if (Array.isArray(stanza.message.timestamp)) {
                const timestamps = stanza.message.timestamp.filter((stanza) => {
                    return (stanza.$attributes !== undefined && stanza.$attributes.xmlns === CtXmppClient.NAMESPACES.CT_SERVER_TIMESTAMP);
                });
                if (timestamps[0] !== undefined) {
                    ts = parseInt(timestamps[0].$value);
                }
            }
            else if (stanza.message.timestamp.$value !== undefined) {
                ts = parseInt(stanza.message.timestamp.$value);
            }
        }
        if (ts === null) {
            ts = this.getSyncedTimestamp(Date.now());
        }
        return ts;
    }
    _getArchiveIdFromStanza(stanza) {
        let archiveId = null;
        if (stanza.message.archived !== undefined) {
            const archiveObj = (Array.isArray(stanza.message.archived)) ? stanza.message.archived[0] : stanza.message.archived;
            if (archiveObj.$attributes !== undefined && archiveObj.$attributes.id !== undefined) {
                archiveId = archiveObj.$attributes.id;
            }
        }
        return archiveId;
    }
    /**
     * Private method used to output debugging information to the console
     * @param detail
     * @param value
     * @private
     */
    _log(detail, value) {
        if (this._options.debug === true) {
            console.debug("[" + new Date().toString() + "] ", detail, value || "");
        }
    }
    /**
     * Method used to generate a unique GUID to be used as message IDs
     * @returns {string}
     */
    getUniqueId() {
        this._isMethodReady(true, true);
        return this._connection.getUniqueId(`${this._instanceId}-${performance.now()}`);
    }
    _clearBotTimeout(requestId) {
        if (this._botCommandTimeouts[requestId]) {
            this._log(`Bot command response verified, removing bot timeout for request '${requestId}'.`);
            this._botCommandTimeouts[requestId].cancel();
            delete this._botCommandTimeouts[requestId];
        }
    }
    _clearBotPromise(requestId) {
        if (!this._botCommandPromises[requestId])
            return;
        this._log(`Clearing bot command promise for request '${requestId}'.`);
        delete this._botCommandPromises[requestId];
    }
    _botCommandResponseHandler(requestId, stanza) {
        if (!this._botCommandPromises[requestId])
            return false;
        if (stanza.message !== undefined && stanza.message.$attributes !== undefined && stanza.message.$attributes.type === "error") {
            const _requestId = (stanza.message.error !== undefined && stanza.message.error.$attributes !== undefined && stanza.message.error.$attributes["request-id"]) ? stanza.message.error.$attributes["request-id"] : null;
            if (_requestId === requestId) {
                this._clearBotTimeout(_requestId);
                const errorMsg = (stanza.message.error !== undefined && stanza.message.error.text !== undefined) ? stanza.message.error.text.$value : "An unexpected error occurred";
                this._botCommandPromises[requestId].reject(errorMsg);
                this._clearBotPromise(requestId);
            }
        }
        else if (stanza.message !== undefined && stanza.message.call !== undefined && stanza.message.call.$attributes !== undefined && stanza.message.call.$attributes.type === "result" && stanza.message.call.$attributes["request-id"] === requestId) {
            this._clearBotTimeout(requestId);
            if (stanza.message.call.json !== undefined && stanza.message.call.json.$value !== undefined) {
                let json = null;
                try {
                    json = JSON.parse(stanza.message.call.json.$value);
                }
                catch (e) {
                    this._onError("Couldn't parse JSON from bot command response:", e);
                    this._botCommandPromises[requestId].reject(e);
                    this._clearBotPromise(requestId);
                }
                if (json !== null) {
                    this._botCommandPromises[requestId].resolve(json);
                    this._clearBotPromise(requestId);
                }
            }
            // We've got our response so we no longer need the handler
            return false;
        }
        // Not got our response yet so keep the handler open
        return true;
    }
    /**
     * Method used to send a command to a bot and retrieve the result
     * @param botJid {String}
     * @param operationName {String}
     * @param data {Object}
     * @param timeout {Number} - If we don't get a response in this time then assume its not worked and reject
     * @returns {Promise}
     */
    sendBotCommand(botJid, operationName, data, timeout = 5000) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            const requestId = this.getUniqueId();
            const stanza = {
                $attributes: {
                    to: botJid,
                    type: "normal"
                },
                call: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.INFINITY_BOT,
                        "request-id": requestId,
                        type: "get",
                        name: operationName
                    }
                }
            };
            let jsonString = null;
            try {
                jsonString = JSON.stringify(data);
            }
            catch (e) {
                this._onError("Couldn't stringify JSON:", e);
            }
            if (jsonString !== null) {
                stanza.call.json = {
                    $attributes: {
                        xmlns: "urn:xmpp:json:0"
                    },
                    $value: jsonString
                };
            }
            this._botCommandPromises[requestId] = {
                resolve: resolve,
                reject: reject
            };
            // Response handler defined in _onStanza so that responses get handled across disconnects
            this.sendStanza(stanza, false).then(() => {
                this._log(`Creating bot command timer for request '${requestId}'...`);
                this._botCommandTimeouts[requestId] = new timer_1.default(requestId, () => {
                    this._log(`Bot command timer finished for request '${requestId}'.`);
                    this._onError(`Didn't get a response from the bot within ${timeout}ms.`, {
                        operationName: operationName
                    });
                    this._botCommandPromises[requestId].reject("Your request took longer then expected, please try again.");
                }, timeout);
            }).catch(e => {
                this._onError("Couldn't send bot command:", e);
                reject(e);
            });
        });
    }
    _pushHandler(data) {
        this._log("Push Received: ", data);
    }
    /**
     * Method used to fetch a push token using the plugin
     * @returns {Promise<PushTokens>}
     * @private
     */
    _getPushTokens() {
        return new es6_promise_1.Promise((resolve, reject) => {
            const regularPush = function (voipToken = null) {
                const NotificationPlugin = Plugin.getSource("PushNotification");
                const oldNotificationPlugin = Plugin.getSource("notification");
                if (NotificationPlugin !== false) {
                    const config = {
                        android: {},
                        ios: {
                            "badge": "true",
                            "sound": "true",
                            "alert": "true"
                        }
                    };
                    this._log("Registering for push notifications...");
                    const that = this;
                    const push = NotificationPlugin.init(config);
                    push.on('registration', function (data) {
                        const token = data.registrationId;
                        that._log("Registered for push:", token);
                        that._setCacheItem("push_token", token).then(() => {
                            resolve({
                                voipToken: voipToken,
                                standardToken: token
                            });
                        });
                    });
                    push.on('notification', function (data) { that._pushHandler.call(that, data); });
                    push.on('error', function (error) {
                        that._log("Error registering for push:", error);
                        reject(error);
                    });
                }
                else if (oldNotificationPlugin !== false) {
                    let config = null;
                    if (environment_1.getPlatformName() === "android") {
                        config = {
                            "senderID": this._options.push.senderId
                        };
                    }
                    else if (environment_1.getPlatformName() === "ios") {
                        config = {
                            "badge": "true",
                            "sound": "true",
                            "alert": "true"
                        };
                    }
                    this._log("Registering for push notifications...");
                    const that = this;
                    oldNotificationPlugin.registerForPush(function (token) {
                        that._log("Registered for push:", token);
                        // Listen for push notifications incoming
                        oldNotificationPlugin.on("pushReceived", function (data) {
                            that._pushHandler(data);
                            if (that._options.push.reLoginOnPushAndroid) {
                                if (!that.connected)
                                    that.reLoginNow();
                            }
                        });
                        // Set the token in the model so it can be used later in the app
                        that._setCacheItem("push_token", token).then(() => {
                            resolve({
                                voipToken: voipToken,
                                standardToken: token
                            });
                        });
                    }, function (error) {
                        that._log("Error registering for push:", error);
                        reject(error);
                    }, config);
                }
                else {
                    this._log("Could not find Push plugin");
                    reject("Could not find Push plugin");
                }
            };
            if (this._options.push.voip && environment_1.getPlatformName() === "ios") {
                const that = this;
                const voipPushPlugin = Plugin.getSource("VoIPPushNotification");
                if (voipPushPlugin !== false) {
                    const voipPush = voipPushPlugin.init();
                    voipPush.on("registration", function (data) {
                        that._log("Registered for push: ", data.deviceToken);
                        that._setCacheItem("push_token", data.deviceToken).then(() => {
                            // We also need to get the regular push token, so do that next
                            regularPush.call(that, data.deviceToken);
                        });
                    });
                    voipPush.on("notification", function (data) {
                        that._pushHandler(data);
                        if (that._options.push.reLoginOnPushiOS) {
                            if (!that.connected)
                                that.reLoginNow();
                        }
                    });
                    voipPush.on("error", function (e) {
                        that._log("VOIP Push Error: " + e);
                    });
                }
                else {
                    this._log("Could not find VOIP Push plugin");
                    reject("Could not find VOIP Push plugin");
                }
            }
            else {
                // We still need to get the regular push token even if we are not doing VOIP
                regularPush.call(this);
            }
        });
    }
    /**
     * Method to contact the server to register for push notifications
     * @returns {Promise}
     * @private
     */
    registerForPush(tokens) {
        if (!environment_1.isDevice())
            throw new Error("This platform does not support push notifications.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const notificationData = {
                package: this._options.push.packageId,
                type: (environment_1.getPlatformName() === "ios") ? "apns" : "gcm",
                token: tokens.standardToken,
                installation_id: this._installId
            };
            if (tokens.voipToken) {
                notificationData.voip_token = tokens.voipToken;
            }
            this.sendIq(null, "set", {
                push: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CT_PUSH
                    },
                    notification: notificationData
                }
            }).then((result) => {
                let pushJid = null;
                try {
                    pushJid = result.iq.push.notification.$attributes.jid;
                    this._pushNodeName = result.iq.push.notification.$attributes.node;
                }
                catch (e) {
                    this._onError("Couldn't enable push notifications.", e);
                    reject(e);
                }
                if (pushJid !== null) {
                    this._setCacheItem("push_jid", pushJid).then(() => {
                        this.enablePush().then(resolve).catch(reject);
                    });
                }
            }).catch(e => {
                this._onError("Couldn't register for push notifications:", e);
                reject(e);
            });
        });
    }
    /**
     * Method to contact the server to enable push notifications
     * @returns {Promise}
     * @private
     */
    enablePush() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getCacheItem("push_jid").then((pushJid) => {
                if (pushJid !== undefined) {
                    this.sendIq(null, "set", {
                        enable: {
                            $attributes: {
                                xmlns: CtXmppClient.NAMESPACES.PUSH,
                                jid: pushJid,
                                node: this._pushNodeName
                            }
                        }
                    }).then(resolve).catch(e => {
                        this._onError("Unable to enable push notifications:", e);
                        reject(e);
                    });
                }
                else {
                    this._onError("'registerForPush' must be called before 'enablePush'.");
                    reject();
                }
            });
        });
    }
    /**
     * Method to contact the server to disable push notifications
     * @returns {Promise}
     * @private
     */
    disablePush() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getCacheItem("push_jid").then((pushJid) => {
                if (pushJid !== undefined) {
                    this.sendIq(null, "set", {
                        disable: {
                            $attributes: {
                                xmlns: CtXmppClient.NAMESPACES.PUSH,
                                jid: pushJid,
                                node: this._pushNodeName
                            }
                        }
                    }).then(resolve).catch(e => {
                        this._onError("Unable to disable push notifications:", e);
                        reject(e);
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    /** Performance related logging methods **/
    _perfStart(key, msg, style) {
        if (this._options.perfLogging !== true)
            return;
        console.log(`%c[START: ${key}] ${msg}`, style);
        console.time(key);
    }
    _perfEnd(key, msg, style) {
        if (this._options.perfLogging !== true)
            return;
        console.log(`%c[END: ${key}] ${msg}`, style);
        console.timeEnd(key);
    }
    /**
     * Static method used to convert JSON stanza to XML stanzas
     * @param type
     * @param json
     * @returns {any}
     */
    static jsonToXml(type, json) {
        return CtXmppClient._parseJsonNode(json, CtXmppClient._createElement(type, json.$attributes));
    }
    static _parseJsonNode(json, $parent) {
        for (let key in json) {
            let value = json[key];
            if (key.indexOf("$") !== 0) {
                if (Array.isArray(value) && value.length > 0) {
                    value.forEach((item) => {
                        let $item;
                        if (typeof item === "string") {
                            $item = CtXmppClient._createElement(key, {});
                            $item.textContent = item;
                        }
                        else {
                            $item = CtXmppClient._createElement(key, item.$attributes);
                            $item = CtXmppClient._parseJsonNode(item, $item);
                        }
                        $parent.appendChild($item);
                    });
                }
                else {
                    const $attrs = (typeof value === "object" && value !== null) ? value.$attributes : undefined;
                    let $element = CtXmppClient._createElement(key, $attrs);
                    if (typeof value === "object" && value !== null && Object.keys(value).length > 0) {
                        $element = CtXmppClient._parseJsonNode(value, $element);
                    }
                    else if (typeof value === "string") {
                        const $txt = CtXmppClient.doc.createTextNode(value);
                        $element.appendChild($txt);
                    }
                    $parent.appendChild($element);
                }
            }
            else if (key === "$value") {
                const $txt = CtXmppClient.doc.createTextNode(value);
                $parent.appendChild($txt);
            }
            else if (key === "$cdata") {
                const $cdata = CtXmppClient.doc.createCDATASection(value);
                $parent.appendChild($cdata);
            }
        }
        return $parent;
    }
    static xmlToJson($xml) {
        return CtXmppClient._parseXmlNode($xml, {});
    }
    static _parseXmlNode($xml, obj) {
        let _node = {};
        if ($xml.attributes !== undefined && $xml.attributes.length > 0) {
            _node.$attributes = {};
            for (let i = 0; i < $xml.attributes.length; i++) {
                const attr = $xml.attributes[i];
                _node.$attributes[attr.nodeName] = attr.value;
            }
        }
        if ($xml.childNodes.length > 0) {
            for (let j = 0; j < $xml.childNodes.length; j++) {
                const $child = $xml.childNodes[j];
                if ($child.nodeType === 3) {
                    if (_node.$attributes !== undefined) {
                        _node.$value = $child.textContent;
                    }
                    else {
                        _node = $child.textContent;
                    }
                }
                else if ($child.nodeType === 4) {
                    _node.$cdata = $child.textContent;
                }
                else {
                    // vCards come littered with textnodes that are just newlines.
                    // This causes some problems and they aren't useful.
                    if (_node === "\n") {
                        continue;
                    }
                    CtXmppClient._parseXmlNode($child, _node);
                }
            }
        }
        if (obj[$xml.nodeName] !== undefined && Array.isArray(obj[$xml.nodeName]) === false) {
            obj[$xml.nodeName] = [obj[$xml.nodeName]];
        }
        if (Array.isArray(obj[$xml.nodeName])) {
            obj[$xml.nodeName].push(_node);
        }
        else {
            obj[$xml.nodeName] = _node;
        }
        return obj;
    }
    static _createElement(name, attributes) {
        if (CtXmppClient.doc === null) {
            CtXmppClient.doc = document.implementation.createDocument('ct:xmpp:client', 'infinity', null);
        }
        const $element = CtXmppClient.doc.createElement(name);
        if (attributes !== undefined && Object.keys(attributes).length > 0) {
            for (let attr in attributes) {
                $element.setAttribute(attr, attributes[attr]);
            }
        }
        return $element;
    }
    static _getContactFromRosterByJid(jid, roster) {
        let result = null;
        if (roster !== undefined && roster.contacts !== undefined && roster.contacts.length > 0) {
            roster.contacts.forEach((contact) => {
                if (contact.jid === jid) {
                    result = contact;
                }
            });
        }
        return result;
    }
    static _isObject(item) {
        return (item && typeof item === 'object' && !Array.isArray(item));
    }
    static _merge(target, ...sources) {
        if (!sources.length)
            return target;
        const source = sources.shift();
        if (CtXmppClient._isObject(target) && CtXmppClient._isObject(source)) {
            for (const key in source) {
                if (CtXmppClient._isObject(source[key])) {
                    if (!target[key])
                        Object.assign(target, { [key]: {} });
                    CtXmppClient._merge(target[key], source[key]);
                }
                else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return CtXmppClient._merge(target, ...sources);
    }
    static _arraysEqual(arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
            return (arr1 === arr2);
        }
        if (arr1.length !== arr2.length)
            return false;
        for (let i = arr1.length; i--;) {
            if (arr1[i] !== arr2[i])
                return false;
        }
        return true;
    }
    /**
     * Static method used to validate a user provided event type against the constants
     * @param type
     * @returns {boolean}
     * @private
     */
    static _validateEventType(type) {
        return CtXmppClient._validateConstants(CtXmppClient.EVENT_TYPES, type);
    }
    /**
     * Static method used to validate a user provided chat status against the constants
     * @param type
     * @returns {boolean}
     * @private
     */
    static _validateChatStatus(type) {
        return CtXmppClient._validateConstants(CtXmppClient.CHAT_STATUSES, type);
    }
    ;
    /**
     * Static method used to validate against a set of constants
     * @param type
     * @returns {boolean}
     * @private
     */
    static _validateConstants(constants, value) {
        for (let t in constants) {
            if (constants[t] === value) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Static method to get the domain from the provided JID
     * @param jid
     * @private
     */
    static getDomainFromJid(jid) {
        const bare = index_1.default.Strophe.getBareJidFromJid(jid);
        return bare.split("@")[1];
    }
    static _isMarkerMessage(stanza) {
        return (stanza.message.received && stanza.message.received.$attributes && stanza.message.received.$attributes.xmlns === CtXmppClient.NAMESPACES.CHAT_MARKERS)
            || (stanza.message.read && stanza.message.read.$attributes && stanza.message.read.$attributes.xmlns === CtXmppClient.NAMESPACES.CHAT_MARKERS)
            || (stanza.message.acknowledged && stanza.message.acknowledged.$attributes && stanza.message.acknowledged.$attributes.xmlns === CtXmppClient.NAMESPACES.CHAT_MARKERS);
    }
    static getNodeFromJid(jid) {
        return index_1.default.Strophe.getNodeFromJid(jid);
    }
    /**
     *
     * @param options
     *
     * contain one of:
     *
     * mediaType: (MEDIA_TYPES)
     * or
     * mimeTypes: [array of mime types]
     *
     * If neither is supplied, then all file types are assumed
     *
     * @returns {Promise}
     */
    static pickFile(options = {}) {
        return File.pickFile(options);
    }
    _isMethodReady(initialisationRequired = true, connectionRequired = false) {
        if (initialisationRequired === true && this._initialised !== true)
            throw new Error(`XMPP client has not yet been fully initialised.`);
        if (connectionRequired === true && this.connected === false)
            throw new Error(`An active connection is required to perform this action.`);
    }
    static isInBackground() {
        return utils_1.isInBackground();
    }
}
CtXmppClient.doc = null;
CtXmppClient.MARKER_TYPES = {
    "RECEIVED": "received",
    "READ": "read",
    "ACKNOWLEDGED": "acknowledged"
};
CtXmppClient.EVENT_TYPES = {
    "INITIALISED": "initialised",
    "STATUS": "status",
    "NEW_MESSAGE": "newmessage",
    "ERROR": "error",
    "MESSAGE_UPDATED": "messageupdated",
    "PRESENCE_UPDATE": "presenceupdate",
    "NEW_PARTICIPANT": "newparticipant",
    "PARTICIPANT_UPDATED": "participantupdated",
    "RECEIPT_RECEIVED": "receiptreceived",
    "AUTO_RECONNECTED": "autoreconnected",
    "DBS_DESTROYED": "dbsdestroyed",
    "AUTO_DBS_DESTROYED": "autodbsdestroyed",
    "ACK_RECEIVED": "ackreceived",
    "UPLOAD_STARTED": "uploadstarted",
    "UPLOAD_SUCCESS": "uploadsuccess",
    "UPLOAD_FAILED": "uploadfailed"
};
CtXmppClient.CHAT_STATUSES = {
    "AWAY": "away",
    "CHAT": "chat",
    "DND": "dnd",
    "XA": "xa"
};
CtXmppClient.NAMESPACES = {
    "MUC": "http://jabber.org/protocol/muc",
    "MUC_SUB": "urn:xmpp:mucsub:0",
    "MUC_OWNER": "http://jabber.org/protocol/muc#owner",
    "X_DATA": "jabber:x:data",
    "DISCO_INFO": "http://jabber.org/protocol/disco#info",
    "DISCO_ITEMS": "http://jabber.org/protocol/disco#items",
    "JABBER_CLIENT": "jabber:client",
    "MAM": "urn:xmpp:mam:0",
    "MAM_TMP": "urn:xmpp:mam:tmp",
    "RESULT_SET_MANAGEMENT": "http://jabber.org/protocol/rsm",
    "CHAT_MARKERS": "urn:xmpp:chat-markers:0",
    "CT_METADATA": "ct:metadata:0",
    "HINTS": "urn:xmpp:hints",
    "CT_CLIENT_TIMESTAMP": "ct:client-timestamp:0",
    "CT_SERVER_TIMESTAMP": "urn:commontime:infinity:timestamps",
    "HTTP_UPLOAD": "urn:xmpp:http:upload",
    "PING": "urn:xmpp:ping",
    "CLIENT_STATE_INDICATION": "urn:xmpp:csi:0",
    "ADDRESS": "http://jabber.org/protocol/address",
    "VCARD_UPDATE": "vcard-temp:x:update",
    "TIME": "urn:xmpp:time",
    "INFINITY_BOT": "urn:commontime:infinity:api",
    "PRIVATE_XML_STORAGE": "jabber:iq:private",
    "CT_PRIVATE_XML_STORAGE": "ct:private-xml-data",
    "CT_PUSH": "urn:commontime:infinity:push",
    "PUSH": "urn:xmpp:push:0",
    "DIRECTORY": "urn:commontime:infinity:directory",
    "CARBONS": "urn:xmpp:carbons:2",
    "INFINITY_MAM": "urn:commontime:infinity:mam",
    "INFINITY_ACK": "urn:commontime:infinity:ack",
    "SOFTWARE_VERSION": "jabber:iq:version"
};
CtXmppClient.MUC_NODES = {
    "PRESENCE": "urn:xmpp:mucsub:nodes:presence",
    "MESSAGES": "urn:xmpp:mucsub:nodes:messages",
    "AFFILIATIONS": "urn:xmpp:mucsub:nodes:affiliations",
    "CONFIG": "urn:xmpp:mucsub:nodes:config",
    "SUBJECT": "urn:xmpp:mucsub:nodes:subject",
    "SYSTEM": "urn:xmpp:mucsub:nodes:system"
};
CtXmppClient.MARKER_PRIORITIES = {
    "received": 3,
    "read": 2,
    "acknowledged": 1
};
CtXmppClient.OBJECT_TYPES = {
    "MESSAGE": "message",
    "CONTACT": "contact",
    "ROOM": "room",
    "PARTICIPANT": "participant",
    "CACHE_ITEM": "cache_item",
    "OBJECT_URL": "object_url"
};
CtXmppClient.CLIENT_STATES = {
    "ACTIVE": "active",
    "INACTIVE": "inactive"
};
CtXmppClient.ERROR_CODES = {
    "DESTROYING_DBS": "destroying_dbs"
};
exports.CtXmppClient = CtXmppClient;
window.CtXmppClient = CtXmppClient;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 19/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
const cWindow = window;
const eWindow = window;
function getSource(pluginName) {
    if (cWindow[pluginName] !== undefined) {
        return cWindow[pluginName];
    }
    else if (cWindow.cordova !== undefined && cWindow.cordova[pluginName] !== undefined) {
        return cWindow.cordova[pluginName];
    }
    else if (cWindow.cordova !== undefined && cWindow.cordova.plugins !== undefined && cWindow.cordova.plugins[pluginName] !== undefined) {
        return cWindow.cordova.plugins[pluginName];
    }
    else if (cWindow.plugins !== undefined && cWindow.plugins[pluginName] !== undefined) {
        return cWindow.plugins[pluginName];
    }
    else if (navigator !== undefined && navigator[pluginName] !== undefined) {
        return navigator[pluginName];
    }
    else if (eWindow.require !== undefined) {
        let plugin = false;
        try {
            plugin = eWindow.require(pluginName);
            return plugin;
        }
        catch (err) {
            if (plugin === false || plugin === undefined) {
                const fixedName = pluginName.replace(/\-/g, "").toLowerCase();
                try {
                    return eWindow.require("@commontimeltd/com.commontime." + fixedName);
                }
                catch (err) {
                    return false;
                }
            }
            return false;
        }
    }
    else {
        console.warn(`Plugin '${pluginName}' is not available.`);
        return false;
    }
}
exports.getSource = getSource;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
class BaseEventArgs {
    constructor() {
        this.eventDate = new Date().getTime();
    }
}
exports.BaseEventArgs = BaseEventArgs;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = skate;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var IQError_1 = __webpack_require__(81);
exports.IQError = IQError_1.IQError;
var NotConnectedError_1 = __webpack_require__(82);
exports.NotConnectedError = NotConnectedError_1.NotConnectedError;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
class UserLookup {
    constructor(layer) {
        if (!layer)
            throw new Error("Chat Layer Component Interface not supplied");
        this._layer = layer;
        this._users = new Map();
    }
    populate(conversations = [], chatEntries = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const newJids = new Set();
            if (conversations) {
                conversations.forEach(conversation => this._addFromConversation(conversation, newJids));
            }
            if (chatEntries) {
                chatEntries.forEach((chatEntry) => __awaiter(this, void 0, void 0, function* () { return this._addFromChatEntry(chatEntry, newJids); }));
            }
            const promises = Array.from(newJids.keys()).map(jid => this._processJid(jid));
            yield Promise.all(promises);
            return newJids.size > 0;
        });
    }
    getJids() {
        return [...this._users.keys()];
    }
    hasJid(jid) {
        return this._users.has(jid);
    }
    get(jid) {
        if (!jid)
            return null;
        const lowerJid = jid.toLowerCase();
        return this._users.get(lowerJid) || null;
    }
    // === Private functions === //
    _addFromConversation(conversation, jids) {
        return __awaiter(this, void 0, void 0, function* () {
            if (conversation.participants && conversation.participants.length) {
                conversation.participants.forEach(participant => this._addIfNew(participant.jid, jids));
            }
            if (conversation.preview)
                this._addFromChatEntry(conversation.preview, jids);
        });
    }
    _addFromChatEntry(chatEntry, jids) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (chatEntry.type) {
                case models_1.ChatEntryType.Chat:
                    const chatMessage = chatEntry;
                    this._addIfNew(chatMessage.from, jids);
                    break;
                case models_1.ChatEntryType.Meta:
                    const chatMetaActivity = chatEntry;
                    this._addIfNew(chatMetaActivity.instigator, jids);
                    this._addIfNew(chatMetaActivity.subject, jids);
                    break;
            }
        });
    }
    _processJid(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!jid)
                return;
            const lowerJid = jid.toLowerCase();
            if (this._users.has(lowerJid))
                return;
            const user = yield this._layer.getUserByJid(lowerJid);
            this._users.set(lowerJid, user || createFakeUserDetails(lowerJid));
        });
    }
    _addIfNew(jid, jids) {
        if (!jid)
            return;
        const lowerJid = jid.toLowerCase();
        if (!this.hasJid(lowerJid))
            jids.add(lowerJid);
    }
}
exports.UserLookup = UserLookup;
function createFakeUserDetails(jid) {
    return {
        id: jid,
        jid: jid,
        username: jid.split("@")[0],
        connectionStatus: models_1.ConnectionStatus.Disconnected,
        displayName: jid
    };
}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const plugin_1 = __webpack_require__(22);
// tslint:disable no-any
function getThumbnail(src, maxWidth, maxHeight, quality) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const thumbnail = plugin_1.getSource("thumbnail");
            if (!thumbnail) {
                return;
            }
            thumbnail.makeThumbnail((data) => {
                resolve(data);
            }, (err) => {
                reject(`Could not create thumbnail of image. ${err}`);
            }, src, maxWidth, maxHeight, quality);
        });
    });
}
exports.getThumbnail = getThumbnail;
// tslint:enable no-any


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.inherits = inherits;
function inherits(parent, child) {
	var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var extended = Object.create(parent.prototype);
	for (var p in props) {
		extended[p] = props[p];
	}
	extended.constructor = child;
	child.prototype = extended;
	return child;
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const Models_1 = __webpack_require__(5);
const components_1 = __webpack_require__(3);
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ONLINE"] = "Online"] = "ONLINE";
    I18nKeys[I18nKeys["OFFLINE"] = "Offline"] = "OFFLINE";
    I18nKeys[I18nKeys["RECONNECTING"] = "Reconnecting"] = "RECONNECTING";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLHeaderMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLHeader, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLHeaderMetadata._instance = null;
exports.CTCLHeaderMetadata = CTCLHeaderMetadata;
class CTCLHeader extends Base_1.CTCLComponent {
    constructor() {
        super();
        this.setMetadata(CTCLHeaderMetadata.instance);
    }
    static get is() {
        return "ct-cl-header";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener(() => {
            clearTimeout(this._reconnectTimeout);
        });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;font-size:1em}:host .header{position:relative;display:flex;align-items:center;height:var(--header-height, 75px);padding:0 20px;background:var(--header-bg, #22b1c8);color:var(--header-text, #fff)}:host .header .left-action{flex:0 0 20px}:host .header .details{flex:1 1 auto;position:relative;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;text-align:center;transition:padding 0.3s ease-out;overflow:hidden}:host .header .details .heading{font-size:1.5em}:host .header .details .sub-heading{font-weight:100}:host .header .details .status{position:absolute;bottom:0;left:50%;transform:translate(-50%, 100%);display:flex;justify-content:center;align-items:center;font-size:.833em;padding:3px 10px;border:1px solid rgba(255,255,255,0.5);border-bottom:0;border-radius:10px 10px 0 0;will-change:transform;transition:transform 0.3s ease-out}:host .header .details .status .icon{margin:0 0 0 5px}:host .header .right-action{flex:0 0 20px}:host .header.offline .details{padding:0 0 20px 0}:host .header.offline .details .status{transform:translate(-50%, 0);cursor:pointer}:host .header.offline .details .status:hover{background:rgba(255,255,255,0.1)}:host .header.disconnecting .details .status,:host .header.connecting .details .status{opacity:0.5;cursor:default}
        `;
    }
    generateComponentMarkup() {
        const cssClasses = [
            "header",
            ...this._getConnectionStatusCssClasses()
        ];
        const headerStyle = renderUtils_1.buildStyles({
            backgroundColor: this.backgroundColor
        });
        return (window.__CTRender("div", { class: cssClasses.join(" "), style: headerStyle },
            window.__CTRender("div", { class: "left-action" },
                window.__CTRender("slot", { name: "left-action" })),
            window.__CTRender("div", { class: "details" },
                window.__CTRender("div", { class: "heading" },
                    window.__CTRender("slot", { name: "heading" })),
                window.__CTRender("div", { class: "sub-heading" },
                    window.__CTRender("slot", { name: "sub-heading" })),
                window.__CTRender("div", { class: "status", onClick: this._onClickReconnectNow.bind(this) },
                    window.__CTRender("div", { class: "label" }, this._getConnectionStatusLabel()),
                    window.__CTRender(components_1.CTIcon, { class: "icon", width: "10", height: "10", icon: Models_1.Icons.UI.Reconnect, spin: this.connectionStatus === models_1.ConnectionStatus.Connecting }))),
            window.__CTRender("div", { class: "right-action" },
                window.__CTRender("slot", { name: "right-action" }))));
    }
    // === Event handlers === //
    _onClickReconnectNow() {
        if (this.connectionStatus === models_1.ConnectionStatus.Disconnected) {
            this.connectionStatus = models_1.ConnectionStatus.Connecting;
            clearTimeout(this._reconnectTimeout);
            this._reconnectTimeout = setTimeout(() => {
                this.layer.attemptReconnect();
            }, 500);
        }
    }
    // === Private functions === //
    _getConnectionStatusCssClasses() {
        switch (this.connectionStatus) {
            case models_1.ConnectionStatus.Disconnected:
                return ["offline disconnected"];
            case models_1.ConnectionStatus.Disconnecting:
                return ["offline disconnecting"];
            case models_1.ConnectionStatus.Connecting:
                return ["offline connecting"];
            case models_1.ConnectionStatus.Connected:
                return ["online connected"];
        }
    }
    _getConnectionStatusLabel() {
        switch (this.connectionStatus) {
            case models_1.ConnectionStatus.Connected:
                return this.translateI18nItem(I18nKeys.ONLINE);
            case models_1.ConnectionStatus.Connecting:
            case models_1.ConnectionStatus.Disconnecting:
            case models_1.ConnectionStatus.Disconnected:
                return this.translateI18nItem(I18nKeys.OFFLINE);
        }
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: null })
], CTCLHeader.prototype, "backgroundColor", void 0);
exports.CTCLHeader = CTCLHeader;
CTCLHeader.register();


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Created by Leon.Revill on 19/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
// TODO: Fix linting issues
const es6_promise_1 = __webpack_require__(64);
const Environment = __webpack_require__(43);
const Plugin = __webpack_require__(22);
const eWindow = window;
const cWindow = window;
let FileTransfer = null;
const ATTACHMENTS_DIR = "attachments";
const MEDIA_TYPES = {
    IMAGE: "image",
    AUDIO: "audio",
    VIDEO: "video"
};
const MIME_TYPE_MAP = {
    "a": { mimeType: "application/octet-stream", mediaType: null },
    "ai": { mimeType: "application/postscript", mediaType: null },
    "aif": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
    "aifc": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
    "aiff": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
    "au": { mimeType: "audio/basic", mediaType: MEDIA_TYPES.AUDIO },
    "avi": { mimeType: "video/x-msvideo", mediaType: null },
    "bat": { mimeType: "text/plain", mediaType: null },
    "bin": { mimeType: "application/octet-stream", mediaType: null },
    "bmp": { mimeType: "image/x-ms-bmp", mediaType: MEDIA_TYPES.IMAGE },
    "c": { mimeType: "text/plain", mediaType: null },
    "cdf": { mimeType: "application/x-cdf", mediaType: null },
    "csh": { mimeType: "application/x-csh", mediaType: null },
    "css": { mimeType: "text/css", mediaType: null },
    "dll": { mimeType: "application/octet-stream", mediaType: null },
    "doc": { mimeType: "application/msword", mediaType: null },
    "docm": { mimeType: "application/vnd.ms-word.document.macroEnabled.12", mediaType: null },
    "docx": { mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", mediaType: null },
    "dot": { mimeType: "application/msword", mediaType: null },
    "dotx": { mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.template", mediaType: null },
    "dvi": { mimeType: "application/x-dvi", mediaType: null },
    "eml": { mimeType: "message/rfc822", mediaType: null },
    "eps": { mimeType: "application/postscript", mediaType: null },
    "etx": { mimeType: "text/x-setext", mediaType: null },
    "exe": { mimeType: "application/octet-stream", mediaType: null },
    "gif": { mimeType: "image/gif", mediaType: MEDIA_TYPES.IMAGE },
    "gtar": { mimeType: "application/x-gtar", mediaType: null },
    "h": { mimeType: "text/plain", mediaType: null },
    "hdf": { mimeType: "application/x-hdf", mediaType: null },
    "htm": { mimeType: "text/html", mediaType: null },
    "html": { mimeType: "text/html", mediaType: null },
    "jpe": { mimeType: "image/jpe", mediaType: MEDIA_TYPES.IMAGE },
    "jpeg": { mimeType: "image/jpeg", mediaType: MEDIA_TYPES.IMAGE },
    "jpg": { mimeType: "image/jpeg", mediaType: MEDIA_TYPES.IMAGE, preferred: true },
    "js": { mimeType: "application/javascript", mediaType: null },
    "json": { mimeType: "application/json", mediaType: null },
    "ksh": { mimeType: "text/plain", mediaType: null },
    "latex": { mimeType: "application/x-latex", mediaType: null },
    "m1v": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "m4a": { mimeType: "audio/mpeg", mediaType: MEDIA_TYPES.AUDIO, preferred: true },
    "man": { mimeType: "application/x-troff-man", mediaType: null },
    "me": { mimeType: "application/x-troff-me", mediaType: null },
    "mht": { mimeType: "message/rfc822", mediaType: null },
    "mhtml": { mimeType: "message/rfc822", mediaType: null },
    "mif": { mimeType: "application/x-mif", mediaType: null },
    "mov": { mimeType: "video/quicktime", mediaType: MEDIA_TYPES.VIDEO },
    "movie": { mimeType: "video/x-sgi-movie", mediaType: MEDIA_TYPES.VIDEO },
    "mp2": { mimeType: "audio/mpeg", mediaType: MEDIA_TYPES.AUDIO },
    "mp3": { mimeType: "audio/mp3", mediaType: MEDIA_TYPES.AUDIO },
    "mp4": { mimeType: "video/mp4", mediaType: MEDIA_TYPES.VIDEO },
    "mpa": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "mpe": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "mpeg": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "mpg": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO, preferred: true },
    "ms": { mimeType: "application/x-troff-ms", mediaType: null },
    "nc": { mimeType: "application/x-netcdf", mediaType: null },
    "nws": { mimeType: "message/rfc822", mediaType: null },
    "o": { mimeType: "application/octet-stream", mediaType: null },
    "obj": { mimeType: "application/octet-stream", mediaType: null },
    "oda": { mimeType: "application/oda", mediaType: null },
    "otf": { mimeType: "application/x-font-opentype", mediaType: null },
    "pbm": { mimeType: "image/x-portable-bitmap", mediaType: MEDIA_TYPES.IMAGE },
    "pdf": { mimeType: "application/pdf", mediaType: null },
    "pfx": { mimeType: "application/x-pkcs12", mediaType: null },
    "pgm": { mimeType: "image/x-portable-graymap", mediaType: MEDIA_TYPES.IMAGE },
    "png": { mimeType: "image/png", mediaType: MEDIA_TYPES.IMAGE },
    "pnm": { mimeType: "image/x-portable-anymap", mediaType: MEDIA_TYPES.IMAGE },
    "po": { mimeType: "text/x-gettext-translation", mediaType: null },
    "pot": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "ppa": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "ppm": { mimeType: "image/x-portable-pixmap", mediaType: MEDIA_TYPES.IMAGE },
    "pps": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "ppt": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "pptm": { mimeType: "application/vnd.ms-powerpoint.presentation.macroEnabled.12", mediaType: null },
    "pptx": { mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation", mediaType: null },
    "ps": { mimeType: "application/postscript", mediaType: null },
    "pwz": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "py": { mimeType: "text/x-python", mediaType: null },
    "pyc": { mimeType: "application/x-python-code", mediaType: null },
    "pyo": { mimeType: "application/x-python-code", mediaType: null },
    "qt": { mimeType: "video/quicktime", mediaType: MEDIA_TYPES.VIDEO },
    "ra": { mimeType: "audio/x-pn-realaudio", mediaType: MEDIA_TYPES.AUDIO },
    "ram": { mimeType: "application/x-pn-realaudio", mediaType: MEDIA_TYPES.AUDIO },
    "ras": { mimeType: "image/x-cmu-raster", mediaType: MEDIA_TYPES.IMAGE },
    "rdf": { mimeType: "application/xml", mediaType: null },
    "rgb": { mimeType: "image/x-rgb", mediaType: MEDIA_TYPES.IMAGE },
    "roff": { mimeType: "application/x-troff", mediaType: null },
    "rtx": { mimeType: "text/richtext", mediaType: null },
    "sgm": { mimeType: "text/x-sgml", mediaType: null },
    "sgml": { mimeType: "text/x-sgml", mediaType: null },
    "sh": { mimeType: "application/x-sh", mediaType: null },
    "shar": { mimeType: "application/x-shar", mediaType: null },
    "snd": { mimeType: "audio/basic", mediaType: MEDIA_TYPES.AUDIO },
    "so": { mimeType: "application/octet-stream", mediaType: null },
    "src": { mimeType: "application/x-wais-source", mediaType: null },
    "svg": { mimeType: "image/svg+xml", mediaType: MEDIA_TYPES.IMAGE },
    "swf": { mimeType: "application/x-shockwave-flash", mediaType: null },
    "t": { mimeType: "application/x-troff", mediaType: null },
    "tar": { mimeType: "application/x-tar", mediaType: null },
    "tcl": { mimeType: "application/x-tcl", mediaType: null },
    "tex": { mimeType: "application/x-tex", mediaType: null },
    "texi": { mimeType: "application/x-texinfo", mediaType: null },
    "texinfo": { mimeType: "application/x-texinfo", mediaType: null },
    "tif": { mimeType: "image/tiff", mediaType: MEDIA_TYPES.IMAGE },
    "tiff": { mimeType: "image/tiff", mediaType: MEDIA_TYPES.IMAGE },
    "tr": { mimeType: "application/x-troff", mediaType: null },
    "tsv": { mimeType: "text/tab-separated-values", mediaType: null },
    "ttf": { mimeType: "application/x-font-truetype", mediaType: null },
    "txt": { mimeType: "text/plain", mediaType: null, preferred: true },
    "ustar": { mimeType: "application/x-ustar", mediaType: null },
    "vcf": { mimeType: "text/x-vcard", mediaType: null },
    "wav": { mimeType: "audio/x-wav", mediaType: MEDIA_TYPES.AUDIO },
    "woff": { mimeType: "application/font-woff", mediaType: null, preferred: true },
    "woff2": { mimeType: "application/font-woff", mediaType: null },
    "wsdl": { mimeType: "application/xml", mediaType: null },
    "xbm": { mimeType: "image/x-xbitmap", mediaType: MEDIA_TYPES.IMAGE },
    "xlb": { mimeType: "application/vnd.ms-excel", mediaType: null },
    "xls": { mimeType: "application/vnd.ms-excel", mediaType: null },
    "xlsm": { mimeType: "application/vnd.ms-excel.sheet.macroEnabled.12", mediaType: null },
    "xlsx": { mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", mediaType: null },
    "xml": { mimeType: "text/xml", mediaType: null },
    "xpdl": { mimeType: "application/xml", mediaType: null },
    "xpm": { mimeType: "image/x-xpixmap", mediaType: MEDIA_TYPES.IMAGE },
    "xsl": { mimeType: "application/xml", mediaType: null },
    "xwd": { mimeType: "image/x-xwindowdump", mediaType: MEDIA_TYPES.IMAGE },
    "zip": { mimeType: "application/zip", mediaType: null }
};
/**
 * Obtains an appropriate mime type given a file extension
 * @param {string} extensionOrPath - The file name or file path of the file including the file extension
 * @returns {string|null} - An appropriate mime type for the file extension, or null if one not found
 */
function getMimeTypeFromExtension(extensionOrPath) {
    if (extensionOrPath.indexOf(".") !== -1) {
        extensionOrPath = extensionOrPath.split(".").pop().toLowerCase();
    }
    if (MIME_TYPE_MAP.hasOwnProperty(extensionOrPath)) {
        return MIME_TYPE_MAP[extensionOrPath].mimeType;
    }
    return null;
}
exports.getMimeTypeFromExtension = getMimeTypeFromExtension;
/**
 * Obtains an appropriate media type (e.g. image, video, audio, etc.) given a file extension
 * @param {string} extensionOrPath - The file name or file path of the file including the file extension
 * @returns {string|null} - An appropriate media type for the file extension, or null if one not found
 */
function getMediaTypeFromExtension(extensionOrPath) {
    if (extensionOrPath.indexOf(".") !== -1) {
        extensionOrPath = extensionOrPath.split(".").pop().toLowerCase();
    }
    if (MIME_TYPE_MAP.hasOwnProperty(extensionOrPath)) {
        return MIME_TYPE_MAP[extensionOrPath].mediaType;
    }
    return null;
}
exports.getMediaTypeFromExtension = getMediaTypeFromExtension;
/**
 * Obtains an appropriate media type (e.g. image, video, audio, etc.) given a mime type
 * @param {string} mimeType - The mime type (e.g. image/jpeg)
 * @returns {string|null} - An appropriate media type for the file extension, or null if one not found
 */
function getMediaTypeFromMimeType(mimeType) {
    const extension = Object.keys(MIME_TYPE_MAP).filter(extension => MIME_TYPE_MAP[extension].mimeType === mimeType)[0];
    return (!extension) ? null : MIME_TYPE_MAP[extension].mediaType;
}
exports.getMediaTypeFromMimeType = getMediaTypeFromMimeType;
/**
 * Obtains just the file name part given a file path
 * @param {string} filePath - The full file path
 * @returns {string} - The file name portion of the file path (including file extension)
 */
function getFileNameFromPath(filePath) {
    return filePath.replace(/\\/g, "/").split("/").pop();
}
exports.getFileNameFromPath = getFileNameFromPath;
/**
 * Obtains the path to the default storage location for the current platform
 * @returns {Promise} - A promise to resolve with the path of the default storage platform
 */
function getStorageLocation() {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            // Bend over backwards to get the electron storage location
            try {
                const app = eWindow.require("electron").remote.app;
                const path = eWindow.require("path");
                const pathSeparator = path.sep;
                const applicationDataPath = app.getPath("userData");
                const location = applicationDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
                // Make it if its not there
                const fs = eWindow.require("fs");
                if (!fs.existsSync(location)) {
                    fs.mkdirSync(location);
                }
                resolve(location);
            }
            catch (e) {
                reject(e);
            }
        }
        else {
            const platformName = Environment.getPlatformName();
            const File = Plugin.getSource("file");
            if (File !== false) {
                let dir = "";
                if (platformName === "ios") {
                    dir += File.documentsDirectory;
                }
                else if (platformName === "android") {
                    dir += File.dataDirectory;
                }
                else {
                    return reject("Unsupported platform, expected Android or iOS.");
                }
                cWindow.resolveLocalFileSystemURL(dir, function (parent) {
                    parent.getDirectory(ATTACHMENTS_DIR, { create: true, exclusive: false }, function (dirEntry) {
                        resolve(dirEntry.nativeURL);
                    }, reject);
                }, reject);
            }
            else {
                reject("No file plugin available.");
            }
        }
    });
}
exports.getStorageLocation = getStorageLocation;
/**
 * Function which figures out which native plugin to use and performs an upload
 * @param filePath {String}
 * @param putUrl {String}
 * @param getUrl {String}
 * @param headers {Object}
 * @returns {Promise}
 */
function upload(filePath, putUrl, getUrl, headers) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (FileTransfer === null)
            FileTransfer = (Environment.isElectron()) ? Plugin.getSource("@commontimeltd/com.commontime.filetransfer") : Plugin.getSource("FileTransfer");
        if (FileTransfer !== false) {
            const uploadOptions = {
                httpMethod: "PUT",
                fileName: getFileNameFromPath(filePath),
                fileKey: "file",
                headers: headers,
                mimeType: getMimeTypeFromExtension(filePath),
                chunkedMode: false
            };
            const ft = new FileTransfer();
            ft.upload(filePath, putUrl, (result) => {
                resolve({
                    source: filePath,
                    target: putUrl,
                    response: result.response
                });
            }, reject, uploadOptions);
        }
        else {
            console.warn("Falling back to using XHR for file uploads.");
            urlToBlob(filePath).then((blob) => {
                const send = new XMLHttpRequest();
                send.addEventListener("load", (e) => {
                    resolve({
                        source: getUrl,
                        target: putUrl,
                        response: e
                    });
                });
                send.addEventListener("error", reject);
                send.open("PUT", putUrl, true);
                if (headers) {
                    for (let key in headers) {
                        send.setRequestHeader(key, headers[key]);
                    }
                }
                send.send(blob);
            });
        }
    });
}
exports.upload = upload;
function download(getUrl, headers = null) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (FileTransfer === null)
            FileTransfer = (Environment.isElectron()) ? Plugin.getSource("@commontimeltd/com.commontime.filetransfer") : Plugin.getSource("FileTransfer");
        if (FileTransfer !== false) {
            getStorageLocation().then((path) => {
                const ft = new FileTransfer();
                const filePath = path + Date.now() + "_" + getFileNameFromPath(getUrl);
                const _success = (result) => {
                    if (Environment.isElectron()) {
                        resolve({
                            source: result.filePath,
                            target: getUrl
                        });
                    }
                    else if (Environment.isDevice()) {
                        resolve({
                            source: result.nativeURL,
                            target: getUrl
                        });
                    }
                    else {
                        console.warn("Attachments are not currently supported on this platform.");
                        reject();
                    }
                };
                const _fail = (e) => {
                    console.error(`Unable to download file '${filePath}' from '${getUrl}':`, e);
                    reject(e);
                };
                // API is different depending on whether you are on a device or on a desktop :( :'( :'''(
                if (Environment.isDevice()) {
                    ft.download(getUrl, filePath, _success, _fail, false, {
                        "headers": headers
                    });
                }
                else {
                    ft.download(getUrl, filePath, _success, _fail, {
                        "headers": headers
                    });
                }
            }).catch(reject);
        }
        else {
            resolve({
                source: getUrl,
                target: getUrl
            });
        }
    });
}
exports.download = download;
function getFileInfo(filePath) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            try {
                const fsplus = eWindow.require("fs-plus");
                fsplus.stat(filePath, (e, stats) => {
                    if (e) {
                        reject(e);
                    }
                    else {
                        resolve({
                            name: getFileNameFromPath(filePath),
                            path: filePath,
                            size: stats.size,
                            type: getMimeTypeFromExtension(filePath),
                            mediaType: getMediaTypeFromExtension(filePath)
                        });
                    }
                });
            }
            catch (e) {
                reject("Couldn't require 'fs-plus' module.");
            }
        }
        else if (Environment.isDevice()) {
            const path = (filePath.indexOf("file://") !== 0) ? `file://${filePath}` : filePath;
            cWindow.resolveLocalFileSystemURL(path, function (fileEntry) {
                fileEntry.file(function (file) {
                    const type = (file.type) ? file.type : getMimeTypeFromExtension(filePath);
                    resolve({
                        name: file.name,
                        path: path,
                        size: file.size,
                        type: type,
                        mediaType: getMediaTypeFromExtension(filePath)
                    });
                });
            }, reject);
        }
        else {
            urlToBlob(filePath).then((blob) => {
                resolve({
                    name: filePath.split("/").pop(),
                    path: filePath,
                    size: blob.size,
                    type: blob.type,
                    mediaType: getMediaTypeFromMimeType(blob.type)
                });
            });
        }
    });
}
exports.getFileInfo = getFileInfo;
function deleteFile(filePath) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            try {
                const fsplus = eWindow.require("fs-plus");
                const fileExists = fsplus.existsSync(filePath);
                if (fileExists) {
                    fsplus.unlinkSync(filePath);
                    resolve();
                }
                else {
                    reject(`File '${filePath}' doesn't exist and cannot be deleted.`);
                }
            }
            catch (e) {
                reject(`Something went wrong while trying to delete the file '${filePath}': ${e}`);
            }
        }
        else if (Environment.isDevice()) {
            cWindow.resolveLocalFileSystemURL(filePath, (fileEntry) => {
                if (fileEntry.isDirectory) {
                    reject(`File path '${filePath}' is a directory and cannot be deleted.`);
                }
                else {
                    fileEntry.remove(resolve, reject);
                }
            }, (err) => {
                reject(err);
            });
        }
        else {
            // No physical file to remove
            resolve();
        }
    });
}
exports.deleteFile = deleteFile;
function urlToBlob(url) {
    return new es6_promise_1.Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "blob";
        xhr.onload = () => {
            if (xhr.status === 200) {
                resolve(xhr.response);
            }
        };
        xhr.send();
    });
}
exports.urlToBlob = urlToBlob;
function blobToObjectUrl(blob) {
    return new es6_promise_1.Promise((resolve) => {
        resolve(URL.createObjectURL(blob));
    });
}
exports.blobToObjectUrl = blobToObjectUrl;
function deleteAttachments() {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            const path = eWindow.require("path");
            const fs = eWindow.require("fs");
            const userDataPath = eWindow.require("electron").remote.app.getPath("userData");
            const pathSeparator = path.sep;
            const location = userDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
            if (!fs.existsSync(location)) {
                return resolve();
            }
            fs.readdir(location, (err, files) => {
                if (err) {
                    return reject(err);
                }
                for (const file of files) {
                    if (fs.lstatSync(path.join(location, file)).isFile()) {
                        fs.unlinkSync(path.join(location, file));
                    }
                }
                resolve();
            });
        }
        else if (Environment.isDevice()) {
            const platformName = Environment.getPlatformName();
            const File = Plugin.getSource("file");
            if (File !== false) {
                let dir = null;
                if (platformName === "ios") {
                    dir = File.documentsDirectory;
                }
                else if (platformName === "android") {
                    dir = File.dataDirectory;
                }
                if (dir !== null) {
                    cWindow.resolveLocalFileSystemURL(dir, parent => {
                        parent.getDirectory(ATTACHMENTS_DIR, { create: false, exclusive: false }, function (dirEntry) {
                            dirEntry.removeRecursively(resolve, reject);
                        }, function (err) {
                            // If directory doesn't exist then there is nothing to delete, so resolve
                            if (err.code === 1) {
                                resolve();
                            }
                            else {
                                console.error(`Couldn't get '${ATTACHMENTS_DIR}' to delete:`, err);
                                reject(err);
                            }
                        });
                    }, function (e) {
                        reject(e);
                    });
                }
                else {
                    reject("Unsupported platform, expected Android or iOS.");
                }
            }
            else {
                reject("No file plugin available.");
            }
        }
        else {
            // Nothing to do (probably browser)
            resolve();
        }
    });
}
exports.deleteAttachments = deleteAttachments;
/**
 *
 * @param options
 *
 * contain one of:
 *
 * mediaType: (MEDIA_TYPES)
 * or
 * mimeTypes: [array of mime types]
 *
 * If neither is supplied, then all file types are assumed
 *
 * @returns {Promise}
 */
function pickFile(options) {
    return new es6_promise_1.Promise((resolve, reject) => {
        let mimes = [];
        let extensions = ["*"];
        let filterName = "All Files";
        if (options.mediaType !== undefined) {
            extensions = Object.keys(MIME_TYPE_MAP)
                .filter(extension => MIME_TYPE_MAP[extension].mediaType === options.mediaType);
            mimes = extensions
                .map((extension) => {
                return MIME_TYPE_MAP[extension].mimeType;
            });
            filterName = options.mediaType;
        }
        else if (options.mimeTypes !== undefined) {
            mimes = options.mimeTypes;
            extensions = Object.keys(MIME_TYPE_MAP)
                .filter(extension => mimes.indexOf(MIME_TYPE_MAP[extension].mimeType) >= 0);
        }
        if (Environment.isElectron()) {
            const dialog = eWindow.require("electron").remote.dialog;
            dialog.showOpenDialog({
                properties: ["openFile", "multiSelections"],
                filters: [{
                        name: filterName,
                        extensions: extensions
                    }]
            }, filePaths => {
                const path = eWindow.require("path");
                const fs = eWindow.require("fs");
                const userDataPath = eWindow.require("electron").remote.app.getPath("userData");
                const pathSeparator = path.sep;
                const location = userDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
                if (!fs.existsSync(location)) {
                    fs.mkdirSync(location);
                }
                const proms = [];
                filePaths.forEach(filePath => {
                    proms.push(new es6_promise_1.Promise((_resolve, _reject) => {
                        const dest = path.join(location, Date.now() + "_" + path.basename(filePath));
                        const _onError = (err) => {
                            console.error(`A problem occurred when trying to copy the file '${filePath}' to '${dest}'.`, err);
                            _reject(err);
                        };
                        const rs = fs.createReadStream(filePath);
                        rs.on("error", _onError);
                        const ws = fs.createWriteStream(dest);
                        ws.on("error", _onError);
                        ws.on("close", () => {
                            _resolve(dest);
                        });
                        rs.pipe(ws);
                    }));
                });
                es6_promise_1.Promise.all(proms).then(resolve).catch(reject);
            });
        }
        else if (Environment.isDevice()) {
            const platformName = Environment.getPlatformName();
            const File = Plugin.getSource("file");
            if (File !== false) {
                let dir = null;
                if (platformName === "ios") {
                    dir = File.documentsDirectory;
                }
                else if (platformName === "android") {
                    dir = File.dataDirectory;
                }
                if (dir !== null) {
                    cWindow.resolveLocalFileSystemURL(dir, parent => {
                        parent.getDirectory(ATTACHMENTS_DIR, { create: true, exclusive: false }, dirEntry => {
                            const FileImporter = Plugin.getSource("fileimporter");
                            if (FileImporter !== null) {
                                FileImporter.importFile((filePath) => {
                                    if (options.encrypt) {
                                        const fileEncryption = Plugin.getSource("fileEncryption");
                                        if (!fileEncryption) {
                                            resolve([filePath]);
                                        }
                                        fileEncryption.encrypt((data) => {
                                            resolve([data]);
                                        }, (err) => {
                                            reject(`Could not encrypt image. ${err}`);
                                        }, (filePath.indexOf("file://") !== 0) ? `file://${filePath}` : filePath);
                                    }
                                    else {
                                        resolve([filePath]);
                                    }
                                }, reject, undefined, mimes, ATTACHMENTS_DIR);
                            }
                            else {
                                reject("File importer plugin not available.");
                            }
                        }, reject);
                    }, reject);
                }
                else {
                    reject("Unsupported platform, expected Android or iOS.");
                }
            }
            else {
                reject("No file plugin available.");
            }
        }
        else {
            const $fileInput = document.createElement("input");
            $fileInput.setAttribute("type", "file");
            $fileInput.setAttribute("multiple", "multiple");
            $fileInput.addEventListener("change", () => {
                const files = [];
                for (let i = 0; i < $fileInput.files.length; i++) {
                    files.push(URL.createObjectURL($fileInput.files[i]));
                }
                resolve(files);
            });
            $fileInput.click();
        }
    });
}
exports.pickFile = pickFile;
/**
 * Method to get the size of the file on disk taking into account that it could be encrypted
 * and we need to get the size of the file when it is NOT encrypted.
 */
function getFileSize(file) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (file && file.name.indexOf(".encrypted") !== -1) {
            const fileEncryption = Plugin.getSource("fileEncryption");
            if (fileEncryption) {
                fileEncryption.getFileSize(size => {
                    try {
                        resolve(parseInt(size));
                    }
                    catch (e) {
                        console.error("Couldn't convert file size to an integer.");
                        reject(e);
                    }
                }, reject, file.path);
            }
            else {
                resolve(file.size);
            }
        }
        else {
            resolve(file.size);
        }
    });
}
exports.getFileSize = getFileSize;
/**
 * Saves a single file to the disk from a blob.
 * @param blob - The content of the file
 * @param filename - A filename to use
 */
function saveFileToDisk(blob, filename) {
    return new es6_promise_1.Promise((resolve, reject) => {
        const path = eWindow.require("path");
        const fs = eWindow.require("fs");
        const userDataPath = eWindow.require("electron").remote.app.getPath("userData");
        const pathSeparator = path.sep;
        const location = userDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
        if (!fs.existsSync(location)) {
            fs.mkdirSync(location);
        }
        const dest = path.join(location, Date.now() + "_" + path.basename(filename));
        const _onError = (err) => {
            console.error(`A problem occurred when trying to copy the file to '${dest}'.`, err);
            reject(err);
        };
        const fr = new FileReader();
        fr.readAsArrayBuffer(blob);
        fr.onerror = _onError;
        fr.onload = () => {
            try {
                fs.writeFileSync(dest, Buffer(new Uint8Array(fr.result)));
                resolve(dest);
            }
            catch (ex) {
                _onError(ex);
            }
        };
    });
}
exports.saveFileToDisk = saveFileToDisk;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63).Buffer))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by leon on 5/19/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
// TODO: Fix linting issues
const plugin_1 = __webpack_require__(22);
const buffer_1 = __webpack_require__(63);
function isNumber(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}
exports.isNumber = isNumber;
function generateGuid() {
    let d = Date.now();
    if (window.performance && typeof window.performance.now === "function") {
        d += performance.now(); // use high-precision timer if available
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
    });
}
exports.generateGuid = generateGuid;
function getEncryptionKey(id) {
    return new Promise((resolve, reject) => {
        const SecureSettings = plugin_1.getSource("securesettings");
        if (SecureSettings !== false) {
            SecureSettings.getOrCreateCryptographicKey(function (key) {
                function hexToBytes(hex) {
                    let bytes = [];
                    for (let c = 0; c < hex.length; c += 2)
                        bytes.push(parseInt(hex.substr(c, 2), 16));
                    return bytes;
                }
                const keyBuffer = buffer_1.Buffer.from(hexToBytes(key));
                resolve(keyBuffer);
            }, reject, id, 256);
        }
        else {
            console.warn("Oh no!  Your databases are encrypted but the key couldn't be secured because this platform doesn't support secure settings.");
            const storedKey = localStorage.getItem(`${id}_key`);
            if (storedKey !== null) {
                const keyBuffer = buffer_1.Buffer.from(JSON.parse(storedKey));
                resolve(keyBuffer);
            }
            else {
                let arr = [], i;
                if (window.crypto && window.crypto.getRandomValues) {
                    var arr8 = new Uint8Array(32);
                    window.crypto.getRandomValues(arr8);
                    for (i = 0; i < 32; i++) {
                        arr[i] = arr8[i];
                    }
                }
                else {
                    for (let i = 0; i < 32; i++) {
                        arr[i] = Math.floor(Math.random() * 256);
                    }
                }
                localStorage.setItem(`${id}_key`, JSON.stringify(arr));
                const keyBuffer = buffer_1.Buffer.from(arr);
                resolve(keyBuffer);
            }
        }
    });
}
exports.getEncryptionKey = getEncryptionKey;
let background = false;
document.addEventListener("pause", () => background = true, false);
document.addEventListener("resume", () => background = false, false);
function isInBackground() {
    return background === true;
}
exports.isInBackground = isInBackground;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
class BaseMessageType {
}
BaseMessageType.XmppChat = "xmppchat";
exports.BaseMessageType = BaseMessageType;
class BaseBotCommand {
}
exports.BaseBotCommand = BaseBotCommand;
class BaseIQ {
}
exports.BaseIQ = BaseIQ;
function get(baseLayer) {
    return [];
}
exports.get = get;
var BaseHandler_1 = __webpack_require__(88);
exports.BaseHandler = BaseHandler_1.BaseHandler;
// tslint:enable no-any


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const renderUtils_1 = __webpack_require__(8);
const utils_1 = __webpack_require__(2);
const renderUtils_2 = __webpack_require__(8);
// tslint:disable no-any
const VIRTUAL_LIST_LOCATION = "vl-l";
class VirtualList {
    constructor(host, items, config) {
        this.EMPTY_STYLES = renderUtils_1.buildStyles();
        this._scrollerStyles = renderUtils_1.buildStyles({
            "overflow-y": "auto",
            "overflowScrolling": "touch",
            "WebkitOverflowScrolling": "touch",
            "will-change": "transform"
        });
        this._host = host;
        this._items = items;
        this._config = config;
        this._initialized = false;
        this._id = `vl_${utils_1.generateRandomSixString()}`;
        this._scroller = null;
        this._useBlocks = config.blockSize && config.blockSize > 0;
        host.onRenderComplete(() => {
            this._scroller = host.shadowRoot.querySelector(`#${this._id}`);
            if (!this._scroller) {
                this._initialized = false;
                return;
            }
            if (this._initialized)
                return;
            renderUtils_2.debouncedRequestAnimationFrame(() => this._calculateVirtualListData(true));
            this._scroller.addEventListener("scroll", () => renderUtils_2.debouncedRequestAnimationFrame(() => this._calculateVirtualListData()));
            this._initialized = true;
        });
        window.addEventListener("resize", () => {
            if (!this._useBlocks)
                this._calculateVirtualListData();
        });
    }
    get items() {
        return this._items;
    }
    setItems(items) {
        this._items = items;
        this._calculateVirtualListData(true);
        this._updateHost();
    }
    render(itemRenderer, scrollerClass = "", contentClass = "") {
        const scrollerProps = this._data && this._data.scrollerProps || {
            "id": this._id,
            "key": this._id
        };
        const containerProps = this._data && this._data.containerProps || {};
        const hasItems = this._data && !!this._data.viewportItems;
        return (window.__CTRender("div", Object.assign({ class: `virtual-list-scroller ${scrollerClass}` }, scrollerProps), hasItems && (window.__CTRender("div", Object.assign({ class: `virtual-list-content ${contentClass}` }, containerProps), this._data.viewportItems.map((x, idx) => itemRenderer(x.item, x.itemProps, idx))))));
    }
    // === Private functions === //
    _calculateVirtualListData(forceUpdate = false) {
        if (!this._scroller)
            return;
        const itemIdx = Math.floor(this._scroller.scrollTop / this._config.itemHeight);
        const previousLocation = parseInt(this._scroller.getAttribute(VIRTUAL_LIST_LOCATION)) || null;
        const currentLocation = this._useBlocks
            ? Math.floor(itemIdx / this._config.blockSize)
            : itemIdx;
        if (!forceUpdate && previousLocation === currentLocation)
            return;
        const totalItems = this._items.length;
        if (this._useBlocks) {
            const blockHeight = this._config.itemHeight * this._config.blockSize;
            const totalBlocks = Math.floor(totalItems / this._config.blockSize) + 1;
            const startBlock = Math.max(0, currentLocation - 1);
            const endBlock = Math.min(totalBlocks, currentLocation + 1);
            const blocksToShow = (endBlock - startBlock) + 1;
            const viewportItemsCount = blocksToShow * this._config.blockSize;
            const startIdx = startBlock * this._config.blockSize;
            const endIdx = Math.max(0, startIdx + viewportItemsCount - 1);
            const offset = startBlock * blockHeight;
            const viewportItems = this._items.slice(startIdx, endIdx + 1);
            this._data = this._generateVirtualListData(viewportItems, currentLocation, offset);
        }
        else {
            const visibleItemCount = Math.ceil(this._scroller.clientHeight / this._config.itemHeight);
            const bufferSize = visibleItemCount * 3;
            const startIdx = Math.max(itemIdx - bufferSize, 0);
            const endIdx = itemIdx + visibleItemCount;
            const preBuffer = Math.max(itemIdx - startIdx, 0);
            const postBuffer = Math.min(totalItems - endIdx, bufferSize);
            const viewportItemsCount = preBuffer + visibleItemCount + postBuffer;
            const offset = startIdx * this._config.itemHeight;
            const viewportItems = this._items.slice(startIdx, endIdx + 1);
            this._data = this._generateVirtualListData(viewportItems, currentLocation, offset);
        }
        this._updateHost();
        if (typeof (this._config.onUpdate) === "function")
            this._config.onUpdate(this._data);
    }
    _generateVirtualListData(viewportItems, currentLocation, offset) {
        const totalItems = this._items.length;
        const totalHeight = totalItems * this._config.itemHeight;
        return {
            viewportItems: this._mapToVirtualListItems(viewportItems, offset),
            scrollerProps: {
                "id": this._id,
                "key": this._id,
                [VIRTUAL_LIST_LOCATION]: currentLocation.toString(),
                style: this._scrollerStyles
            },
            containerProps: {
                style: this._setStyles({
                    "position": "relative",
                    "height": `${totalHeight}px`
                })
            }
        };
    }
    _mapToVirtualListItems(items, offset) {
        return items.map((item, idx) => {
            const itemOffset = offset + idx * this._config.itemHeight;
            return {
                item,
                itemProps: {
                    "key": this._config.itemKeyGetter(item),
                    "style": this._setStyles({
                        "position": "absolute",
                        "top": 0,
                        "left": 0,
                        "width": "100%",
                        "height": `${this._config.itemHeight}px`,
                        "transform": `translateY(${itemOffset}px)`
                    })
                }
            };
        });
    }
    _setStyles(styles = {}) {
        return Object.assign({}, this.EMPTY_STYLES, styles);
    }
    _updateHost() {
        this._host.forceRedraw();
    }
    // Public method to force a recalculation of the rows
    forceRecalc() {
        this._calculateVirtualListData(true);
    }
}
exports.VirtualList = VirtualList;
// tslint:enable no-any


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.AMPERSAND = exports.CLOSEPAREN = exports.CLOSEANGLEBRACKET = exports.CLOSEBRACKET = exports.CLOSEBRACE = exports.OPENPAREN = exports.OPENANGLEBRACKET = exports.OPENBRACKET = exports.OPENBRACE = exports.WS = exports.TLD = exports.SYM = exports.UNDERSCORE = exports.SLASH = exports.MAILTO = exports.PROTOCOL = exports.QUERY = exports.POUND = exports.PLUS = exports.NUM = exports.NL = exports.LOCALHOST = exports.PUNCTUATION = exports.DOT = exports.COLON = exports.AT = exports.DOMAIN = exports.Base = undefined;

var _createTokenClass = __webpack_require__(66);

var _class = __webpack_require__(28);

/******************************************************************************
	Text Tokens
	Tokens composed of strings
******************************************************************************/

/**
	Abstract class used for manufacturing text tokens.
	Pass in the value this token represents

	@class TextToken
	@abstract
*/
var TextToken = (0, _createTokenClass.createTokenClass)();
TextToken.prototype = {
	toString: function toString() {
		return this.v + '';
	}
};

function inheritsToken(value) {
	var props = value ? { v: value } : {};
	return (0, _class.inherits)(TextToken, (0, _createTokenClass.createTokenClass)(), props);
}

/**
	A valid domain token
	@class DOMAIN
	@extends TextToken
*/
var DOMAIN = inheritsToken();

/**
	@class AT
	@extends TextToken
*/
var AT = inheritsToken('@');

/**
	Represents a single colon `:` character

	@class COLON
	@extends TextToken
*/
var COLON = inheritsToken(':');

/**
	@class DOT
	@extends TextToken
*/
var DOT = inheritsToken('.');

/**
	A character class that can surround the URL, but which the URL cannot begin
	or end with. Does not include certain English punctuation like parentheses.

	@class PUNCTUATION
	@extends TextToken
*/
var PUNCTUATION = inheritsToken();

/**
	The word localhost (by itself)
	@class LOCALHOST
	@extends TextToken
*/
var LOCALHOST = inheritsToken();

/**
	Newline token
	@class NL
	@extends TextToken
*/
var NL = inheritsToken('\n');

/**
	@class NUM
	@extends TextToken
*/
var NUM = inheritsToken();

/**
	@class PLUS
	@extends TextToken
*/
var PLUS = inheritsToken('+');

/**
	@class POUND
	@extends TextToken
*/
var POUND = inheritsToken('#');

/**
	Represents a web URL protocol. Supported types include

	* `http:`
	* `https:`
	* `ftp:`
	* `ftps:`

	@class PROTOCOL
	@extends TextToken
*/
var PROTOCOL = inheritsToken();

/**
	Represents the start of the email URI protocol

	@class MAILTO
	@extends TextToken
*/
var MAILTO = inheritsToken('mailto:');

/**
	@class QUERY
	@extends TextToken
*/
var QUERY = inheritsToken('?');

/**
	@class SLASH
	@extends TextToken
*/
var SLASH = inheritsToken('/');

/**
	@class UNDERSCORE
	@extends TextToken
*/
var UNDERSCORE = inheritsToken('_');

/**
	One ore more non-whitespace symbol.
	@class SYM
	@extends TextToken
*/
var SYM = inheritsToken();

/**
	@class TLD
	@extends TextToken
*/
var TLD = inheritsToken();

/**
	Represents a string of consecutive whitespace characters

	@class WS
	@extends TextToken
*/
var WS = inheritsToken();

/**
	Opening/closing bracket classes
*/

var OPENBRACE = inheritsToken('{');
var OPENBRACKET = inheritsToken('[');
var OPENANGLEBRACKET = inheritsToken('<');
var OPENPAREN = inheritsToken('(');
var CLOSEBRACE = inheritsToken('}');
var CLOSEBRACKET = inheritsToken(']');
var CLOSEANGLEBRACKET = inheritsToken('>');
var CLOSEPAREN = inheritsToken(')');

var AMPERSAND = inheritsToken('&');

exports.Base = TextToken;
exports.DOMAIN = DOMAIN;
exports.AT = AT;
exports.COLON = COLON;
exports.DOT = DOT;
exports.PUNCTUATION = PUNCTUATION;
exports.LOCALHOST = LOCALHOST;
exports.NL = NL;
exports.NUM = NUM;
exports.PLUS = PLUS;
exports.POUND = POUND;
exports.QUERY = QUERY;
exports.PROTOCOL = PROTOCOL;
exports.MAILTO = MAILTO;
exports.SLASH = SLASH;
exports.UNDERSCORE = UNDERSCORE;
exports.SYM = SYM;
exports.TLD = TLD;
exports.WS = WS;
exports.OPENBRACE = OPENBRACE;
exports.OPENBRACKET = OPENBRACKET;
exports.OPENANGLEBRACKET = OPENANGLEBRACKET;
exports.OPENPAREN = OPENPAREN;
exports.CLOSEBRACE = CLOSEBRACE;
exports.CLOSEBRACKET = CLOSEBRACKET;
exports.CLOSEANGLEBRACKET = CLOSEANGLEBRACKET;
exports.CLOSEPAREN = CLOSEPAREN;
exports.AMPERSAND = AMPERSAND;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const events_1 = __webpack_require__(9);
const Base_1 = __webpack_require__(12);
const Events_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(2);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ADD_CONTACTS"] = "Add Contacts"] = "ADD_CONTACTS";
    I18nKeys[I18nKeys["CHOOSE_CONTACT"] = "Choose contacts to add to conversation"] = "CHOOSE_CONTACT";
    I18nKeys[I18nKeys["TOTAL_CONTACTS"] = "Total {{number}} Contacts in Conversation"] = "TOTAL_CONTACTS";
    I18nKeys[I18nKeys["TOTAL_CONTACTS_MAX"] = "Total {{number}} Contacts in Conversation (out of {{maximum}})"] = "TOTAL_CONTACTS_MAX";
    I18nKeys[I18nKeys["SEARCH_PLACEHOLDER"] = "Find Contacts"] = "SEARCH_PLACEHOLDER";
    I18nKeys[I18nKeys["INITIAL_MESSAGE"] = "Find your contacts using the search bar above"] = "INITIAL_MESSAGE";
    I18nKeys[I18nKeys["NO_MATCHES"] = "No contacts match your search"] = "NO_MATCHES";
    I18nKeys[I18nKeys["ADD"] = "Add"] = "ADD";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLAddConversationContactsMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLAddConversationContacts, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLAddConversationContactsMetadata._instance = null;
exports.CTCLAddConversationContactsMetadata = CTCLAddConversationContactsMetadata;
class CTCLAddConversationContacts extends Base_1.CTCLComponent {
    // === End properties === //
    constructor() {
        super();
        this.setMetadata(CTCLAddConversationContactsMetadata.instance);
    }
    static get is() {
        return "ct-cl-add-conversation-contacts";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.conversation = yield this.layer.getCurrentConversation();
            if (!this.conversation)
                return this._back();
            this.layer.setBackHandler(() => {
                this._back();
            });
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener();
        this.addListener(Events_1.ChatEvents.ConversationParticipantsChanged, (detail) => {
            if (this.conversation && this.conversation.id === detail.conversation.id) {
                this.conversation.participants = detail.conversation.participants;
                this.forceRedraw();
            }
        });
        // Catch the disconnect and remove the waiting message so the user doesn't get stuck if they are disconnected while adding users
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            if (detail.status === models_1.ConnectionStatus.Disconnected) {
                this.dismissWaitingMessage();
                this._back();
            }
        }, { dontSuppress: true });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;height:100%;font-size:1em}:host .contact-list{flex:1 1 auto;display:flex;flex-direction:column;height:100%}:host .contact-list .header .action{cursor:pointer}:host .contact-list .user-list{flex:1 1 auto;display:flex;flex-direction:column;overflow:auto}:host .contact-list .user-list #user-list{display:flex;flex-direction:column;flex:1}:host .contact-list .footer{flex:0 0 auto;background:var(--secondary-color, #f2f2f2);border-top:var(--secondary-border, 1px solid #ddd);display:flex;padding:10px 20px}:host .contact-list .footer .button{flex:1 1;margin:0 5px}
        `;
    }
    generateComponentMarkup() {
        const existingParticipants = this.conversation.participants.map(x => x.jid);
        const maxParticipants = this.layer.config.behaviour.maxConversationParticipants;
        const userListProps = {
            excludeUsers: existingParticipants,
            allowSearch: this.allowSearch,
            requireSearch: this.requireSearch,
            searchPlaceholder: this.translateI18nItem(I18nKeys.SEARCH_PLACEHOLDER),
            initialMessage: this.translateI18nItem(I18nKeys.INITIAL_MESSAGE),
            noMatchesMessage: this.translateI18nItem(I18nKeys.NO_MATCHES),
            allowSelection: true,
            maxSelections: (maxParticipants - existingParticipants.length),
            onChangeSelection: (selections) => {
                this.selectedParticipantCount = selections.length;
            },
            onClickUser: (user) => {
                this.layer.showContactInfo(user, null, false);
            },
            onClickGroup: (group) => this.layer.showRoleUsersModal(group)
        };
        return (window.__CTRender("div", { class: "contact-list" },
            this._renderHeader(),
            window.__CTRender("div", { class: "user-list" },
                window.__CTRender(components_1.CTUserList, Object.assign({ id: "user-list" }, userListProps))),
            this._renderFooter()));
    }
    _renderHeader() {
        const maxParticipants = this.layer.config.behaviour.maxConversationParticipants || 0;
        const participantCountHeaderTemplate = (maxParticipants === 0)
            ? this.translateI18nItem(I18nKeys.TOTAL_CONTACTS)
            : this.translateI18nItem(I18nKeys.TOTAL_CONTACTS_MAX);
        const totalParticipants = (this.conversation.participants.length - 1) + this.selectedParticipantCount;
        const subHeader = (this.showCountFrom !== null) && (totalParticipants >= this.showCountFrom)
            ? participantCountHeaderTemplate
                .replace("{{number}}", totalParticipants.toString())
                .replace("{{maximum}}", (maxParticipants - 1).toString())
            : this.translateI18nItem(I18nKeys.CHOOSE_CONTACT);
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, this.translateI18nItem(I18nKeys.ADD_CONTACTS)),
            window.__CTRender("div", { slot: "sub-heading" }, subHeader)));
    }
    _renderFooter() {
        return (window.__CTRender("div", { class: "footer" },
            window.__CTRender(components_1.CTButton, { type: "primary", class: "button", disabled: !this.isOnline || (this.selectedParticipantCount === 0), onClick: this._add.bind(this) }, this.translateI18nItem(I18nKeys.ADD))));
    }
    // === Event handlers === //
    _back() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._clearSelectedUsers();
            this.emitComponentEvent("go-back");
        });
    }
    _add() {
        return __awaiter(this, void 0, void 0, function* () {
            const selectedUsers = yield this._getSelectedUsers();
            const selectedUserJids = new Map();
            for (const item of selectedUsers) {
                if (item.name) {
                    item.users.map(i => selectedUserJids.set(i.jid.toLowerCase(), i));
                }
                else {
                    selectedUserJids.set(item.jid.toLowerCase(), item);
                }
            }
            const jids = Array.from(selectedUserJids.keys());
            const newParticipants = jids.map(x => ({
                jid: x,
                role: models_1.ChatRole.Participant
            }));
            if (yield this.layer.addParticipantsToConversation(this.conversation, newParticipants)) {
                this._back();
            }
        });
    }
    // === Private functions === //
    _getSelectedUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            const userList = this.shadowRoot.querySelector("#user-list");
            if (!userList)
                return [];
            const selections = yield userList.getSelections();
            return utils_1.sortUsersByName(selections);
        });
    }
    _clearSelectedUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            const userList = this.shadowRoot.querySelector("#user-list");
            if (!userList)
                return;
            yield userList.clearSelections();
        });
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTCLAddConversationContacts.prototype, "allowSearch", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTCLAddConversationContacts.prototype, "requireSearch", void 0);
__decorate([
    base_1.prop({ type: base_1.NullableNumber, attribute: true, default: null })
], CTCLAddConversationContacts.prototype, "showCountFrom", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLAddConversationContacts.prototype, "conversation", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTCLAddConversationContacts.prototype, "selectedParticipantCount", void 0);
exports.CTCLAddConversationContacts = CTCLAddConversationContacts;
CTCLAddConversationContacts.register();


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const errors_1 = __webpack_require__(25);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const UserLookup_1 = __webpack_require__(26);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
const renderUtils_1 = __webpack_require__(8);
const Keys_1 = __webpack_require__(20);
const utils_2 = __webpack_require__(2);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const clamp_1 = __webpack_require__(209);
const ct_cl_thumbnail_1 = __webpack_require__(162);
const plugins_1 = __webpack_require__(27);
const ConversationConfigReader_1 = __webpack_require__(14);
const ctcl_attachment_handler_1 = __webpack_require__(48);
const ctcl_response_view_1 = __webpack_require__(50);
// tslint:disable-next-line no-any
const eventListenerOptionsOnce = { once: true };
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["DIRECT_CONVERSATION"] = "Direct Conversation"] = "DIRECT_CONVERSATION";
    I18nKeys[I18nKeys["NAMED_CONVERSATION"] = "Named Conversation"] = "NAMED_CONVERSATION";
    I18nKeys[I18nKeys["SELF_CONVERSATION"] = "Conversation with self"] = "SELF_CONVERSATION";
    I18nKeys[I18nKeys["CONTACTS_IN_CONVERSATION"] = "{{number}} contact(s) in this conversation"] = "CONTACTS_IN_CONVERSATION";
    I18nKeys[I18nKeys["INFO"] = "Info"] = "INFO";
    I18nKeys[I18nKeys["EDIT_INFO"] = "Edit Info"] = "EDIT_INFO";
    I18nKeys[I18nKeys["LEAVE"] = "Leave"] = "LEAVE";
    I18nKeys[I18nKeys["COMFIRM_LEAVE"] = "Are you sure you wish to leave this conversation?"] = "COMFIRM_LEAVE";
    I18nKeys[I18nKeys["END"] = "End"] = "END";
    I18nKeys[I18nKeys["COMFIRM_END"] = "Are you sure you wish to end this conversation?"] = "COMFIRM_END";
    I18nKeys[I18nKeys["DELETE"] = "Delete"] = "DELETE";
    I18nKeys[I18nKeys["DELETE_CONFIRM"] = "Are you sure you wish to delete this conversation? This will remove all messages from your device."] = "DELETE_CONFIRM";
    I18nKeys[I18nKeys["RESPONSES"] = "View Responses"] = "RESPONSES";
    I18nKeys[I18nKeys["PROVISIONAL_MESSAGE"] = "This conversation will be created when you send your first message"] = "PROVISIONAL_MESSAGE";
    I18nKeys[I18nKeys["SCROLL_TO_TOP_FOR_MORE"] = "Scroll to top to fetch more"] = "SCROLL_TO_TOP_FOR_MORE";
    I18nKeys[I18nKeys["AT_START"] = "At start of conversation"] = "AT_START";
    I18nKeys[I18nKeys["LOADING_IMAGE"] = "loading image..."] = "LOADING_IMAGE";
    I18nKeys[I18nKeys["IMAGE_REFETCH"] = "Download image"] = "IMAGE_REFETCH";
    I18nKeys[I18nKeys["IMAGE_ERROR"] = "Image unable to download, press to retry"] = "IMAGE_ERROR";
    I18nKeys[I18nKeys["MESSAGE_PLACEHOLDER"] = "Message"] = "MESSAGE_PLACEHOLDER";
    I18nKeys[I18nKeys["CONFIRM_REPLACE_IMAGE"] = "You have already selected an image to attach. Do you want to replace this with a different image?"] = "CONFIRM_REPLACE_IMAGE";
    I18nKeys[I18nKeys["SEND_ERROR"] = "Unable to send message"] = "SEND_ERROR";
    I18nKeys[I18nKeys["FETCH_ERROR_NOT_ONLINE"] = "Unable to fetch messages whilst offline"] = "FETCH_ERROR_NOT_ONLINE";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLChatMessageListMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLChatMessageList, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLChatMessageListMetadata._instance = null;
exports.CTCLChatMessageListMetadata = CTCLChatMessageListMetadata;
class CTCLChatMessageList extends Base_1.CTCLComponent {
    constructor() {
        super();
        // === End properties === //
        this._isInitialising = false;
        this._chatListScrollable = null;
        this._chatListFetchMore = null;
        this._chatScrollToBottom = null;
        this._messageTextbox = null;
        this._isInitialFetch = true;
        this._rawChatEntries = []; // raw chat entries are all of the fetched chat entries from the server
        this._processedChatEntries = []; // processed chat entries are all the raw chat entries embelished with day dividers
        this._batchSize = null;
        this._visibleChatEntryBlockSize = null;
        this._startIdx = null;
        this._endIdx = null;
        this._supportsOverscroll = false;
        this._suppressScrollHandler = false;
        this._newNotificationsCount = 0;
        this._draft = null;
        this._saveDraftTimeout = null;
        this._pendingConversationId = null;
        this._pendingDraft = null;
        this._maxMessageLength = null;
        this._description = null;
        this._priorityDescriptionExpanded = true;
        this._deferredEvents = [];
        this._onForeground = () => {
            // We need to see if there are any visible chat messages that we need to now mark as read
            if (this.isOnline)
                this.visibleChatEntries.forEach(x => this.layer.markChatEntryRead(x));
            // Then listen for the background event again (so we only ever have one in memory at once)
            document.removeEventListener("pause", this._onBackground);
            document.addEventListener("pause", this._onBackground, eventListenerOptionsOnce);
        };
        this._onBackground = () => {
            // When we go into the background listen for when we come into the foreground again
            document.removeEventListener("resume", this._onForeground);
            document.addEventListener("resume", this._onForeground, eventListenerOptionsOnce);
        };
        // === Event handlers === //
        this._onScroll = () => {
            if (this._suppressScrollHandler)
                return;
            const scrollTop = this._chatListScrollable.scrollTop;
            const scrollHeight = this._chatListScrollable.scrollHeight;
            const clientHeight = this._chatListScrollable.clientHeight;
            const bottomTrigger = scrollHeight - clientHeight;
            if (scrollTop <= 0) {
                this._suppressScrollHandler = true;
                this._stopScroll(0)
                    .then(() => this._handleScrollAtTop());
            }
            else if (Math.ceil(scrollTop) >= bottomTrigger) {
                this._suppressScrollHandler = true;
                this._stopScroll(bottomTrigger)
                    .then(() => this._handleScrollAtBottom());
            }
        };
        this._viewInfo = () => __awaiter(this, void 0, void 0, function* () {
            yield this._saveDraft();
            const isDirectConversation = this.conversation.type === Models_1.ConversationType.Direct;
            if (isDirectConversation && this.conversation.participants.length === 1) {
                const me = this.layer.getCurrentUser();
                this.layer.showContactInfo(me, this.conversation, false);
            }
            else if (isDirectConversation && this.conversation.participants.length === 2) {
                const currentUserJid = this.layer.getCurrentUserJid();
                const otherParticipant = this.conversation.participants.find(x => !utils_1.jidsMatch(x.jid, currentUserJid));
                const contact = this._userLookup.get(otherParticipant.jid);
                this.layer.showContactInfo(contact, this.conversation, false);
            }
            else {
                this.emitComponentEvent("go-info");
            }
        });
        this._deleteDirect = () => __awaiter(this, void 0, void 0, function* () {
            if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.DELETE_CONFIRM))) {
                const last = this._rawChatEntries[this._rawChatEntries.length - 1];
                yield this.layer.markDirectConversationAsDeleted(this.conversation, last ? last.date : 0);
            }
        });
        this._openResponses = () => __awaiter(this, void 0, void 0, function* () {
            yield this.layer.showResponsesModal(this.conversation);
        });
        this.setMetadata(CTCLChatMessageListMetadata.instance);
    }
    static get is() {
        return "ct-cl-chat-message-list";
    }
    initialize(layer) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this, layer);
            this._isInitialising = true;
            this._userLookup = new UserLookup_1.UserLookup(this.layer);
            this._batchSize = this.layer.config.behaviour && this.layer.config.behaviour.chatEntriesFetchBatchSize || null;
            this._visibleChatEntryBlockSize = this._batchSize || 10;
            this._maxMessageLength = this.layer.config.behaviour && this.layer.config.behaviour.maxMessageLength || 5000;
            this._detectOverscrollSupport();
            this.conversation = yield this.layer.getCurrentConversation();
            if (!this.conversation)
                return this._back();
            if (this.conversation.isClosed)
                return this._back();
            this._config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, this.conversation);
            this._draft = this.conversation.draft || null;
            this._updateSendButton();
            this.onRenderComplete(() => this._getDomNodes());
            this.onRenderComplete(() => this._multilineEllipsis(false));
            this.onRenderComplete(() => this._setupScrollWatcher(), true);
            this.onRenderComplete(() => this._calcLongDescription(), true);
            this.isFetchingMore = true;
            this.defer(() => __awaiter(this, void 0, void 0, function* () {
                yield this._refreshUserLookup();
                this.forceRedraw();
                this.defer(() => __awaiter(this, void 0, void 0, function* () {
                    // Hold back loading chat entries if the conversation is being purged to avoid errors.
                    if (!this.layer.isConversationBeingPurged(this.conversation.id)) {
                        yield this._fetchMoreChatEntries(true);
                    }
                    this.defer(() => {
                        this._isInitialising = false;
                        this._deferredEvents.forEach(x => this.emitEvent(x.eventType, x.data));
                    });
                }));
            }));
            this._autoFocusMessageTextboxOnDesktop();
            this.layer.setBackHandler(() => {
                this._back();
            });
        });
    }
    setupListeners() {
        /**
         * Specifically listen for a conversation purging to finish
         */
        this.addListener(Events_1.ChatEvents.ConversationPurged, (detail) => __awaiter(this, void 0, void 0, function* () {
            // If the purging has finished on the current conversation we are okay to go ahead and load chat entries.
            if (detail.conversation.id === this.conversation.id) {
                this._fetchMoreChatEntries();
            }
        }));
        /**
         * Specifically listen for auto reconnect and if the stream hasn't been resumed then we want to reset the view to ensure new messages
         * from the conversation fetch get shown in the chat list
         */
        this.addListener(Events_1.ChatEvents.AutoReconnected, ({ resumed }) => __awaiter(this, void 0, void 0, function* () {
            if (this._isInitialising) {
                this._deferredEvents.push({
                    eventType: Events_1.ChatEvents.AutoReconnected,
                    data: { resumed: resumed }
                });
                return;
            }
            this._isInitialising = true;
            yield this._resetForConversationChange();
            yield this._fetchMoreChatEntries(true);
            this._suppressScrollHandler = false;
            const currentConversation = yield this.layer.getCurrentConversation();
            // Hack...?
            // We need to check here incase other events have happened and removed the currentConversation
            // (e.g. the conversation being ended whilst offline)
            if (currentConversation && currentConversation.id === this.conversation.id) {
                this.conversation.preview = this._processedChatEntries[this._processedChatEntries.length - 1];
                this.conversation.hasUnread = false;
                yield this.layer.updateConversation(this.conversation);
            }
            if (this.isOnline) {
                this.visibleChatEntries.forEach(x => this.layer.markChatEntryRead(x));
            }
            this._removeDeferredEvent(Events_1.ChatEvents.AutoReconnected);
            this.defer(() => {
                this._isInitialising = false;
                this._deferredEvents.forEach(x => this.emitEvent(x.eventType, x.data));
            });
        }), { dontSuppress: true });
        /**
         * This is needed because it's called from somewhere and sets the this.isOnline
         * property. This is required to actually send messages...
         * NK Edit: We don't need to do anything inside this function because the
         * AutoReconnected handler above does it all for us.
         */
        this.setupConnectionStatusListener();
        this.addListener(Events_1.ChatEvents.ConversationAdded, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this._pendingConversationId && this._pendingConversationId === detail.conversation.id) {
                const conversation = utils_1.deepCloneObject(detail.conversation);
                this._draft = this._pendingDraft;
                this._pendingDraft = null;
                yield this.layer.setCurrentConversation(conversation);
            }
        }));
        this.addListener(Events_1.ChatEvents.ConversationParticipantsChanged, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this.conversation && this.conversation.id === detail.conversation.id) {
                this.conversation.participants = detail.participants;
                yield this._refreshUserLookup();
                this.forceRedraw();
            }
        }));
        this.addListener(Events_1.ChatEvents.ChatEntryReceived, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this._isInitialising) {
                this._deferredEvents.push({
                    eventType: Events_1.ChatEvents.ChatEntryReceived,
                    data: detail
                });
                return;
            }
            if (yield this.layer.belongsToCurrentConversation(detail.chatEntry)) {
                yield this._appendChatEntry(detail.chatEntry);
                this.conversation = yield this.layer.getCurrentConversation();
                this.conversation.hasUnread = false;
                const updateOptions = {};
                if (detail.chatEntry.date > this.conversation.preview.date) {
                    this.conversation.preview = detail.chatEntry;
                    updateOptions.preview = detail.chatEntry;
                }
                yield this.layer.updateConversation(this.conversation, updateOptions);
                this._calcLongDescription();
                if (this.isOnline)
                    yield this.layer.markChatEntryRead(detail.chatEntry);
            }
            this._removeDeferredEvent(Events_1.ChatEvents.ChatEntryReceived);
        }));
        this.addListener(Events_1.ChatEvents.ChatEntryUpdated, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this._isInitialising) {
                this._deferredEvents.push({
                    eventType: Events_1.ChatEvents.ChatEntryUpdated,
                    data: detail
                });
                return;
            }
            if (yield this.layer.belongsToCurrentConversation(detail.chatEntry)) {
                if (detail.chatEntry.type === models_1.ChatEntryType.Chat) {
                    // We are having to put this in a timeout because chat marker updates are firing before the chat entry has
                    // been returned and put into the chat list UI, meaning that the entry is not there to update yet
                    setTimeout(() => {
                        this._updateChatEntry(detail.chatEntry);
                    }, 1000);
                    this._removeDeferredEvent(Events_1.ChatEvents.ChatEntryUpdated);
                }
            }
        }));
        this.addListener(Events_1.ChatEvents.CurrentConversationChanged, () => __awaiter(this, void 0, void 0, function* () {
            this._resetForConversationChange();
            this.conversation = yield this.layer.getCurrentConversation();
            if (!this.conversation)
                return;
            yield this._refreshUserLookup();
            this.isFetchingMore = true;
            this.defer(() => __awaiter(this, void 0, void 0, function* () {
                yield this._fetchMoreChatEntries();
                if (this._pendingConversationId && this._pendingConversationId === this.conversation.id) {
                    this._pendingConversationId = null;
                    if (this._draft || (this.media && this.media.length)) {
                        this.sending = false;
                        this._sendMessage();
                    }
                }
            }));
        }));
        this.addListener(Events_1.ChatEvents.ConversationDeleted, () => {
            this._clearDraft();
            this.emitComponentEvent("go-end");
        });
        this.addListener(Events_1.ChatEvents.ThumbnailLoaded, (entry) => {
            const idx = this._processedChatEntries.findIndex(x => x.id === entry.id);
            if (idx > -1 && this._processedChatEntries.length - idx < 5) {
                setTimeout(() => this._scrollToBottom(false), 500);
            }
        });
        // Start by listening for the background event
        document.removeEventListener("pause", this._onBackground);
        document.addEventListener("pause", this._onBackground, eventListenerOptionsOnce);
    }
    _removeDeferredEvent(type) {
        const idx = this._deferredEvents.findIndex(x => x.eventType === type);
        if (idx > -1) {
            this._deferredEvents.splice(idx, 1);
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._removeMedia(true);
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;height:736px;font-size:1em}:host .chat-message-list{position:relative;flex:1 1 auto;display:flex;flex-direction:column;height:736px;overflow-x:hidden;background-color:var(--chat-list-bg-color, #fff)}@media only screen and (min-width: 960px){:host .chat-message-list.desktop{flex-direction:row}:host .chat-message-list.desktop .description-container{flex-basis:40%;flex-direction:column;background:var(--default-bg-color-light, #F1F1F1)}:host .chat-message-list.desktop .description-container .image-thumbnail{align-items:center;width:100%;padding:20px 20px 0;flex:0 1;height:30%}:host .chat-message-list.desktop .description-container #description-text{overflow:initial !important}:host .chat-message-list.desktop .description-container .expander{display:none}}:host .chat-message-list ctcl-response-view{flex-basis:50%;flex:1}:host .chat-message-list .response-container{flex:1}:host .chat-message-list .header .action{cursor:pointer}:host .chat-message-list .audio-attachment{padding:20px;background:var(--default-bg-color-light, #F1F1F1);color:var(--default-bg-color-light-font, --default-font-color)}:host .chat-message-list .priority-description{display:flex;flex-direction:row;flex-shrink:0;background:var(--default-bg-color-light, #F1F1F1);color:var(--default-bg-color-light-font, --default-font-color)}:host .chat-message-list .priority-description .image-thumbnail{height:75px;width:75px;flex:0 0 auto}:host .chat-message-list .priority-description .description-text{font-size:1.333em;padding:15px 10px 0 25px;height:60px;margin-bottom:15px}:host .chat-message-list .priority-description .description-text.collapsed{overflow:hidden}:host .chat-message-list .priority-description .description-text:not(.collapsed){height:auto;max-height:200px;overflow-y:auto !important;text-wrap:normal;-webkit-overflow-scrolling:touch;white-space:pre-line}:host .chat-message-list .priority-description .expander{display:flex;flex-direction:column-reverse;padding:15px}:host .chat-message-list .priority-description .expander>.hidden{display:none}:host .chat-message-list .chat-history{flex:1 1 auto;position:relative;overflow:auto;-webkit-overflow-scrolling:touch}:host .chat-message-list .chat-history .fetch-more{display:flex;justify-content:center;align-items:center;text-align:center;height:80px;overflow:hidden;transition:height var(--animation-normal, .5s) ease-out;color:var(--subtle-font-color, #828688)}:host .chat-message-list .chat-history .fetch-more .error{display:flex;align-items:center}:host .chat-message-list .chat-history .fetch-more .error .icon{margin:0 5px 0 0}:host .chat-message-list .chat-history .fetch-more.no-more{height:0}:host .chat-message-list .chat-history .entry{display:flex}:host .chat-message-list .chat-history .entry.divider{justify-content:center;background:var(--light-header-bg, #f2f2f2);color:var(--light-header-text, #828688);padding:3px 15px;margin:10px 0;font-size:.833em;font-weight:600;text-transform:uppercase}:host .chat-message-list .chat-history .entry.meta{padding:10px;justify-content:center;text-align:center}:host .chat-message-list .chat-history .entry.meta .bubble{display:inline-block;background:var(--light-header-bg, #f2f2f2);color:var(--light-header-text, #828688);font-size:.833em;padding:3px 30px;margin:0 auto;border-radius:10px}:host .chat-message-list .chat-history .entry.meta .bubble .b{font-weight:700}:host .chat-message-list .chat-history .entry.meta+.meta{padding-top:0}:host .chat-message-list .chat-history .entry.chat{padding:10px 0}:host .chat-message-list .chat-history .entry.chat .chat{display:flex;flex-direction:column}:host .chat-message-list .chat-history .entry.chat .chat .bubble{position:relative;display:inline-block;padding:8px;font-size:1em;border-radius:5px}:host .chat-message-list .chat-history .entry.chat .chat .bubble .from{margin:0 0 5px 0}:host .chat-message-list .chat-history .entry.chat .chat .bubble .content{word-break:break-word;white-space:pre-line;word-wrap:break-word}:host .chat-message-list .chat-history .entry.chat .chat .bubble .content a{color:inherit}:host .chat-message-list .chat-history .entry.chat .chat .bubble.emojis-only .content{font-size:36px;line-height:1em}:host .chat-message-list .chat-history .entry.chat .chat .bubble:after{content:"";display:block;position:absolute;top:12px;width:0;height:0}:host .chat-message-list .chat-history .entry.chat .chat .meta{display:flex;font-size:.833em;font-weight:600;padding:2px 5px;color:var(--subtle-font-color, #828688)}:host .chat-message-list .chat-history .entry.chat .chat .meta .chat-status{margin:0 3px 0 0}:host .chat-message-list .chat-history .entry.chat.sent{justify-content:flex-end}:host .chat-message-list .chat-history .entry.chat.sent .chat{margin:0 15px 0 50px;align-items:flex-end}:host .chat-message-list .chat-history .entry.chat.sent .chat .bubble{background:var(--chat-message-bubble-sent-bg, #22b1c8);color:var(--chat-message-bubble-sent-text, #fff)}:host .chat-message-list .chat-history .entry.chat.sent .chat .bubble:after{right:0;margin:0 -12px 0 0;border-top:5px solid transparent;border-bottom:5px solid transparent;border-left:15px solid var(--chat-message-bubble-sent-bg, #22b1c8)}:host .chat-message-list .chat-history .entry.chat.sent .meta{justify-content:flex-end;align-items:center}:host .chat-message-list .chat-history .entry.chat.received{justify-content:flex-start}:host .chat-message-list .chat-history .entry.chat.received .chat{margin:0 50px 0 15px}:host .chat-message-list .chat-history .entry.chat.received .chat .bubble{background:var(--chat-message-bubble-received-bg, #ebebeb);color:var(--chat-message-bubble-received-text, #212121)}:host .chat-message-list .chat-history .entry.chat.received .chat .bubble .from{color:var(--chat-message-bubble-received-from, #22b1c8)}:host .chat-message-list .chat-history .entry.chat.received .chat .bubble:after{left:0;margin:0 0 0 -12px;border-top:5px solid transparent;border-bottom:5px solid transparent;border-right:15px solid var(--chat-message-bubble-received-bg, #ebebeb)}:host .chat-message-list .chat-history.stop-scroll{overflow:hidden}:host .chat-message-list .chat-scroll-to-bottom{position:absolute;right:0;bottom:65px;display:flex;align-items:center;padding:3px;background:#ffffff;border:var(--secondary-border, #f2f2f2);border-width:1px 0 1px 1px;border-radius:50px 0 0 50px;transform:translateX(100%);cursor:pointer}:host .chat-message-list .chat-scroll-to-bottom .icon{width:34px;height:34px;display:flex;justify-content:center;align-items:center;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border:1px solid var(--primary-font-color, #fff);border-radius:50%}:host .chat-message-list .chat-scroll-to-bottom .number{margin:0 3px;color:var(--primary-color, #22b1c8);font-size:.833em;font-weight:600}:host .chat-message-list .chat-scroll-to-bottom.animate{transition:transform 0.3s ease-out}:host .chat-message-list .chat-scroll-to-bottom.visible{transform:translateX(0)}:host .chat-message-list .pager-ui{background:var(--default-bg-color-light, #F1F1F1);color:var(--default-bg-color-light-font, --default-font-color);flex:1;display:flex;flex-direction:column}:host .chat-message-list .pager-ui .image-thumbnail{padding:20px 20px 0;display:flex;height:25vh;width:50%;align-self:center}:host .chat-message-list .pager-ui .description-text{font-size:1.333em;padding:20px 10px 0 25px;margin-bottom:auto}:host .chat-message-list .pager-ui .meta{display:flex;padding:2px 5px;background:var(--light-header-bg, #ebebeb);color:var(--light-header-text, #828688);padding:3px 30px;margin:0 15% 40px;border-radius:10px;justify-content:center}:host .chat-message-list .pager-ui .meta span{text-align:center}:host .chat-message-list .footer{flex:none;display:flex;align-items:flex-end;padding:10px;background:var(--secondary-color, #f2f2f2);border-top:var(--secondary-border, 1px solid #ddd)}:host .chat-message-list .footer .action{display:flex;justify-content:center;align-items:center;flex:none;width:32px;height:32px;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border-radius:50%;cursor:pointer}:host .chat-message-list .footer .action.disabled{background:var(--subtle-font-color, #828688);cursor:default}:host .chat-message-list .footer .textbox{position:relative;flex:1 1 auto;margin:0 5px;background:transparent}:host .chat-message-list .footer .textbox .media{display:flex;flex-direction:row;justify-content:center;padding:7px 10px;border-bottom:var(--secondary-border, 1px solid #ddd)}:host .chat-message-list .footer .textbox .media .media-item{position:relative}:host .chat-message-list .footer .textbox .media .media-item .media-image{max-height:75px;display:block}:host .chat-message-list .footer .textbox .media .media-item .remove{position:absolute;top:5px;right:5px;color:#ffffff;background:#212121;border-radius:50%;cursor:pointer}:host .chat-message-list .footer .textbox .error{position:absolute;bottom:8px;right:5px;color:var(--conversation-has-error-color, #d93247)}:host .chat-message-list .footer .textbox.disabled{background:var(--secondary-color, #f2f2f2)}
        `;
    }
    generateComponentMarkup() {
        const me = this.conversation.participants.find(x => utils_1.jidsMatch(x.jid, this.layer.getCurrentUserJid()));
        // Force Pager UI if this has been specified
        if (![models_1.ChatRole.Owner].includes(me.role) && this._config.usePagerUI) {
            return (window.__CTRender("div", { class: "chat-message-list" },
                this._renderHeader(),
                this._renderPagerUI()));
        }
        // Otherwise, just render the normal chat message list
        return (window.__CTRender("div", { class: "chat-message-list" },
            this._renderHeader(),
            window.__CTRender("div", { class: "chat-message-list desktop" },
                ((this.conversation.attachments
                    && this.conversation.attachments.length) ||
                    this.conversation.description)
                    && this._renderPriorityDescription(),
                this._config.chatAvailable
                    ? this._renderChatEntries()
                    : window.__CTRender(ctcl_response_view_1.CTCLResponseView, { conversation: this.conversation })),
            this._config.chatAvailable && this._renderScrollToBottom(),
            this._renderFooter()));
    }
    _renderHeader() {
        let heading = "";
        let subHeading = this._config.descriptionAtTop;
        if (!this._config.namedSettings) {
            if (this.conversation.participants.length === 1) {
                const me = this.layer.getCurrentUser();
                heading = utils_1.formatUserName(me, utils_1.NameFormat.PREFIX_FIRST_LAST);
                subHeading = this.translateI18nItem(I18nKeys.SELF_CONVERSATION);
            }
            else if (this.conversation.participants.length === 2) {
                const currentUserJid = this.layer.getCurrentUserJid();
                const otherParticipant = this.conversation.participants.find(x => !utils_1.jidsMatch(x.jid, currentUserJid));
                const contact = this._userLookup.get(otherParticipant.jid);
                heading = utils_1.formatUserName(contact, utils_1.NameFormat.PREFIX_FIRST_LAST) || " ";
                subHeading = this.translateI18nItem(I18nKeys.DIRECT_CONVERSATION);
            }
            else if (this.conversation.participants.length > 2) {
                heading = this.translateI18nItem(I18nKeys.DIRECT_CONVERSATION);
                subHeading = this.translateI18nItem(I18nKeys.CONTACTS_IN_CONVERSATION).replace("{{number}}", (this.conversation.participants.length - 1).toString());
            }
        }
        else {
            heading = this.conversation.subject || this._config.name;
        }
        const backIcon = this.conversation.isProvisional || this.conversation.hideBefore
            ? models_1.Icons.COMMON.CircleCross
            : models_1.Icons.COMMON.ChevronLeft;
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header", backgroundColor: this._config.colorCode },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: backIcon, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, heading),
            window.__CTRender("div", { slot: "sub-heading" }, subHeading),
            window.__CTRender("div", { slot: "right-action" }, this._renderRightAction())));
    }
    _renderRightAction() {
        return this.conversation.type === Models_1.ConversationType.Direct
            ? this._renderInfo()
            : this._renderMenu();
    }
    _renderInfo() {
        if (this.conversation.participants.length === 1)
            return null; // don't show info icon for direct conversation with self
        const menuItems = [
            new components_1.MenuItem(this.translateI18nItem(I18nKeys.INFO), this._viewInfo)
        ];
        if (this.conversation.hideBefore) {
            return window.__CTRender(components_1.CTMenu, { menuItems: menuItems });
        }
        if ((!this.conversation.isProvisional || this.conversation.hideBefore === 0) && this._config.participantCanDelete) {
            menuItems.push(new components_1.MenuItem(this.translateI18nItem(I18nKeys.DELETE), this._deleteDirect));
        }
        if (menuItems.length > 0) {
            return window.__CTRender(components_1.CTMenu, { menuItems: menuItems });
        }
        else {
            return null;
        }
    }
    _renderMenu() {
        const currentUserJid = this.layer.getCurrentUserJid();
        const me = this.conversation.participants.find(x => utils_1.jidsMatch(x.jid, currentUserJid));
        if (!me)
            return null;
        const canEditInfo = [models_1.ChatRole.Owner].includes(me.role) && this._config.ownerCanEditAfterSend;
        const canLeave = this._config.participantCanLeave;
        const canEnd = [models_1.ChatRole.Owner].includes(me.role) && this._config.ownerCanCloseEarly;
        const menuItems = [];
        if (canEditInfo) {
            menuItems.push(new components_1.MenuItem(this.translateI18nItem(I18nKeys.EDIT_INFO), this._editInfo.bind(this)));
        }
        else {
            menuItems.push(new components_1.MenuItem(this.translateI18nItem(I18nKeys.INFO), this._viewInfo));
        }
        if (this._config.alert && [models_1.ChatRole.Owner].includes(me.role) && this._config.chatAvailable) {
            menuItems.push(new components_1.MenuItem(this.translateI18nItem(I18nKeys.RESPONSES), this._openResponses, false));
        }
        if (canLeave) {
            menuItems.push(new components_1.MenuItem(this.translateI18nItem(I18nKeys.LEAVE), this._leave.bind(this), !this.isOnline));
        }
        if (canEnd) {
            menuItems.push(new components_1.MenuItem(this.translateI18nItem(I18nKeys.END), this._end.bind(this), !this.isOnline));
        }
        if (menuItems.length > 0) {
            return window.__CTRender(components_1.CTMenu, { menuItems: menuItems });
        }
        return null;
    }
    _renderChatEntries() {
        const lastChatEntry = this._processedChatEntries[this._processedChatEntries.length - 1];
        const lastChatEntryId = lastChatEntry && lastChatEntry.id || "";
        return (window.__CTRender("div", { id: "chat-history", class: "chat-history" },
            this.conversation.isProvisional && this._renderProvisionalMessage(),
            !this.conversation.isProvisional && this.mightHaveMore && this._renderFetchMore(),
            !this.conversation.isProvisional && this.visibleChatEntries.map(x => {
                const isLastEntry = x.id === lastChatEntryId;
                return this._renderEntry(x, isLastEntry);
            })));
    }
    _renderFetchMore() {
        const cssClasses = [
            "fetch-more"
        ];
        if (this.isFetchingMore)
            cssClasses.push("fetching");
        if (this.noMoreToFetch)
            cssClasses.push("no-more");
        return (window.__CTRender("div", { id: "fetch-more", key: "fetch-more", class: cssClasses.join(" ") },
            !!this.fetchError && (window.__CTRender("div", { class: "error" },
                window.__CTRender(components_1.CTIcon, { class: "icon", width: "16", height: "16", icon: models_1.Icons.COMMON.AlertWarning }),
                this.fetchError)),
            !this.fetchError && !this.noMoreToFetch && !this.isFetchingMore && this.translateI18nItem(I18nKeys.SCROLL_TO_TOP_FOR_MORE),
            this.isFetchingMore && window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }),
            this.noMoreToFetch && this.translateI18nItem(I18nKeys.AT_START)));
    }
    _renderProvisionalMessage() {
        return (window.__CTRender("div", { class: "entry meta" },
            window.__CTRender("div", { class: "bubble" }, this.translateI18nItem(I18nKeys.PROVISIONAL_MESSAGE))));
    }
    _renderEntry(entry, isLastEntry) {
        const cssClasses = [
            "entry",
            entry.type.toString()
        ];
        if (entry.type === models_1.ChatEntryType.Chat)
            cssClasses.push(entry.mine ? "sent" : "received");
        const domId = this._generateDomIdFromEntryId(entry.id);
        return (window.__CTRender("div", { id: domId, key: entry.id, class: cssClasses.join(" ") },
            (entry.type === models_1.ChatEntryType.Meta) && this._renderMetaMessage(entry),
            (entry.type === models_1.ChatEntryType.Chat) && this._renderChatMessage(entry, isLastEntry),
            (entry.type === models_1.ChatEntryType.Divider) && this._renderDivider(entry)));
    }
    _renderDivider(entry) {
        return (window.__CTRender("span", null, utils_1.getFriendlyDate(entry.date, this)));
    }
    _renderChatMessage(message, isLastEntry) {
        const bubbleCssClasses = ["bubble"];
        if (this._isOnlyEmojis(message.body))
            bubbleCssClasses.push("emojis-only");
        const from = this._userLookup.get(message.from);
        return (window.__CTRender("div", { class: "chat" },
            window.__CTRender("div", { class: bubbleCssClasses.join(" ") },
                (message.mine === false) && (window.__CTRender("div", { class: "from" }, utils_1.formatUserName(from, utils_1.NameFormat.PREFIX_FIRST_LAST) || message.from)),
                (message.attachments && message.attachments.length > 0) && this._renderMedia(message, message.attachments[0], isLastEntry),
                (typeof (message.body) === "string" && message.body.length > 0) && (window.__CTRender("div", { class: "content" }, this.renderHtml(renderUtils_1.linkifyText(message.body.trim()), this._generateDomIdFromEntryId(message.id))))),
            window.__CTRender("div", { class: "meta" },
                window.__CTRender("div", { class: "chat-status" }, this._renderChatMessageStatus(message)),
                window.__CTRender("div", { class: "chat-time" },
                    window.__CTRender("span", { class: "hour-min" }, utils_1.getFriendlyTime(message.date))))));
    }
    _renderChatMessageStatus(message) {
        if (!this._shouldUseChatMarkers())
            return null;
        if (!message.mine)
            return null;
        const received = message.receivedBy && message.receivedBy.length > 0;
        const read = message.readBy && message.readBy.length > 0;
        if (read) {
            return window.__CTRender(components_1.CTIcon, { width: "10", height: "10", icon: models_1.Icons.COMMON.Tick });
        }
        else if (received) {
            return window.__CTRender(components_1.CTIcon, { width: "10", height: "10", icon: models_1.Icons.COMMON.TickHollow });
        }
        else {
            return null;
        }
    }
    _renderMetaMessage(activity) {
        const currentUserJid = this.layer.getCurrentUserJid();
        const me = this.conversation.participants.find(x => utils_1.jidsMatch(x.jid, currentUserJid));
        // Only show acknowledgements when the configuration allows OR the user is an owner.
        if (![models_1.ChatRole.Owner].includes(me.role) &&
            this._config.participantAlertResponsesVisible === false &&
            activity.instigator !== currentUserJid &&
            // tslint:disable-next-line no-any
            activity.action === Models_1.ChatMetaActivityType.ACK) {
            return null;
        }
        const metaActivitySummaryHtml = ChatUtils_1.getChatMetaActivitySummaryText(activity, this._userLookup, currentUserJid, this, true);
        return (window.__CTRender("div", { class: "bubble" }, this.renderHtml(metaActivitySummaryHtml, this._generateDomIdFromEntryId(activity.id))));
    }
    _renderMedia(chatMessage, attachment, isLastEntry) {
        // const mediaSrc: string = this._getAttachmentSrc(attachment);
        return (window.__CTRender("div", null,
            window.__CTRender(ct_cl_thumbnail_1.CTCLThumbnail, { chatMessage: chatMessage, attachment: attachment, isLastEntry: isLastEntry })));
    }
    _renderScrollToBottom() {
        if (!this.conversation)
            return null;
        if (this.conversation.isProvisional === true)
            return null;
        if (this._rawChatEntries.length === 0)
            return null;
        this.onRenderComplete(() => {
            if (!this._chatScrollToBottom)
                return;
            this._chatScrollToBottom.classList.add("animate");
        }, true);
        return (window.__CTRender("div", { id: "chat-scroll-to-bottom", class: "chat-scroll-to-bottom", onClick: () => this._scrollToBottom(true) },
            window.__CTRender("div", { class: "icon" },
                window.__CTRender(components_1.CTIcon, { icon: Models_1.Icons.UI.ScrollToBottom, width: 16, height: 16 })),
            window.__CTRender("div", { class: "number" }, this._newNotificationsCount)));
    }
    _multilineEllipsis(lines) {
        if (!this._description)
            return;
        clamp_1.clamp(this._description, { clamp: lines });
    }
    _calcLongDescription() {
        if (!this._description)
            return;
        // The height of the description element will be <= 60 px if only displaying two lines
        this._description.classList.remove("collapsed");
        this.hasLongDescription = (this._description.clientHeight > 60);
        this.forceRedraw();
    }
    _renderPriorityDescription() {
        const audioAttachment = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.AUDIO);
        const imageAttachment = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.IMAGE);
        return (window.__CTRender("div", { class: "description-container" },
            audioAttachment && (window.__CTRender("div", { class: "audio-attachment" },
                window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: audioAttachment.local || audioAttachment.path, type: Models_1.SupportedAttachmentType.AUDIO, conversationId: this.conversation.id, preventRemoteStart: true }))),
            window.__CTRender("div", { class: "priority-description" },
                imageAttachment && (window.__CTRender("div", { class: "image-thumbnail" },
                    window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: imageAttachment.local || imageAttachment.path, type: Models_1.SupportedAttachmentType.IMAGE, allowOpenImageInFullScreen: this._config.allowOpenInFullScreen, conversationId: this.conversation.id }))),
                window.__CTRender("div", { id: "description-text", class: "description-text" }, this.conversation.description),
                this.hasLongDescription && (window.__CTRender("div", { class: "expander" },
                    window.__CTRender(components_1.CTIcon, { id: "priority-description-collapsed-icon", class: "hidden", width: "16", height: "16", icon: models_1.Icons.COMMON.ChevronDown, onClick: (e) => this._togglePriorityDescriptionExpansion() }),
                    window.__CTRender(components_1.CTIcon, { id: "priority-description-expanded-icon", width: "16", height: "16", icon: models_1.Icons.COMMON.ChevronUp, onClick: (e) => this._togglePriorityDescriptionExpansion() }))))));
    }
    _renderFooter() {
        // Disable chat responses entirely if the conversation is configured for this.
        // Mostly used for page style conversations right now.
        if (this.conversation.disallowReply || this._config.chatAvailable === false)
            return null;
        const draftMessageBody = this._draft && this._draft.body || "";
        const draftError = this._draft && this._draft.error === true;
        const attachButtonCssClasses = [
            "action",
            "attach"
        ];
        const textboxContainerCssClasses = [
            "textbox"
        ];
        const sendButtonCssClasses = [
            "action",
            "send"
        ];
        if (this.sendButtonDisabled || !this.isOnline)
            sendButtonCssClasses.push("disabled");
        if (this.sending) {
            attachButtonCssClasses.push("disabled");
            textboxContainerCssClasses.push("disabled");
        }
        const showError = draftError || this.sendError;
        return (window.__CTRender("div", { class: "footer" },
            this._config.canSendAttachmentsWithinConversation && (window.__CTRender("div", { class: attachButtonCssClasses.join(" "), onClick: this._attachMedia.bind(this) },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Attachment }))),
            window.__CTRender("div", { class: textboxContainerCssClasses.join(" ") },
                this.media && (this.media.length > 0) && (window.__CTRender("div", { class: "media" }, this.media.map(x => this._renderDraftMedia(x)))),
                window.__CTRender(components_1.CTGrowingTextbox, { id: "message", key: "message", value: draftMessageBody, placeholder: this.translateI18nItem(I18nKeys.MESSAGE_PLACEHOLDER), maxHeight: 200, maxLength: this._maxMessageLength, transparent: true, disabled: this.sending, onFocus: this._onFocusMessage.bind(this), onChange: this._onMessageChanged.bind(this), onSubmit: this._sendMessage.bind(this) }),
                showError && (window.__CTRender("div", { class: "error" },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Error })))),
            window.__CTRender("div", { class: sendButtonCssClasses.join(" "), onClick: this._sendMessage.bind(this) },
                !this.sending && window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.SendMessage }),
                this.sending && window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }))));
    }
    _renderDraftMedia(data) {
        const imageSrc = this._getDraftAttachmentSrc(data);
        return (window.__CTRender("div", { class: "media-item" },
            window.__CTRender("img", { class: "media-image", src: imageSrc }),
            !this.sending && (window.__CTRender("div", { class: "remove" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.CircleCross, onClick: e => this._removeMediaItem(e) })))));
    }
    _renderPagerUI() {
        const audioAttachment = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.AUDIO);
        const imageAttachment = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.IMAGE);
        const message = this.conversation.acknowledgements.find(x => x.jid === this.layer.getCurrentUserJid());
        return (window.__CTRender("div", { class: "pager-ui" },
            audioAttachment && (window.__CTRender("div", { class: "audio-attachment" },
                window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: audioAttachment.local || audioAttachment.path, type: Models_1.SupportedAttachmentType.AUDIO, conversationId: this.conversation.id, preventRemoteStart: true }))),
            imageAttachment && (window.__CTRender("div", { class: "image-thumbnail" },
                window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: imageAttachment.local || audioAttachment.path, type: Models_1.SupportedAttachmentType.IMAGE, allowOpenImageInFullScreen: this._config.allowOpenInFullScreen, conversationId: this.conversation.id }))),
            window.__CTRender("div", { id: "description-text", class: "description-text" }, this.conversation.description),
            message && (window.__CTRender("div", { class: "meta" },
                window.__CTRender("span", null,
                    "You responded with: ",
                    window.__CTRender("strong", null, message.value),
                    " at ",
                    window.__CTRender("strong", { class: "hour-min" }, utils_1.getFriendlyTime(parseInt("" + message.ts))))))));
    }
    _onMessageChanged() {
        return __awaiter(this, void 0, void 0, function* () {
            this._updateDraft();
            this._updateSendButton();
        });
    }
    _onFocusMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            this.sendError = false;
            // Scroll chat list to the bottom if the keyboard is opened on Android devices and the list is already
            // close to the bottom anyways.
            if (utils_2.isAndroid() && (this._chatListScrollable.scrollTop > (this._chatListScrollable.scrollHeight / 2))) {
                // This needs to be deferred to give the OS time to open the keyboard
                setTimeout(() => this._scrollToBottom(true), 500);
            }
            this._updateDraft();
        });
    }
    _removeMediaItem(event) {
        event.stopPropagation();
        this._removeMedia(true);
    }
    _sendMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOnline)
                return;
            if (this.sending)
                return;
            if (this.sendButtonDisabled)
                return;
            if (!this._messageTextbox)
                return;
            this.sendError = false;
            this.sending = true;
            try {
                if (this.conversation.isProvisional) {
                    this._pendingConversationId = yield this.layer.createConversationFromProvisional(this.conversation);
                    this._pendingDraft = this._draft;
                }
                else {
                    // TODO:LR: Shouldn't need to use the draft object here but there appears to be a bug which clears the messageTextbox value just before
                    // sending the first direct conversation message
                    const text = (this._draft && this._draft.body) ? this._draft.body : this._messageTextbox.getValue();
                    const attachmentPath = this.media.length && this.media[0].path || null;
                    const attachments = attachmentPath && [attachmentPath] || [];
                    const useChatMarkers = this._shouldUseChatMarkers();
                    const chatMessage = yield this.layer.sendConversationMessage(this.conversation, text, attachments, useChatMarkers);
                    this._appendChatEntry(chatMessage, true);
                    this._messageTextbox.clear();
                    yield this._removeMedia(false);
                    this._clearDraft();
                    this._updateSendButton();
                    this.sending = false;
                    this._autoFocusMessageTextboxOnDesktop();
                }
            }
            catch (ex) {
                const title = this.translateI18nItem(I18nKeys.SEND_ERROR);
                const message = this.translateI18nItem(I18nKeys.SEND_ERROR);
                this.layer.error(title, message, ex);
                if (ex.message && ex.message._id) {
                    this.layer.deleteConversationMessageById(ex.message._id, false);
                }
                this.sendError = true;
                this.sending = false;
                this._updateDraft();
            }
        });
    }
    _back() {
        return __awaiter(this, void 0, void 0, function* () {
            this.emitEvent(Events_1.ChatEvents.RemotelyStopAudioPlayer);
            yield this._removeMedia(true);
            yield this._saveDraft();
            yield this.layer.clearCurrentConversation();
            // On exit purge the current conversation.
            this.layer.purgeConversation(this.conversation);
            this.emitComponentEvent("go-back");
        });
    }
    _editInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._saveDraft();
            this.emitComponentEvent("go-info");
        });
    }
    _leave() {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.COMFIRM_LEAVE))) {
                const success = yield this.layer.leaveConversation(this.conversation);
                if (success) {
                    this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
                    this.addListener(Events_1.ChatEvents.ConversationClosed, () => __awaiter(this, void 0, void 0, function* () {
                        this.dismissWaitingMessage();
                        this._clearDraft();
                        yield this.layer.clearCurrentConversation();
                        this.emitComponentEvent("go-leave");
                    }), { onceOnly: true });
                }
            }
        });
    }
    _end() {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.COMFIRM_END))) {
                const success = yield this.layer.endConversation(this.conversation);
                if (success) {
                    this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
                    this.addListener(Events_1.ChatEvents.ConversationClosed, () => __awaiter(this, void 0, void 0, function* () {
                        this.dismissWaitingMessage();
                        this._clearDraft();
                        yield this.layer.clearCurrentConversation();
                        this.emitComponentEvent("go-end");
                    }), { onceOnly: true });
                }
            }
        });
    }
    // === Private functions === //
    _refreshUserLookup() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._userLookup.populate([this.conversation], this._rawChatEntries);
        });
    }
    _detectOverscrollSupport() {
        const div = document.createElement("div");
        document.documentElement.appendChild(div);
        // tslint:disable-next-line no-any
        div.style.WebkitOverflowScrolling = "touch";
        this._supportsOverscroll = "getComputedStyle" in window && window.getComputedStyle(div)["-webkit-overflow-scrolling"] === "touch";
        document.documentElement.removeChild(div);
    }
    _getDomNodes() {
        const root = this.shadowRoot;
        this._chatListScrollable = root.querySelector("#chat-history");
        this._chatListFetchMore = root.querySelector("#fetch-more");
        this._chatScrollToBottom = root.querySelector("#chat-scroll-to-bottom");
        this._messageTextbox = root.querySelector("#message");
        this._description = root.querySelector("#description-text");
    }
    _generateDomIdFromEntryId(id) {
        return `entry_${(id || "").replace(/[:.]/g, "_")}`;
    }
    _setupScrollWatcher() {
        if (!this._chatListScrollable)
            return;
        setTimeout(() => {
            this._chatListScrollable.removeEventListener("scroll", this._onScroll);
            this._chatListScrollable.addEventListener("scroll", this._onScroll);
        }, 500);
    }
    _stopScroll(position) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._supportsOverscroll)
                return Promise.resolve();
            return new Promise(resolve => {
                this._chatListScrollable.classList.add("stop-scroll");
                this._chatListScrollable.scrollTop = position;
                setTimeout(() => {
                    this._chatListScrollable.classList.remove("stop-scroll");
                    resolve();
                }, 0);
            });
        });
    }
    _scrollToBottom(animate) {
        return __awaiter(this, void 0, void 0, function* () {
            const processedChatEntriesLength = this._processedChatEntries.length;
            const lastProcessedChatEntryIdx = processedChatEntriesLength - 1;
            if (this._endIdx < lastProcessedChatEntryIdx) {
                if (lastProcessedChatEntryIdx - this._endIdx === 1) {
                    // there has been one single message added - we can deal with this
                    this._endIdx += 1;
                    this._calculateStartIdxBasedOnEndIdx();
                    this._updateVisibleChatEntries()
                        .then(() => this._scrollToBottom(animate));
                    return;
                }
                else {
                    this._setMostRecentChatEntriesVisible();
                    return;
                }
            }
            if (!this._chatListScrollable)
                return;
            this._hideScrollToBottom();
            const scrollCurrent = this._chatListScrollable.scrollTop;
            const scrollHeight = this._chatListScrollable.scrollHeight;
            const visibleHeight = this._chatListScrollable.clientHeight;
            const scrollTo = scrollHeight - visibleHeight;
            if (scrollCurrent >= scrollTo)
                return Promise.resolve();
            if (animate) {
                const duration = 300;
                return new Promise(resolve => {
                    const start = this._chatListScrollable.scrollTop;
                    const change = scrollTo - start;
                    const increment = 20;
                    let currentTime = 0;
                    const easeInOutQuad = (t, b, c, d) => {
                        t /= d / 2;
                        if (t < 1)
                            return c / 2 * t * t + b;
                        t--;
                        return -c / 2 * (t * (t - 2) - 1) + b;
                    };
                    const animateScroll = () => {
                        currentTime += increment;
                        this._chatListScrollable.scrollTop = easeInOutQuad(currentTime, start, change, duration);
                        if (currentTime < duration) {
                            setTimeout(animateScroll, increment);
                        }
                        else {
                            resolve();
                        }
                    };
                    animateScroll();
                });
            }
            else {
                this._chatListScrollable.scrollTop = scrollTo;
                return Promise.resolve();
            }
        });
    }
    _handleScrollAtTop() {
        if (this.isFetchingMore)
            return;
        if (!this.visibleChatEntries || this.visibleChatEntries.length === 0)
            return;
        const currentFirst = this.visibleChatEntries[0];
        const currentFirstIdx = this._processedChatEntries.findIndex(x => x.id === currentFirst.id);
        const isFirstProcessedChatEntry = currentFirstIdx === 0;
        if (isFirstProcessedChatEntry && !this.noMoreToFetch) {
            this._fetchMoreChatEntries();
            return;
        }
        this._offsetVisibleIndexes(-this._visibleChatEntryBlockSize);
        this._processIndexChanges(currentFirst.id);
    }
    _handleScrollAtBottom() {
        if (!this.visibleChatEntries || this.visibleChatEntries.length === 0)
            return;
        const currentLast = this.visibleChatEntries[this.visibleChatEntries.length - 1];
        const currentLastIdx = this._processedChatEntries.findIndex(x => x.id === currentLast.id);
        const isLastProcessedChatEntry = currentLastIdx === (this._processedChatEntries.length - 1);
        if (isLastProcessedChatEntry) {
            this._hideScrollToBottom();
            this._suppressScrollHandler = false;
            return;
        }
        this._offsetVisibleIndexes(this._visibleChatEntryBlockSize);
        this._processIndexChanges(currentLast.id);
    }
    _offsetVisibleIndexes(offsetAmount) {
        this._startIdx = Math.max(0, this._startIdx + offsetAmount);
        this._calculateEndIdxBasedOnStartIdx();
    }
    _calculateStartIdxBasedOnEndIdx() {
        this._startIdx = Math.max(0, this._endIdx - (this._visibleChatEntryBlockSize * 3));
    }
    _calculateEndIdxBasedOnStartIdx() {
        this._endIdx = Math.min(this._processedChatEntries.length - 1, this._startIdx + (this._visibleChatEntryBlockSize * 3));
    }
    _processIndexChanges(idOfMessageToRetainInView) {
        if (!this._chatListScrollable)
            return;
        const previousBoundsTop = this._getMessageBoundsTop(idOfMessageToRetainInView);
        this._updateVisibleChatEntries()
            .then(() => {
            const newTop = this._getMessageTop(idOfMessageToRetainInView);
            this._chatListScrollable.scrollTop = newTop - previousBoundsTop;
            this._suppressScrollHandler = false;
        });
    }
    _getMessageTop(id) {
        const domId = this._generateDomIdFromEntryId(id);
        const message = this.shadowRoot.querySelector(`#${domId}`);
        return message && message.offsetTop || 0;
    }
    _getMessageBoundsTop(id) {
        const domId = this._generateDomIdFromEntryId(id);
        const containerBoundsTop = this._chatListScrollable.getBoundingClientRect().top || 0;
        const message = this.shadowRoot.querySelector(`#${domId}`);
        const messageBoundsTop = message && message.getBoundingClientRect().top || 0;
        return messageBoundsTop - containerBoundsTop;
    }
    _resetForConversationChange() {
        return __awaiter(this, void 0, void 0, function* () {
            this._rawChatEntries = [];
            this._processedChatEntries = [];
            this.visibleChatEntries = [];
            this.fetchError = null;
            this.noMoreToFetch = false;
            this.mightHaveMore = true;
        });
    }
    _fetchMoreChatEntries(initial = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.noMoreToFetch)
                return;
            if (!this._config.usePagerUI && !this._chatListScrollable)
                return;
            // Ensures that we are debouncing the event to signal message processing is over
            clearTimeout(this.layer.messageQueueProcessorDebounce);
            this.isFetchingMore = true;
            this.fetchError = null;
            const lastEntry = this._rawChatEntries && this._rawChatEntries[0] || null;
            this._isInitialFetch = initial || (lastEntry === null);
            try {
                let fetchedEntries = yield this.layer.fetchConversationEntries(this.conversation, lastEntry, this._batchSize || 10);
                if (fetchedEntries.length) {
                    fetchedEntries = fetchedEntries.filter(x => !x.placeholder);
                    if (this.isOnline) {
                        fetchedEntries.forEach(x => this.layer.markChatEntryRead(x));
                    }
                    yield this._updateChatEntries([
                        ...fetchedEntries,
                        ...this._rawChatEntries
                    ]);
                    if (this._isInitialFetch) {
                        this._setMostRecentChatEntriesVisible();
                    }
                    else {
                        this._startIdx = 0;
                        this._calculateEndIdxBasedOnStartIdx();
                        this._processIndexChanges(lastEntry.id);
                    }
                    this.isFetchingMore = false;
                    if (this._isInitialFetch && this.conversation.hasUnread) {
                        this.conversation.hasUnread = false;
                        yield this.layer.updateConversation(this.conversation);
                    }
                }
                else {
                    this.isFetchingMore = false;
                    this.noMoreToFetch = true;
                    this._suppressScrollHandler = false;
                }
                if (this._isInitialFetch && fetchedEntries.length < (this._batchSize || Number.MAX_VALUE)) {
                    this.mightHaveMore = false;
                }
            }
            catch (ex) {
                if (ex instanceof errors_1.NotConnectedError) {
                    this.fetchError = this.translateI18nItem(I18nKeys.FETCH_ERROR_NOT_ONLINE);
                    this.isFetchingMore = false;
                }
                else {
                    throw ex;
                }
            }
        });
    }
    _setMostRecentChatEntriesVisible() {
        this._endIdx = this._processedChatEntries.length - 1;
        this._calculateStartIdxBasedOnEndIdx();
        this._updateVisibleChatEntries()
            .then(() => this._scrollToBottom(false));
    }
    _updateVisibleChatEntries() {
        return new Promise(resolve => {
            this._startIdx = Math.max(this._startIdx, 0);
            this._endIdx = Math.min(this._endIdx, this._processedChatEntries.length - 1);
            this.visibleChatEntries = this._processedChatEntries.slice(this._startIdx, this._endIdx + 1);
            this.onRenderComplete(() => resolve(), true);
        });
    }
    _updateChatEntries(chatEntries) {
        return __awaiter(this, void 0, void 0, function* () {
            this._rawChatEntries = chatEntries;
            this._processedChatEntries = yield this._generateProcessedChatEntries(chatEntries);
            yield this._refreshUserLookup();
        });
    }
    _updateChatEntry(chatEntry) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundIdx = this._rawChatEntries.findIndex(x => x.id === chatEntry.id);
            if (foundIdx === -1)
                return;
            const newRawChatEntries = this._rawChatEntries.map((x, idx) => (idx === foundIdx) ? chatEntry : x);
            yield this._updateChatEntries(newRawChatEntries);
            yield this._updateVisibleChatEntries();
        });
    }
    _appendChatEntry(chatEntry, wasJustSent = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._rawChatEntries.find(x => x.id === chatEntry.id)) {
                yield this._updateChatEntries([
                    ...this._rawChatEntries,
                    chatEntry
                ]);
                if (this._isNearBottom() || wasJustSent) {
                    yield this._scrollToBottom(true);
                }
                else {
                    this._newNotificationsCount += 1;
                    this._showScrollToBottom();
                }
            }
        });
    }
    _generateProcessedChatEntries(chatEntries) {
        return __awaiter(this, void 0, void 0, function* () {
            // this function injects divider "messages" into the list of chat messages so that date divider UI elements can be added.
            // it also adds the "read" and "received" statuses to the appropriate most recent message of that state (for 1 to 1 conversations only).
            const newChatEntries = [];
            let lastDate = null;
            for (let i = chatEntries.length - 1; i >= 0; i--) {
                const entry = chatEntries[i];
                const thisDate = new Date(entry.date);
                if (lastDate !== null && lastDate.toDateString() !== thisDate.toDateString()) {
                    this._addDivider(newChatEntries, lastDate);
                }
                newChatEntries.unshift(entry);
                lastDate = thisDate;
            }
            // Reorder the entries otherwise messages can be out of order due to just appending message 
            // to the bottom of the list when a new one is sent or recieved
            return newChatEntries.sort((a, b) => a.date - b.date);
        });
    }
    _addDivider(chatEntries, date) {
        const startOfDate = date.setHours(0, 0, 0, 0);
        chatEntries.unshift({
            id: `divider_${startOfDate}`,
            type: models_1.ChatEntryType.Divider,
            date: startOfDate,
            to: this.conversation.roomJid
        });
    }
    _shouldUseChatMarkers() {
        return (this.conversation.type === Models_1.ConversationType.Direct && this.conversation.participants.length === 2);
    }
    _isOnlyEmojis(content) {
        if (!content)
            return false;
        const emojiRegex = "(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|[\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|[\ud83c[\ude32-\ude3a]|[\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])";
        return content.replace(new RegExp(emojiRegex, "g"), "").length === 0;
    }
    _isNearBottom() {
        if (!this._chatListScrollable)
            return;
        const scrollHeight = this._chatListScrollable.scrollHeight;
        const visibleHeight = this._chatListScrollable.clientHeight;
        const scrollBottom = scrollHeight - visibleHeight;
        const scrollCurrent = this._chatListScrollable.scrollTop;
        const tolerance = 100;
        return (scrollBottom - scrollCurrent) <= tolerance;
    }
    _showScrollToBottom() {
        if (!this._chatScrollToBottom)
            return;
        this.onRenderComplete(() => {
            if (this._newNotificationsCount && this._newNotificationsCount > 0) {
                this._chatScrollToBottom.querySelector(".number").textContent = this._newNotificationsCount.toString();
            }
            else {
                this._chatScrollToBottom.querySelector(".number").textContent = "";
            }
        }, true);
        this._chatScrollToBottom.classList.add("visible");
    }
    _hideScrollToBottom() {
        if (!this._chatScrollToBottom)
            return;
        this._chatScrollToBottom.classList.remove("visible");
        this._newNotificationsCount = 0;
        setTimeout(() => {
            const div = this._chatScrollToBottom.querySelector(".number");
            if (div)
                div.textContent = "";
        }, 300);
    }
    _attachMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sending)
                return;
            if (this.media.length > 0) {
                if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.CONFIRM_REPLACE_IMAGE))) {
                    this._doAttachMedia();
                }
            }
            else {
                this._doAttachMedia();
            }
        });
    }
    _doAttachMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.layer.captureOrSelectMedia();
            data.base64 = yield plugins_1.getThumbnail(data.path, 75, 75, 100);
            yield this._removeMedia(true);
            this.media = [data];
            this._updateDraft();
            this._updateSendButton();
        });
    }
    _removeMedia(deleteFile) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.media.length > 0) {
                if (deleteFile) {
                    yield this.layer.cancelMediaSeletion(this.media[0].path);
                }
                this.media = [];
                this._updateDraft();
                this._updateSendButton();
            }
        });
    }
    // private _getAttachmentSrc (attachment: ChatMessageAttachment): string {
    //     if (isDesktop()) return attachment.remote;
    //     return normalizeLocalFilePaths(attachment.local);
    // }
    _getDraftAttachmentSrc(data) {
        if (data.base64) {
            if (data.base64.startsWith("data:") && data.base64.includes("base64"))
                return data.base64;
            else if (data.mimeType)
                return `data:${data.mimeType};base64,${data.base64}`;
        }
        if (data.path)
            return utils_2.normalizeLocalFilePaths(data.path);
        return "";
    }
    _updateDraft() {
        if (!this._messageTextbox)
            return;
        const text = this._messageTextbox.getValue();
        let newDraft = null;
        if (!!text) {
            newDraft = newDraft || {};
            newDraft.body = text;
            newDraft.error = this.sendError;
        }
        if (JSON.stringify(newDraft) !== JSON.stringify(this._draft)) {
            if (newDraft === null) {
                this._draft = null;
            }
            else {
                this._draft = newDraft;
            }
            this._saveDraft(true);
            this.forceRedraw();
        }
    }
    _clearDraft() {
        this._draft = null;
        this._saveDraft();
    }
    _saveDraft(debounce = false) {
        return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._saveDraftTimeout);
            if (debounce) {
                this._saveDraftTimeout = setTimeout(() => {
                    this.layer.saveConversationDraft(this.conversation, this._draft);
                }, 2000);
            }
            else {
                yield this.layer.saveConversationDraft(this.conversation, this._draft);
            }
        });
    }
    _updateSendButton() {
        const hasDraftMessage = (this._draft && typeof (this._draft.body) === "string" && this._draft.body.length > 0);
        this.sendButtonDisabled = !hasDraftMessage && this.media.length === 0;
    }
    _autoFocusMessageTextboxOnDesktop() {
        if (utils_1.isDesktop() && this._config.chatAvailable === true) {
            this.onRenderComplete(() => {
                this.defer(() => {
                    this._messageTextbox.focus();
                });
            }, true);
        }
    }
    _togglePriorityDescriptionExpansion() {
        if (!this._description)
            return;
        const collapsed = this.shadowRoot.querySelector("#priority-description-collapsed-icon");
        const expanded = this.shadowRoot.querySelector("#priority-description-expanded-icon");
        expanded.classList.toggle("hidden");
        collapsed.classList.toggle("hidden");
        this._description.classList.toggle("collapsed");
        if (this._description.classList.contains("collapsed")) {
            this._description.scrollTop = 0;
            this._multilineEllipsis(2);
        }
        else {
            this._multilineEllipsis(false);
        }
    }
}
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLChatMessageList.prototype, "conversation", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTCLChatMessageList.prototype, "visibleChatEntries", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLChatMessageList.prototype, "isFetchingMore", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTCLChatMessageList.prototype, "fetchError", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLChatMessageList.prototype, "mightHaveMore", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLChatMessageList.prototype, "noMoreToFetch", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTCLChatMessageList.prototype, "media", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLChatMessageList.prototype, "sendButtonDisabled", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLChatMessageList.prototype, "sending", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLChatMessageList.prototype, "sendError", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLChatMessageList.prototype, "hasLongDescription", void 0);
exports.CTCLChatMessageList = CTCLChatMessageList;
CTCLChatMessageList.register();


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const Events_1 = __webpack_require__(4);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
const events_1 = __webpack_require__(9);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const ConversationConfigReader_1 = __webpack_require__(14);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["CONTACT_INFORMATION"] = "Contact Information"] = "CONTACT_INFORMATION";
    I18nKeys[I18nKeys["START_DIRECT_CONVERSATION"] = "Direct Conversation"] = "START_DIRECT_CONVERSATION";
    I18nKeys[I18nKeys["USER_TYPE"] = "User Type"] = "USER_TYPE";
    I18nKeys[I18nKeys["ACCESS_RIGHTS"] = "Access Rights"] = "ACCESS_RIGHTS";
    I18nKeys[I18nKeys["PARTICIPANT"] = "Participant"] = "PARTICIPANT";
    I18nKeys[I18nKeys["PARTICIPANT_RIGHTS"] = "Read/Reply"] = "PARTICIPANT_RIGHTS";
    I18nKeys[I18nKeys["ADMIN"] = "Admin"] = "ADMIN";
    I18nKeys[I18nKeys["ADMIN_RIGHTS"] = "Add/Remove Participants"] = "ADMIN_RIGHTS";
    I18nKeys[I18nKeys["OWNER"] = "Owner"] = "OWNER";
    I18nKeys[I18nKeys["OWNER_RIGHTS"] = "Add/Remove/Promote/Demote Anybody"] = "OWNER_RIGHTS";
    I18nKeys[I18nKeys["REMOVE_FROM_CONVERSATION"] = "Remove From This Conversation"] = "REMOVE_FROM_CONVERSATION";
    I18nKeys[I18nKeys["CONFIRM_DIRECT_CONVERSATION"] = "Are you sure you wish to start or resume a direct conversation with this contact?"] = "CONFIRM_DIRECT_CONVERSATION";
    I18nKeys[I18nKeys["CONFIRM_CHANGE_ROLE"] = "Are you sure you wish to change the role of this contact?"] = "CONFIRM_CHANGE_ROLE";
    I18nKeys[I18nKeys["CONFIRM_REMOVE"] = "Are you sure you wish to remove this contact from the conversation?"] = "CONFIRM_REMOVE";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLContactInfoMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLContactInfo, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLContactInfoMetadata._instance = null;
exports.CTCLContactInfoMetadata = CTCLContactInfoMetadata;
class CTCLContactInfo extends Base_1.CTCLComponent {
    constructor() {
        super();
        // === End properties === //
        this._animationDuration = 500;
        this._goChatFunction = null;
        this.setMetadata(CTCLContactInfoMetadata.instance);
    }
    static get is() {
        return "ct-cl-contact-info";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener();
        this.addListener(Events_1.ChatEvents.ConversationParticipantsChanged, (detail) => {
            if (this.conversation && this.conversation.id === detail.conversation.id) {
                this.conversation.participants = detail.conversation.participants;
                this.forceRedraw();
            }
        });
        // Catch the disconnect and remove the waiting message so the user doesn't get stuck if they are disconnected while removing a user
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            if (detail.status === models_1.ConnectionStatus.Disconnected) {
                this.dismissWaitingMessage();
            }
        }, { dontSuppress: true });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex-direction:column;position:fixed;top:0;left:0;height:100%;width:100%;background:#ffffff;font-size:1em;transform:translateY(100%);will-change:transform;z-index:99997}:host .contact-info{flex:1 1 auto;display:flex;flex-direction:column;height:100%;background-color:var(--list-bg);color:var(--default-font-color)}:host .contact-info .header .action{cursor:pointer}:host .contact-info .user-info{display:flex;flex-direction:column;align-items:center;flex:none;padding:10px 40px 20px 40px}:host .contact-info .user-info .avatar{margin:0 0 10px 0}:host .contact-info .user-info .name{font-size:1.333em}:host .contact-info .user-info .job-title{font-size:1.333em;font-weight:300;color:var(--subtle-font-color, #828688)}:host .contact-info .user-info .group{font-size:1.333em;font-weight:300;font-style:italic;color:var(--subtle-font-color, #828688)}:host .contact-info .user-info .telephone{font-size:1.333em;color:var(--primary-color, #22b1c8);text-decoration:none}:host .contact-info .user-info .actions{margin:20px 0 0 0}:host .contact-info .conversation-context{display:flex;flex-direction:column;flex:1 1 auto}:host .contact-info .conversation-context .roles{flex:1 1 auto}:host .contact-info .conversation-context .roles .row{display:flex;align-items:center;border-bottom:var(--secondary-border, 1px solid #ddd)}:host .contact-info .conversation-context .roles .row .r{margin:0 0 0 auto;text-align:right}:host .contact-info .conversation-context .roles .row.header{flex:none;background:var(--light-header-bg, #f2f2f2);color:var(--light-header-text, #828688);font-size:.833em;font-weight:600;text-transform:uppercase;padding:7px 20px}:host .contact-info .conversation-context .roles .row.role{padding:10px 20px;cursor:pointer}:host .contact-info .conversation-context .roles .row.role .l{position:relative;padding:0 0 0 30px}:host .contact-info .conversation-context .roles .row.role .l .radio{position:absolute;display:flex;justify-content:center;align-items:center;left:0;top:50%;transform:translateY(-50%);width:18px;height:18px;border:2px solid var(--default-font-color, #212121);border-radius:50%}:host .contact-info .conversation-context .roles .row.role .r{font-size:.833em;color:var(--subtle-font-color, #828688)}:host .contact-info .conversation-context .roles .row.disabled{opacity:0.5;cursor:not-allowed}:host .contact-info .conversation-context .roles .row.selected .l .radio:before{content:"";display:block;width:6px;height:6px;background-color:var(--default-font-color, #212121);border-radius:50%}:host .contact-info .conversation-context .footer{flex:none;padding:10px;text-align:center}:host([animate]){transition:transform var(--animation-normal, .5s) ease-out}:host([showing]){transform:translateY(0)}
        `;
    }
    generateComponentMarkup() {
        if (!this.contact)
            return null;
        return (window.__CTRender("div", { class: "contact-info" },
            this._renderHeader(),
            this._renderContactInfo(),
            this.conversation && this._renderConversationContext()));
    }
    _renderHeader() {
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, utils_1.formatUserName(this.contact, utils_1.NameFormat.PREFIX_INITIAL_LAST)),
            window.__CTRender("div", { slot: "sub-heading" }, this.translateI18nItem(I18nKeys.CONTACT_INFORMATION))));
    }
    _renderContactInfo() {
        return (window.__CTRender("div", { class: "user-info" },
            window.__CTRender(components_1.CTUserAvatar, { class: "avatar", user: this.contact, size: 90 }),
            window.__CTRender("div", { class: "name" }, utils_1.formatUserName(this.contact, utils_1.NameFormat.PREFIX_FIRST_LAST)),
            this.contact.jobTitle && (window.__CTRender("div", { class: "job-title" }, this.contact.jobTitle)),
            this.layer.config.roles.enableRoles && this.contact.group && (window.__CTRender("div", { class: "group" }, this.contact.group)),
            this.contact.telephone && (window.__CTRender("a", { class: "telephone", href: `tel:${this.contact.telephone}` }, this.contact.telephone)),
            this.allowStartDirect && (window.__CTRender("div", { class: "actions" },
                window.__CTRender(components_1.CTButton, { type: "secondary", width: "auto", disabled: !this.isOnline, onClick: this._startDirectConversation.bind(this) }, this.translateI18nItem(I18nKeys.START_DIRECT_CONVERSATION))))));
    }
    _renderConversationContext() {
        const participant = this._getParticipant(this.contact.jid);
        if (!participant)
            return null;
        const showParticipantManagement = this._config.namedSettings && this._config.ownerCanEditAfterSend;
        const currentUserJid = this.layer.getCurrentUserJid();
        const currentUserParticipant = this._getParticipant(currentUserJid);
        const currentUserRole = currentUserParticipant.role;
        const canChangeRole = currentUserRole === models_1.ChatRole.Owner;
        const canRemove = currentUserRole === models_1.ChatRole.Owner || (currentUserRole === models_1.ChatRole.Administrator && participant.role === models_1.ChatRole.Participant);
        return (window.__CTRender("div", { class: "conversation-context" },
            showParticipantManagement && (window.__CTRender("div", { class: "roles" },
                window.__CTRender("div", { class: "row header" },
                    window.__CTRender("div", { class: "l" }, this.translateI18nItem(I18nKeys.USER_TYPE)),
                    window.__CTRender("div", { class: "r" }, this.translateI18nItem(I18nKeys.ACCESS_RIGHTS))),
                this._renderRoleType(participant, models_1.ChatRole.Owner, I18nKeys.OWNER, I18nKeys.OWNER_RIGHTS, canChangeRole),
                this._renderRoleType(participant, models_1.ChatRole.Administrator, I18nKeys.ADMIN, I18nKeys.ADMIN_RIGHTS, canChangeRole),
                this._renderRoleType(participant, models_1.ChatRole.Participant, I18nKeys.PARTICIPANT, I18nKeys.PARTICIPANT_RIGHTS, canChangeRole))),
            showParticipantManagement && canRemove && (window.__CTRender("div", { class: "footer" },
                window.__CTRender(components_1.CTButton, { type: "dangerous", width: "auto", disabled: !this.isOnline, onClick: () => this._removeFromConversation(participant) }, this.translateI18nItem(I18nKeys.REMOVE_FROM_CONVERSATION))))));
    }
    _renderRoleType(participant, role, type, rights, enabled) {
        const changeRole = () => {
            if (!enabled)
                return;
            if (role === participant.role)
                return;
            this._changeRole(participant, role);
        };
        const selected = participant.role === role;
        const classes = [
            "row",
            "role"
        ];
        if (!enabled || !this.isOnline)
            classes.push("disabled");
        if (selected)
            classes.push("selected");
        return (window.__CTRender("div", { class: classes.join(" "), onClick: changeRole.bind(this) },
            window.__CTRender("div", { class: "l" },
                window.__CTRender("div", { class: "radio" }),
                this.translateI18nItem(type)),
            window.__CTRender("div", { class: "r" }, this.translateI18nItem(rights))));
    }
    // === Event handlers === //
    _back() {
        this.dismiss();
    }
    _startDirectConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOnline)
                return;
            if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.CONFIRM_DIRECT_CONVERSATION))) {
                const currentUserJid = this.layer.getCurrentUserJid();
                const participants = ChatUtils_1.buildConversationParticipants(null, null, [currentUserJid, this.contact.jid]);
                const existingDirectConversation = yield this.layer.getDirectConversationByParticipants(participants);
                if (existingDirectConversation) {
                    yield this.layer.setCurrentConversation(existingDirectConversation);
                    yield this.dismiss(false);
                    this._callGoChatFunction();
                }
                else {
                    const provisionalConversation = ChatUtils_1.createProvisionalDirectConversation(participants, this.layer.doesDirectConversationExistInConfiguration());
                    yield this.layer.setProvisionalConversation(provisionalConversation);
                    yield this.dismiss(false);
                    this._callGoChatFunction();
                }
            }
        });
    }
    _changeRole(partipant, newRole) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOnline)
                return;
            if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.CONFIRM_CHANGE_ROLE))) {
                yield this.layer.changeParticipantRoleInConversation(this.conversation, partipant, newRole);
            }
        });
    }
    _removeFromConversation(participant) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOnline)
                return;
            if (yield this.requestConfirmation(this.translateI18nItem(I18nKeys.CONFIRM_REMOVE))) {
                const success = yield this.layer.removeParticipantsFromConversation(this.conversation, [participant]);
                if (success)
                    this.dismiss(false);
            }
        });
    }
    // === Public functions === //
    show(contact, context = null, allowStartDirect = true, animate = true, goChatFunction = null) {
        return __awaiter(this, void 0, void 0, function* () {
            this.animate = animate;
            this.contact = contact;
            this.conversation = context;
            this._config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, this.conversation);
            this.showing = true;
            this._goChatFunction = goChatFunction;
            this.allowStartDirect = this.layer.doesDirectConversationExistInConfiguration() ? true : false;
            this.layer.setBackHandler(() => {
                this._back();
            });
            yield utils_1.sleep(animate ? this._animationDuration : 0);
        });
    }
    dismiss(animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.animate = animate;
            this.showing = false;
            this.layer.popBackHandler();
            yield utils_1.sleep(animate ? this._animationDuration : 0);
            this.contact = null;
            this.conversation = null;
            this.allowStartDirect = false;
        });
    }
    // === Private functions === //
    _getParticipant(jid) {
        return this.conversation && this.conversation.participants.find(x => utils_1.jidsMatch(x.jid, jid)) || null;
    }
    _callGoChatFunction() {
        if (typeof (this._goChatFunction) === "function") {
            this._goChatFunction();
        }
        this._goChatFunction = null;
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: true })
], CTCLContactInfo.prototype, "animate", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTCLContactInfo.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLContactInfo.prototype, "contact", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLContactInfo.prototype, "allowStartDirect", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLContactInfo.prototype, "conversation", void 0);
exports.CTCLContactInfo = CTCLContactInfo;
CTCLContactInfo.register();


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const UserLookup_1 = __webpack_require__(26);
const Events_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(2);
const renderUtils_1 = __webpack_require__(8);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const ConversationConfigReader_1 = __webpack_require__(14);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["INFORMATION"] = "Information"] = "INFORMATION";
    I18nKeys[I18nKeys["DIRECT_CONVERSATION"] = "Direct Conversation"] = "DIRECT_CONVERSATION";
    I18nKeys[I18nKeys["NAMED_CONVERSATION"] = "Named Conversation"] = "NAMED_CONVERSATION";
    I18nKeys[I18nKeys["CURRENT_ROLE_ADMINISTRATOR"] = "You are an Admin of this conversation"] = "CURRENT_ROLE_ADMINISTRATOR";
    I18nKeys[I18nKeys["CURRENT_ROLE_OWNER"] = "You are an Owner of this conversation"] = "CURRENT_ROLE_OWNER";
    I18nKeys[I18nKeys["ADMIN"] = "Admin"] = "ADMIN";
    I18nKeys[I18nKeys["OWNER"] = "Owner"] = "OWNER";
    I18nKeys[I18nKeys["CONTACT_LIST_HEADER"] = "Contacts in this conversation"] = "CONTACT_LIST_HEADER";
    I18nKeys[I18nKeys["ADD_MORE_CONTACTS"] = "Add More Contacts"] = "ADD_MORE_CONTACTS";
    I18nKeys[I18nKeys["SUBJECT"] = "Subject"] = "SUBJECT";
    I18nKeys[I18nKeys["DESCRIPTION_OPTIONAL"] = "Description (optional)"] = "DESCRIPTION_OPTIONAL";
    I18nKeys[I18nKeys["EDIT"] = "Edit details"] = "EDIT";
    I18nKeys[I18nKeys["SAVE"] = "Save"] = "SAVE";
    I18nKeys[I18nKeys["CANCEL"] = "Cancel"] = "CANCEL";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLConversationInfoMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLConversationInfo, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLConversationInfoMetadata._instance = null;
exports.CTCLConversationInfoMetadata = CTCLConversationInfoMetadata;
class CTCLConversationInfo extends Base_1.CTCLComponent {
    constructor() {
        super();
        this._me = null;
        this._namedConversationSubject = "";
        this._namedConversationDescription = "";
        this.setMetadata(CTCLConversationInfoMetadata.instance);
    }
    static get is() {
        return "ct-cl-conversation-info";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isLoading = true;
            this.conversation = yield this.layer.getCurrentConversation();
            this._config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, this.conversation);
            if (!this.conversation)
                return yield this._back();
            this._getCurrentUserParticipant();
            this._namedConversationSubject = this.conversation.subject;
            this._namedConversationDescription = this.conversation.description;
            this.defer(() => __awaiter(this, void 0, void 0, function* () {
                this._userLookup = new UserLookup_1.UserLookup(this.layer);
                yield this._userLookup.populate([this.conversation]);
                this._createUserList();
                this.isLoading = false;
            }));
            this.layer.setBackHandler(() => {
                this._back();
            });
        });
    }
    _createUserList() {
        const otherParticipants = this.conversation.participants.filter(x => !utils_1.jidsMatch(x.jid, this._me.jid));
        const users = otherParticipants
            .map(x => this._userLookup.get(x.jid))
            .filter(x => x !== null);
        const sortedUsers = utils_1.sortUsersByName(users);
        this.usersToDisplay = sortedUsers;
    }
    _getCurrentUserParticipant() {
        const currentUserJid = this.layer.getCurrentUserJid();
        this._me = this.conversation.participants.find(x => utils_1.jidsMatch(x.jid, currentUserJid)) || null;
    }
    setupListeners() {
        this.setupConnectionStatusListener();
        this.addListener(Events_1.ChatEvents.ConversationUpdated, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this.conversation && this.conversation.id === detail.conversation.id) {
                this.conversation = detail.conversation;
                yield this._userLookup.populate([this.conversation]);
                this._createUserList();
            }
        }));
        this.addListener(Events_1.ChatEvents.ConversationParticipantsChanged, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this.conversation && this.conversation.id === detail.conversation.id) {
                this.isLoading = true;
                this.conversation.participants = detail.participants;
                this._getCurrentUserParticipant();
                yield this._userLookup.populate([this.conversation]);
                this._createUserList();
                this.isLoading = false;
            }
        }));
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;height:100%;font-size:1em}:host .conversation-info{flex:1 1 auto;display:flex;flex-direction:column;height:100%}:host .conversation-info .header .action{cursor:pointer}:host .conversation-info .role{flex:none;background:var(--dark-header-bg, #212121);color:var(--dark-header-text, #f2f2f2);padding:7px 20px}:host .conversation-info .scrollable{flex:1 1 auto;display:flex;flex-direction:column;overflow:auto}:host .conversation-info .scrollable .named-info{flex:none}:host .conversation-info .scrollable .named-info .subject,:host .conversation-info .scrollable .named-info .description{padding:10px 20px;color:var(--subtle-font-color, #828688)}:host .conversation-info .scrollable .named-info .subject.form-item,:host .conversation-info .scrollable .named-info .description.form-item{padding:10px 10px 5px 10px}:host .conversation-info .scrollable .named-info .description,:host .conversation-info .scrollable .named-info .buttons{border-top:1px solid var(--light-header-bg, #f2f2f2)}:host .conversation-info .scrollable .named-info .buttons{display:flex;justify-content:center;padding:10px}:host .conversation-info .scrollable .named-info .buttons .button+.button{margin:0 0 0 10px}:host .conversation-info .scrollable .participants{flex:1 1 auto}:host .conversation-info .scrollable .participants .heading{flex:none;background:var(--light-header-bg, #f2f2f2);color:var(--light-header-text, #828688);font-size:.833em;font-weight:600;text-transform:uppercase;padding:7px 20px}:host .conversation-info .scrollable .participants ct-icon{margin-top:20px}:host .conversation-info .scrollable .participants .participant-list{flex:1 1 auto}:host .conversation-info .scrollable .participants .participant-list .participant{position:relative;cursor:pointer}:host .conversation-info .scrollable .participants .participant-list .participant .badges{position:absolute;top:50%;right:10px;transform:translateY(-50%)}:host .conversation-info .scrollable .participants .participant-list .participant .badges .badge{display:inline-block;font-size:.75em;font-weight:300;text-transform:uppercase;padding:3px 10px;border-radius:4px;margin:0 0 0 5px;line-height:1em}:host .conversation-info .scrollable .participants .participant-list .participant .badges .badge.admin{background:#303233;color:#ffffff}:host .conversation-info .scrollable .participants .participant-list .participant .badges .badge.owner{background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff)}:host .conversation-info .scrollable .footer{flex:none;padding:10px;text-align:center}
        `;
    }
    generateComponentMarkup() {
        if (!this.conversation)
            return;
        if (!this._me)
            return;
        const isNamedConversation = this._config.namedSettings;
        const canEditNamedConversationDetails = isNamedConversation && [models_1.ChatRole.Owner].includes(this._me.role) && this._config.ownerCanEditAfterSend;
        const canAddContacts = isNamedConversation && [models_1.ChatRole.Administrator, models_1.ChatRole.Owner].includes(this._me.role) && this._config.ownerCanAddAdditionalContacts;
        return (window.__CTRender("div", { class: "conversation-info" },
            this._renderHeader(),
            isNamedConversation && this._renderMyRole(),
            window.__CTRender("div", { class: "scrollable" },
                isNamedConversation && this._renderNamedConversationInfo(canEditNamedConversationDetails),
                !this.editMode && (window.__CTRender("div", { class: "participants" },
                    window.__CTRender("div", { class: "heading" }, this.translateI18nItem(I18nKeys.CONTACT_LIST_HEADER)),
                    this.isLoading
                        ? window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true })
                        : this._renderParticipants())),
                !this.editMode && canAddContacts && this._renderFooter())));
    }
    _renderHeader() {
        const subHeading = this._config.name;
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, this.translateI18nItem(I18nKeys.INFORMATION)),
            window.__CTRender("div", { slot: "sub-heading" }, subHeading)));
    }
    _renderMyRole() {
        const myRole = this._getCurrentRoleString();
        return myRole && (window.__CTRender("div", { class: "role" }, myRole));
    }
    _renderNamedConversationInfo(canEdit) {
        if (canEdit && this.editMode) {
            const subjectLimit = this._config.maxSubjectLength;
            const descriptionLimit = this._config.maxDescriptionLength;
            return (window.__CTRender("div", { class: "named-info" },
                window.__CTRender("div", { class: "form-item subject" },
                    window.__CTRender(components_1.CTTextbox, { type: "text", name: "subject", max: subjectLimit, required: true, fullBorder: true, defaultValue: this._namedConversationSubject, placeholder: this._config.subjectFieldLabel, callback: e => this._onChangeNamedConversationDetail(e) })),
                window.__CTRender("div", { class: "form-item description" },
                    window.__CTRender(components_1.CTTextbox, { type: "textarea", name: "description", max: descriptionLimit, fullBorder: true, defaultValue: this._namedConversationDescription, placeholder: this.translateI18nItem(I18nKeys.DESCRIPTION_OPTIONAL), callback: e => this._onChangeNamedConversationDetail(e) })),
                window.__CTRender("div", { class: "buttons" },
                    window.__CTRender(components_1.CTButton, { class: "button", type: "primary", width: "auto", disabled: this.saveDisabled || !this.isOnline, onClick: this._saveChanges.bind(this) }, this.translateI18nItem(I18nKeys.SAVE)),
                    window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", disabled: !this.isOnline, onClick: this._cancelChanges.bind(this) }, this.translateI18nItem(I18nKeys.CANCEL)))));
        }
        else {
            return (window.__CTRender("div", { class: "named-info" },
                window.__CTRender("div", { class: "subject" }, this.conversation.subject),
                this.conversation.description && (window.__CTRender("div", { class: "description" }, this.conversation.description)),
                canEdit && (window.__CTRender("div", { class: "buttons" },
                    window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", disabled: !this.isOnline, onClick: this._enterEditMode.bind(this) }, this.translateI18nItem(I18nKeys.EDIT))))));
        }
    }
    _renderParticipants() {
        return (window.__CTRender("div", { class: "participant-list" }, this.usersToDisplay.map(x => this._renderContact(x))));
    }
    _renderContact(contact) {
        if (!contact)
            return null;
        const participant = this.conversation.participants.find(x => utils_1.jidsMatch(x.jid, contact.jid)) || null;
        if (!participant)
            return null;
        const isNamedConversation = this._config.namedSettings;
        const role = isNamedConversation && this._getRoleString(participant) || null;
        const roleClass = isNamedConversation && this._getRoleClass(participant) || null;
        const detailStyle = renderUtils_1.buildStyles({});
        if (role) {
            detailStyle.paddingRight = "60px";
        }
        return (window.__CTRender("div", { class: "participant", onClick: () => this._showContactInfo(contact) },
            window.__CTRender(components_1.CTUserTile, { user: contact, detailStyle: detailStyle }, role && (window.__CTRender("div", { class: "badges", slot: "additional" },
                window.__CTRender("div", { class: `badge ${roleClass}` }, role))))));
    }
    _renderFooter() {
        return (window.__CTRender("div", { class: "footer" },
            window.__CTRender(components_1.CTButton, { type: "secondary", width: "auto", disabled: !this.isOnline, onClick: this._addContacts.bind(this) }, this.translateI18nItem(I18nKeys.ADD_MORE_CONTACTS))));
    }
    // === Event handlers === //
    _enterEditMode() {
        this.saveDisabled = true;
        this.editMode = true;
    }
    _onChangeNamedConversationDetail(e) {
        if (e && e.key === "subject") {
            this._namedConversationSubject = e.value;
        }
        if (e && e.key === "description") {
            this._namedConversationDescription = e.value;
        }
        const hasSubject = this._config.subjectRequired ? this._namedConversationSubject.trim().length > 0 : true;
        const hasDescription = this._config.descriptionRequired ? this._namedConversationDescription.trim().length > 0 : true;
        const detailsAreDifferent = (this.conversation.subject !== this._namedConversationSubject) || (this.conversation.description !== this._namedConversationDescription);
        this.saveDisabled = !hasSubject || !hasDescription || !detailsAreDifferent;
    }
    _saveChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.saveDisabled)
                return;
            if (yield this.layer.updateNamedConversation(this.conversation, this._namedConversationSubject.trim(), this._namedConversationDescription.trim())) {
                this.editMode = false;
            }
        });
    }
    _cancelChanges() {
        this._namedConversationSubject = this.conversation.subject;
        this._namedConversationDescription = this.conversation.description;
        this.editMode = false;
    }
    _back() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.conversation) {
                yield this.layer.setCurrentConversation(this.conversation);
            }
            this.emitComponentEvent("go-back");
        });
    }
    _addContacts() {
        this.emitComponentEvent("go-add-contacts");
    }
    _goChat() {
        this.emitComponentEvent("go-chat");
    }
    _showContactInfo(contact) {
        this.layer.showContactInfo(contact, this.conversation, true, this._goChat.bind(this));
    }
    // === Private functions === //
    _getCurrentRoleString() {
        switch (this._me && this._me.role) {
            case models_1.ChatRole.Administrator:
                return this.translateI18nItem(I18nKeys.CURRENT_ROLE_ADMINISTRATOR);
            case models_1.ChatRole.Owner:
                return this.translateI18nItem(I18nKeys.CURRENT_ROLE_OWNER);
            default:
                return null;
        }
    }
    _getRoleString(participant) {
        switch (participant && participant.role) {
            case models_1.ChatRole.Administrator:
                return this.translateI18nItem(I18nKeys.ADMIN);
            case models_1.ChatRole.Owner:
                return this.translateI18nItem(I18nKeys.OWNER);
            default:
                return null;
        }
    }
    _getRoleClass(participant) {
        switch (participant && participant.role) {
            case models_1.ChatRole.Administrator:
                return "admin";
            case models_1.ChatRole.Owner:
                return "owner";
            default:
                return null;
        }
    }
}
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLConversationInfo.prototype, "conversation", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLConversationInfo.prototype, "editMode", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLConversationInfo.prototype, "saveDisabled", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTCLConversationInfo.prototype, "usersToDisplay", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLConversationInfo.prototype, "isLoading", void 0);
exports.CTCLConversationInfo = CTCLConversationInfo;
CTCLConversationInfo.register();


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const UserLookup_1 = __webpack_require__(26);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const utils_1 = __webpack_require__(2);
const ChatUtils_1 = __webpack_require__(10);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const VirtualList_1 = __webpack_require__(33);
const renderUtils_1 = __webpack_require__(8);
const ct_selection_text_filter_1 = __webpack_require__(61);
const ConversationConfigReader_1 = __webpack_require__(14);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["CONVERSATIONS"] = "Conversations"] = "CONVERSATIONS";
    I18nKeys[I18nKeys["NO_UNREAD"] = "No Unread Conversations"] = "NO_UNREAD";
    I18nKeys[I18nKeys["UNREAD_COUNT"] = "{{number}} Unread Conversation(s)"] = "UNREAD_COUNT";
    I18nKeys[I18nKeys["NO_CONVERSATIONS"] = "You do not have any conversations"] = "NO_CONVERSATIONS";
    I18nKeys[I18nKeys["NO_MATCH"] = "No conversations match that filter"] = "NO_MATCH";
    I18nKeys[I18nKeys["FILTER_PLACEHOLDER"] = "Filter by Subject & Participant"] = "FILTER_PLACEHOLDER";
    I18nKeys[I18nKeys["SUBJECT"] = "Subject"] = "SUBJECT";
    I18nKeys[I18nKeys["EXPIRED"] = "Expired"] = "EXPIRED";
    I18nKeys[I18nKeys["YOU"] = "You"] = "YOU";
    I18nKeys[I18nKeys["CLOSED"] = "Closed"] = "CLOSED";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLConversationListMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLConversationList, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLConversationListMetadata._instance = null;
exports.CTCLConversationListMetadata = CTCLConversationListMetadata;
class CTCLConversationList extends Base_1.CTCLComponent {
    constructor() {
        super();
        // === End properties === //
        this.TILE_HEIGHT = 70;
        this._filterType = "";
        this._filterTerm = "";
        this._contentLimit = 100;
        this._onFilterChange = (selection, filterTerm) => {
            this._filterType = selection;
            this._filterTerm = filterTerm;
            this._updateVirtualList();
        };
        this.setMetadata(CTCLConversationListMetadata.instance);
        this._virtualList = new VirtualList_1.VirtualList(this, [], {
            itemHeight: this.TILE_HEIGHT,
            itemKeyGetter: x => x.id
        });
    }
    static get is() {
        return "ct-cl-conversation-list";
    }
    initialize(layer) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this, layer);
            this._userLookup = new UserLookup_1.UserLookup(this.layer);
            this.isFetching = true;
            this.defer(() => __awaiter(this, void 0, void 0, function* () {
                yield this._updateConversations();
            }));
            this.layer.setBackHandler(() => {
                this.layer.moveTaskToBack();
            });
        });
    }
    setupListeners() {
        this.addListeners([
            Events_1.ChatEvents.ConversationAdded,
            Events_1.ChatEvents.ConversationUpdated,
            Events_1.ChatEvents.ConversationRemoved
        ], () => __awaiter(this, void 0, void 0, function* () {
            this.debounce("update", () => __awaiter(this, void 0, void 0, function* () {
                yield this._updateConversations();
            }));
        }));
    }
    _generateFilterItems() {
        const filterItems = this.layer.getConfiguredConversations().map(x => x.name);
        this._allConversations.forEach(x => {
            if (x.config && !filterItems.includes(x.config.name)) {
                filterItems.push(x.config.name);
            }
        });
        filterItems.sort();
        return filterItems;
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}@-moz-keyframes blinker{0%{opacity:1.0}50%{opacity:0.25}100%{opacity:1.0}}@-webkit-keyframes blinker{0%{opacity:1.0}50%{opacity:0.25}100%{opacity:1.0}}@keyframes blinker{0%{opacity:1.0}50%{opacity:0.25}100%{opacity:1.0}}:host{display:block;height:100%;font-size:1em}:host .conversation-list{flex:1 1 auto;display:flex;flex-direction:column;height:100%}:host .conversation-list .header .action{cursor:pointer}:host .conversation-list .filter{flex:0 0 55px;display:flex;justify-content:center;align-items:center;background:var(--secondary-color, #f2f2f2);border-bottom:var(--secondary-border, 1px solid #ddd);padding:0 20px}:host .conversation-list .filter .search-box{width:80%;font-size:.833em}:host .conversation-list .column-headings{display:none;background:var(--secondary-color, #f2f2f2);border-bottom:var(--secondary-border, 1px solid #ddd);color:var(--subtle-font-color);align-items:center;padding:5px 10px}@media only screen and (min-width: 960px){:host .conversation-list .column-headings{display:flex;flex:0 0 auto}}:host .conversation-list .column-headings div.type{flex-basis:6vw}:host .conversation-list .column-headings div.from-to{flex-basis:20vw}:host .conversation-list .column-headings div.subject{flex-basis:30vw}:host .conversation-list .column-headings div.last-response{flex-basis:30vw}:host .conversation-list .column-headings div.raised-at{flex-basis:10vw}:host .conversation-list .column-headings div span{text-transform:uppercase}:host .conversation-list .fetching,:host .conversation-list .no-conversations{flex:1 1 auto;display:flex;justify-content:center;align-items:flex-start;text-align:center;height:100%;padding:25px 10px;background:var(--list-bg, #f2f2f2);color:var(--subtle-font-color, #828688)}:host .conversation-list .conversations{flex:1 1 auto;overflow:auto;-webkit-overflow-scrolling:touch;background:var(--list-bg, #f2f2f2)}:host .conversation-list .conversations .conversations-content .conversation{cursor:pointer}:host .conversation-list .conversations .conversations-content .conversation .avatar{flex:none;display:flex;flex-direction:column;justify-content:center;align-items:center;width:40px;height:40px;background:var(--avatar-bg, #7b7e80);color:var(--avatar-color, #fff);border-radius:50%}:host .conversation-list .conversations .conversations-content .conversation .avatar.group{background:var(--group-avatar-bg, #22b1c8);color:var(--group-avatar-color, #fff)}:host .conversation-list .conversations .conversations-content .conversation .avatar.group .icon{margin:-2px 0 2px 0}:host .conversation-list .conversations .conversations-content .conversation .avatar.group .count{line-height:0.8em;font-size:1.333em;letter-spacing:-1px}:host .conversation-list .conversations .conversations-content .conversation .avatar.group .count.small{font-size:1em}:host .conversation-list .conversations .conversations-content .conversation .avatar.group .count.smallest{font-size:.833em}:host .conversation-list .conversations .conversations-content .conversation .avatar.closed{background:none;justify-content:flex-start}:host .conversation-list .conversations .conversations-content .conversation .avatar.closed .badge{background:#303233;color:#ffffff;font-size:.75em;font-weight:300;text-transform:uppercase;padding:3px 4px;margin:5px 0 0 0;border-radius:4px;line-height:1em}:host .conversation-list .conversations .conversations-content .conversation .avatar.closed .badge.blink{-webkit-animation-name:blinker;-webkit-animation-duration:3s;-webkit-animation-timing-function:linear;-webkit-animation-iteration-count:infinite;-moz-animation-name:blinker;-moz-animation-duration:3s;-moz-animation-timing-function:linear;-moz-animation-iteration-count:infinite;animation-name:blinker;animation-duration:3s;animation-timing-function:linear;animation-iteration-count:infinite}:host .conversation-list .conversations .conversations-content .conversation .expanded{display:none}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .expanded{display:flex;flex-basis:20vw;overflow:hidden;flex-direction:column}:host .conversation-list .conversations .conversations-content .conversation .expanded div.from,:host .conversation-list .conversations .conversations-content .conversation .expanded div.to{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}}:host .conversation-list .conversations .conversations-content .conversation .subject{display:flex;align-items:center;overflow:hidden}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .subject{flex-basis:20vw;padding-right:20px}}:host .conversation-list .conversations .conversations-content .conversation .subject .badge{flex:none;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);font-size:.75em;font-weight:300;text-transform:uppercase;margin:0 5px 0 0;padding:3px 4px;border-radius:4px;line-height:1em}:host .conversation-list .conversations .conversations-content .conversation .subject .badge.blink{-webkit-animation-name:blinker;-webkit-animation-duration:1s;-webkit-animation-timing-function:linear;-webkit-animation-iteration-count:infinite;-moz-animation-name:blinker;-moz-animation-duration:1s;-moz-animation-timing-function:linear;-moz-animation-iteration-count:infinite;animation-name:blinker;animation-duration:1s;animation-timing-function:linear;animation-iteration-count:infinite}:host .conversation-list .conversations .conversations-content .conversation .subject .title{flex:1 1 auto;font-size:1.333em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .subject .title{display:none}}:host .conversation-list .conversations .conversations-content .conversation .subject .icon{flex:none;margin:0 0 0 10px}:host .conversation-list .conversations .conversations-content .conversation .subject .icon.pending{color:var(--conversation-has-draft-color, #7e8080)}:host .conversation-list .conversations .conversations-content .conversation .subject .icon.error{color:var(--conversation-has-error-color, #d93247)}:host .conversation-list .conversations .conversations-content .conversation .subject .icon.remove{color:var(--subtle-font-color, #828688);cursor:pointer}:host .conversation-list .conversations .conversations-content .conversation .description{display:none}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .description{display:flex;flex-basis:30vw;flex-direction:column;overflow:hidden;padding-right:20px;justify-content:center}:host .conversation-list .conversations .conversations-content .conversation .description div.subject-desc{font-size:1.333em}:host .conversation-list .conversations .conversations-content .conversation .description div.subject-desc,:host .conversation-list .conversations .conversations-content .conversation .description div.user-desc{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}}:host .conversation-list .conversations .conversations-content .conversation .preview{display:flex;align-items:center;flex-direction:row;padding-right:20px;color:var(--conversation-read-text, #828688)}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .preview{flex:0 0 30vw}}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview{flex:1 1 auto;display:flex;align-items:center;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview{display:none}}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .entry{flex:1 1 auto;display:flex;align-items:center;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .entry .message{text-overflow:ellipsis;overflow:hidden}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .entry .message.has-attachment{display:flex;align-items:center}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .entry .message.has-attachment .icon{margin:0 3px 0 5px;color:var(--subtle-font-color, #828688)}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .entry .message.has-attachment .label{font-size:.833em;color:var(--subtle-font-color, #828688)}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .when{flex:none;margin:0 0 0 10px}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .marker{flex:none;margin:0 0 0 5px;width:16px}:host .conversation-list .conversations .conversations-content .conversation .preview .mobile-preview .marker:before{display:block;content:"";width:10px;height:10px;margin:0 auto;border-radius:50%;background:var(--conversation-read-marker-bg, #fff);border:var(--conversation-read-marker-border, 1px solid #ddd)}:host .conversation-list .conversations .conversations-content .conversation .preview .desktop-preview{display:none}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation .preview .desktop-preview{display:flex;flex-basis:30vw;flex-direction:column;overflow:hidden;justify-content:center}:host .conversation-list .conversations .conversations-content .conversation .preview .desktop-preview div.entry div.message{font-size:1.1em}}:host .conversation-list .conversations .conversations-content .conversation div.raised-on{display:none}@media only screen and (min-width: 960px){:host .conversation-list .conversations .conversations-content .conversation div.raised-on{display:flex;flex-basis:10vw;flex-direction:row;overflow:hidden;align-content:center}:host .conversation-list .conversations .conversations-content .conversation div.raised-on span{margin:auto 0}:host .conversation-list .conversations .conversations-content .conversation div.raised-on div.marker{margin:auto 0 auto 5px;flex:none;width:16px}:host .conversation-list .conversations .conversations-content .conversation div.raised-on div.marker:before{display:block;content:"";width:10px;height:10px;margin:0 auto;border-radius:50%;background:var(--conversation-read-marker-bg, #fff);border:var(--conversation-read-marker-border, 1px solid #ddd)}}:host .conversation-list .conversations .conversations-content .conversation.unread .subject .title{font-weight:600}:host .conversation-list .conversations .conversations-content .conversation.unread .description .subject-desc{font-weight:600}:host .conversation-list .conversations .conversations-content .conversation.unread .preview .entry,:host .conversation-list .conversations .conversations-content .conversation.unread .raised-on .entry{color:var(--conversation-unread-text, #212121)}:host .conversation-list .conversations .conversations-content .conversation.unread .preview .marker:before,:host .conversation-list .conversations .conversations-content .conversation.unread .raised-on .marker:before{background:var(--conversation-unread-marker-bg, #22b1c8);border:var(--conversation-unread-marker-border, 1px solid #22b1c8)}:host .conversation-list .conversations .conversations-content .conversation.closed{position:relative;cursor:default}:host .conversation-list .conversations .conversations-content .conversation.closed .subject{color:var(--subtle-font-color, #828688)}:host .conversation-list .conversations .conversations-content .conversation.closed .subject .title{font-weight:400}:host .conversation-list .conversations .conversations-content .conversation.closed .preview .entry{color:var(--subtle-font-color, #828688)}:host .conversation-list .conversations .conversations-content .conversation.closed .preview .when{color:var(--subtle-font-color, #828688)}:host .conversation-list .conversations .conversations-content .conversation.closed .preview .marker{display:none}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "conversation-list" },
            this._renderHeader(),
            window.__CTRender("div", { class: "filter" },
                window.__CTRender(ct_selection_text_filter_1.CTSelectionTextFilter, { placeholder: this.translateI18nItem(I18nKeys.FILTER_PLACEHOLDER), selectionItems: this.filterItems, onSearch: this._onFilterChange })),
            window.__CTRender("div", { class: "column-headings" },
                window.__CTRender("div", { class: "type" },
                    window.__CTRender("span", null, "Type")),
                window.__CTRender("div", { class: "from-to" },
                    window.__CTRender("span", null, "From / To")),
                window.__CTRender("div", { class: "subject" },
                    window.__CTRender("span", null, "Subject / Description")),
                window.__CTRender("div", { class: "last-response" },
                    window.__CTRender("span", null, "Response / Time")),
                window.__CTRender("div", { class: "raised-at" },
                    window.__CTRender("span", null, "Raised"))),
            this.isFetching && (window.__CTRender("div", { class: "fetching" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }))),
            !this.isFetching && this._renderConversations()));
    }
    _renderHeader() {
        const unreadConversations = this._virtualList.items.filter(x => {
            return x.hasUnread && !x.isClosed;
        });
        const unreadCount = unreadConversations.length;
        const title = this.translateI18nItem(I18nKeys.CONVERSATIONS);
        const subTitle = unreadCount === 0
            ? this.translateI18nItem(I18nKeys.NO_UNREAD)
            : this.translateI18nItem(I18nKeys.UNREAD_COUNT).replace("{{number}}", unreadCount.toString());
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "heading" }, title),
            window.__CTRender("div", { slot: "sub-heading" }, subTitle),
            window.__CTRender("div", { slot: "right-action" }, this._renderRightAction())));
    }
    _renderRightAction() {
        if (this.layer.getConfiguredConversations().length === 0) {
            return null;
        }
        if (this.updatingUserDirectory) {
            return (window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }));
        }
        return (window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.PlusSign, onClick: this._startNew.bind(this) }));
    }
    _renderConversations() {
        if (!this._allConversations || this._allConversations.length === 0) {
            return (window.__CTRender("div", { class: "no-conversations" }, this.translateI18nItem(I18nKeys.NO_CONVERSATIONS)));
        }
        if (this._virtualList.items.length === 0) {
            return (window.__CTRender("div", { class: "no-conversations" }, this.translateI18nItem(I18nKeys.NO_MATCH)));
        }
        return this._virtualList.render(this._renderConversation.bind(this), "conversations", "conversations-content");
    }
    _renderConversation(conversation, props) {
        const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, conversation);
        const classes = [
            "conversation",
            conversation.hasUnread ? "unread" : "read"
        ];
        if (conversation.isClosed)
            classes.push("closed");
        if (!conversation.isClosed && typeof (this._onClickConversation) === "function")
            classes.push("clickable");
        const currentUserJid = this.layer.getCurrentUserJid();
        const title = ChatUtils_1.getConversationTitle(conversation, this._userLookup, currentUserJid, this.translateI18nItem(I18nKeys.YOU));
        const description = conversation.description ? conversation.description.substr(0, 100) : null;
        const from = this._userLookup.get(conversation.instigator).displayName;
        const to = ChatUtils_1.generateConversationTitleFromParticipants(this._userLookup, conversation.participants.filter(x => x.jid !== currentUserJid), currentUserJid).substr(0, 100);
        const when = conversation.preview && ((utils_1.daysFromNow(conversation.preview.date) === 0)
            ? utils_1.getFriendlyTime(conversation.preview.date)
            : utils_1.getFriendlyDate(conversation.preview.date, this)) || null;
        const raisedOn = (utils_1.daysFromNow(conversation.createdTime) === 0)
            ? utils_1.getFriendlyTime(conversation.createdTime)
            : utils_1.getFriendlyDate(conversation.createdTime, this);
        let priorityText = config.name;
        let priorityColor = config.colorCode;
        if (ChatUtils_1.isExpiredConversation(conversation)) {
            priorityText = config.name;
            priorityColor = "#CCC"; // TODO: how to get this?
        }
        else if (config.alert) {
            priorityText = config.name;
            priorityColor = config.colorCode;
        }
        const badgeStyle = renderUtils_1.buildStyles({
            backgroundColor: priorityColor,
            color: priorityColor ? renderUtils_1.decideTextColorFromBgColor(priorityColor) : "#FFF"
        });
        const badgeClasses = ["badge"];
        if (config.alert) {
            const currentUserJid = this.layer.getCurrentUserJid();
            if (this.layer.shouldUserGetAlert(conversation)) {
                if (!ChatUtils_1.isExpiredConversation(conversation)) {
                    if (!conversation.acknowledgements || !conversation.acknowledgements.find(a => a.jid === currentUserJid)) {
                        badgeClasses.push("blink");
                    }
                }
            }
        }
        return (window.__CTRender("div", Object.assign({ class: classes.join(" ") }, props, { onClick: e => this._onClickConversation(conversation, e, config) }),
            window.__CTRender(components_1.CTAvatarTile, { height: `${this.TILE_HEIGHT}px`, hatched: conversation.isClosed },
                this._renderAvatar(conversation, config),
                window.__CTRender("div", { class: "subject" },
                    config.namedSettings && !conversation.isClosed && (window.__CTRender("div", { class: badgeClasses.join(" "), style: badgeStyle }, priorityText)),
                    window.__CTRender("div", { class: "expanded" },
                        window.__CTRender("div", { class: "from" },
                            "From: ",
                            from),
                        window.__CTRender("div", { class: "to" },
                            "To: ",
                            to)),
                    window.__CTRender("div", { class: "title" }, title),
                    this._renderSubjectLineIcon(conversation)),
                window.__CTRender("div", { class: "description" },
                    window.__CTRender("div", { class: "subject-desc" }, title),
                    window.__CTRender("div", { class: "user-desc" }, description)),
                conversation.preview && (window.__CTRender("div", { class: "preview" },
                    window.__CTRender("div", { class: "mobile-preview" },
                        this._renderPreviewLine(conversation.preview),
                        window.__CTRender("div", { class: "when" }, when),
                        window.__CTRender("div", { class: "marker" })),
                    window.__CTRender("div", { class: "desktop-preview" },
                        this._renderPreviewLine(conversation.preview),
                        window.__CTRender("div", { class: "when" }, when)))),
                window.__CTRender("div", { class: "raised-on" },
                    window.__CTRender("span", null, raisedOn),
                    window.__CTRender("div", { class: "marker" })))));
    }
    _renderAvatar(conversation, config) {
        const currentUserJid = this.layer.getCurrentUserJid();
        const otherParticipants = conversation.participants
            .filter(x => !utils_1.jidsMatch(x.jid, currentUserJid));
        if (conversation.isClosed) {
            return (window.__CTRender("div", { slot: "avatar", class: "avatar closed" },
                window.__CTRender("div", { class: "badge" }, this.translateI18nItem(I18nKeys.CLOSED))));
        }
        if (config.alert && config.autoAlert) {
            return (window.__CTRender("div", { slot: "avatar", class: "avatar individual" },
                window.__CTRender(components_1.CTUserAvatar, { bgColor: !conversation.isClosed ? config.colorCode : null, defaultIcon: Models_1.Icons.UI.AlertBellRinging })));
        }
        else if (config.alert && !config.autoAlert) {
            return (window.__CTRender("div", { slot: "avatar", class: "avatar individual" },
                window.__CTRender(components_1.CTUserAvatar, { bgColor: !conversation.isClosed ? config.colorCode : null, defaultIcon: Models_1.Icons.UI.AlertBell })));
        }
        const individual = (otherParticipants.length === 1);
        if (individual) {
            const otherUser = this._userLookup.get(otherParticipants[0].jid);
            return (window.__CTRender("div", { slot: "avatar", class: "avatar individual" },
                window.__CTRender(components_1.CTUserAvatar, { bgColor: !conversation.isClosed ? config.colorCode || utils_1.getCSSVariable("--primary-color") : null, user: otherUser })));
        }
        else {
            const length = otherParticipants.length.toString().length;
            let size = "";
            if (length === 3) {
                size = "small";
            }
            else if (length === 4) {
                size = "smallest";
            }
            return (window.__CTRender("div", { slot: "avatar", class: "avatar group" },
                window.__CTRender(components_1.CTIcon, { class: "icon", width: "12", height: "12", icon: models_1.Icons.COMMON.Users }),
                window.__CTRender("div", { class: `count ${size}` },
                    "+ ",
                    otherParticipants.length)));
        }
    }
    _renderSubjectLineIcon(conversation) {
        if (conversation.isClosed) {
            return (window.__CTRender("div", { class: "icon remove" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.CircleCross, onClick: e => this._removeConversation(conversation, e) })));
        }
        if (!conversation.draft)
            return null;
        if (conversation.draft.error === true) {
            return (window.__CTRender("div", { class: "icon error" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Error })));
        }
        else if (conversation.draft) {
            return (window.__CTRender("div", { class: "icon pending" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Pencil })));
        }
    }
    _renderPreviewLine(preview) {
        if (!preview)
            return null;
        const previewContent = () => {
            switch (preview.type) {
                case models_1.ChatEntryType.Meta:
                    const currentUserJid = this.layer.getCurrentUserJid();
                    const activity = preview;
                    const metaActivitySummaryText = ChatUtils_1.getChatMetaActivitySummaryText(activity, this._userLookup, currentUserJid, this, false);
                    return (window.__CTRender("div", { class: "message" }, metaActivitySummaryText));
                case models_1.ChatEntryType.Chat:
                    const message = preview;
                    const fromUser = this._userLookup.get(message.from);
                    const from = message.mine
                        ? this.translateI18nItem(I18nKeys.YOU)
                        : utils_1.formatUserName(fromUser, utils_1.NameFormat.PREFIX_INITIAL_LAST) || message.from;
                    const hasAttachment = (message.attachments && message.attachments.length > 0);
                    const cssClasses = [
                        "message"
                    ];
                    if (hasAttachment)
                        cssClasses.push("has-attachment");
                    const previewText = ChatUtils_1.getChatMessageTextForPreview(message, this);
                    return (window.__CTRender("div", { class: cssClasses.join(" ") },
                        from,
                        ":",
                        " ",
                        hasAttachment && (window.__CTRender("div", { class: "icon" },
                            window.__CTRender(components_1.CTIcon, { width: "14", height: "14", icon: Models_1.Icons.UI.Attachment }))),
                        hasAttachment && window.__CTRender("span", { class: "label" }, previewText),
                        !hasAttachment && previewText));
            }
        };
        return (window.__CTRender("div", { class: "entry" }, previewContent()));
    }
    // === Event handlers === //
    _startNew() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.layer.config.behaviour.updateUsersOnNewConversationClick) {
                this.updatingUserDirectory = true;
                try {
                    yield this.layer.updateUserDirectory();
                }
                catch (ex) {
                    // tslint:disable-next-line no-console
                    console.error(ex);
                }
                finally {
                    this.updatingUserDirectory = false;
                    this.emitComponentEvent("go-new-conversation");
                }
            }
            else {
                this.emitComponentEvent("go-new-conversation");
            }
        });
    }
    _onClickConversation(conversation, event, config) {
        return __awaiter(this, void 0, void 0, function* () {
            event.stopPropagation();
            if (conversation.isClosed)
                return;
            yield this.layer.setCurrentConversation(conversation, false);
            if (config.alert) {
                if (this.layer.shouldUserGetAlert(conversation)) {
                    if (!ChatUtils_1.isExpiredConversation(conversation)) {
                        if (!conversation.acknowledgements || !conversation.acknowledgements.find(a => a.jid === this.layer.getCurrentUserJid())) {
                            yield this.layer.showConversationAlert(conversation, true);
                            return;
                        }
                    }
                }
            }
            this.emitComponentEvent("go-chat");
        });
    }
    _removeConversation(conversation, event) {
        return __awaiter(this, void 0, void 0, function* () {
            event.stopPropagation();
            if (!conversation.isClosed)
                return;
            yield this.layer.removeConversationById(conversation.id);
        });
    }
    // === Private functions === //
    _updateConversations() {
        return __awaiter(this, void 0, void 0, function* () {
            const allConversations = yield this.layer.getConversations();
            this._allConversations = allConversations.filter(x => !x.hideBefore);
            yield this._userLookup.populate(this._allConversations);
            this._updateVirtualList();
            this.filterItems = this._generateFilterItems();
        });
    }
    _updateVirtualList() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isFetching = true;
            const currentUserJid = this.layer.getCurrentUserJid();
            const preparedConversations = ChatUtils_1.prepareConversationsForList(this._userLookup, this._allConversations, currentUserJid, this._filterType, this._filterTerm, this.layer);
            this._conversationHash = ChatUtils_1.sortConversationsIntoHash(this._userLookup, this._allConversations, currentUserJid, this._filterType, this._filterTerm, this.layer);
            this._virtualList.setItems(preparedConversations);
            this.filterItems = this._generateFilterItems();
            this.isFetching = false;
        });
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: true })
], CTCLConversationList.prototype, "isFetching", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLConversationList.prototype, "updatingUserDirectory", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTCLConversationList.prototype, "filterItems", void 0);
exports.CTCLConversationList = CTCLConversationList;
CTCLConversationList.register();


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const events_1 = __webpack_require__(9);
const Base_1 = __webpack_require__(12);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const Events_1 = __webpack_require__(4);
const Models = __webpack_require__(1);
const Keys_1 = __webpack_require__(20);
const Helpers_1 = __webpack_require__(150);
const ct_action_sheet_1 = __webpack_require__(58);
const ConversationConfigReader_1 = __webpack_require__(14);
const ct_cl_image_attachment_1 = __webpack_require__(107);
const ct_cl_audio_attachment_1 = __webpack_require__(105);
const ct_single_checkbox_1 = __webpack_require__(187);
const ctcl_video_attachment_1 = __webpack_require__(108);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["SELECT_CONTACTS"] = "Select Contacts"] = "SELECT_CONTACTS";
    I18nKeys[I18nKeys["CHOOSE_CONTACT"] = ""] = "CHOOSE_CONTACT";
    I18nKeys[I18nKeys["TOTAL_CONTACTS"] = "Total {{number}} Contacts Added"] = "TOTAL_CONTACTS";
    I18nKeys[I18nKeys["TOTAL_CONTACTS_MAX"] = "Total {{number}} Contacts Added (out of {{maximum}})"] = "TOTAL_CONTACTS_MAX";
    I18nKeys[I18nKeys["SEARCH_PLACEHOLDER"] = "Find Contacts"] = "SEARCH_PLACEHOLDER";
    I18nKeys[I18nKeys["INITIAL_MESSAGE"] = "Find your contacts using the search bar above"] = "INITIAL_MESSAGE";
    I18nKeys[I18nKeys["NO_MATCHES"] = "No contacts match your search"] = "NO_MATCHES";
    I18nKeys[I18nKeys["DIRECT"] = "Direct"] = "DIRECT";
    I18nKeys[I18nKeys["NAMED"] = "Named"] = "NAMED";
    I18nKeys[I18nKeys["NAMED_CONVERSATION"] = "Named Conversation"] = "NAMED_CONVERSATION";
    I18nKeys[I18nKeys["ADD_SUBJECT_AND_DESCRIPTION"] = "Add a Subject & Description"] = "ADD_SUBJECT_AND_DESCRIPTION";
    I18nKeys[I18nKeys["SUBJECT"] = "Subject"] = "SUBJECT";
    I18nKeys[I18nKeys["DESCRIPTION_OPTIONAL"] = "Description (optional)"] = "DESCRIPTION_OPTIONAL";
    I18nKeys[I18nKeys["CREATE"] = "Create"] = "CREATE";
    I18nKeys[I18nKeys["CREATING_CONVERSATION"] = "Creating conversation"] = "CREATING_CONVERSATION";
    I18nKeys[I18nKeys["THIS_PRIORITY_WILL_POP_UP_WARNING"] = "Selecting this priority will cause a pop-up on the recipient's device, are you sure?"] = "THIS_PRIORITY_WILL_POP_UP_WARNING";
    I18nKeys[I18nKeys["WARN_NO_CONTACTS"] = "You have not selected any contacts. Are you sure you wish to proceed?"] = "WARN_NO_CONTACTS";
    I18nKeys[I18nKeys["OPTIONS"] = "Options"] = "OPTIONS";
    I18nKeys[I18nKeys["PARTICIPANT_ERROR"] = "You cannot create this conversation without selecting contacts first."] = "PARTICIPANT_ERROR";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLNewConversationMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLNewConversation, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLNewConversationMetadata._instance = null;
exports.CTCLNewConversationMetadata = CTCLNewConversationMetadata;
var NEW_CONVERSATION_STEP;
(function (NEW_CONVERSATION_STEP) {
    NEW_CONVERSATION_STEP[NEW_CONVERSATION_STEP["CONTACT_LIST"] = 0] = "CONTACT_LIST";
    NEW_CONVERSATION_STEP[NEW_CONVERSATION_STEP["NAMED_CONVERSATION_DETAILS"] = 1] = "NAMED_CONVERSATION_DETAILS";
})(NEW_CONVERSATION_STEP || (NEW_CONVERSATION_STEP = {}));
class CTCLNewConversation extends Base_1.CTCLComponent {
    constructor() {
        super();
        // === End properties === //
        this._namedConversationSubject = "";
        this._namedConversationDescription = "";
        this._pendingConversationId = null;
        this._alertResponseOption = Models_1.defaultAlertResponseOption;
        this._newPageOptions = Helpers_1.generateDefaultNewPage();
        this._attachments = [];
        this._startDirectConversation = () => __awaiter(this, void 0, void 0, function* () {
            const participants = yield this._getConversationParticipants(false);
            yield this._resetUserList();
            const existingDirectConversation = yield this.layer.getDirectConversationByParticipants(participants);
            if (existingDirectConversation) {
                yield this.layer.setCurrentConversation(existingDirectConversation);
                this.emitComponentEvent("go-chat");
            }
            else {
                const provisionalConversation = ChatUtils_1.createProvisionalDirectConversation(participants, this._config.constructConfigurationToSend());
                yield this.layer.setProvisionalConversation(provisionalConversation);
                this.emitComponentEvent("go-chat");
            }
        });
        this._goToNamedConversationDetailsStep = () => __awaiter(this, void 0, void 0, function* () {
            this.step = NEW_CONVERSATION_STEP.NAMED_CONVERSATION_DETAILS;
        });
        this._onReplyTemplateChange = (selection) => {
            const option = this._config.alertResponseOptions[selection];
            if (option) {
                this._alertResponseOption = option;
            }
            else {
                this._alertResponseOption = Models_1.defaultAlertResponseOption;
            }
        };
        this._setImgAttachment = (file) => {
            this._attachments
                .filter(x => x.type === Models_1.SupportedAttachmentType.IMAGE)
                .forEach((x, idx) => this._attachments.splice(idx, 1));
            if (file) {
                this._attachments.push({
                    path: file,
                    type: Models_1.SupportedAttachmentType.IMAGE
                });
            }
        };
        this._setAudioAttachment = (file) => {
            const hasSubject = this._config.subjectRequired ? this._namedConversationSubject.trim().length > 0 : true;
            const hasDescription = this._config.descriptionRequired ? this._namedConversationDescription.trim().length > 0 : true;
            if (hasSubject && hasDescription)
                this.createNamedConversationDisabled = false;
            this.isRecording = false;
            this._attachments
                .filter(x => x.type === Models_1.SupportedAttachmentType.AUDIO)
                .forEach((x, idx) => this._attachments.splice(idx, 1));
            if (file) {
                this._attachments.push({
                    path: file,
                    type: Models_1.SupportedAttachmentType.AUDIO
                });
            }
        };
        this._setVideoAttachment = (file) => {
            this._attachments
                .filter(x => x.type === Models_1.SupportedAttachmentType.VIDEO)
                .forEach((x, idx) => this._attachments.splice(idx, 1));
            if (file) {
                this._attachments.push({
                    path: file,
                    type: Models_1.SupportedAttachmentType.VIDEO
                });
            }
        };
        this._onEnableChatChange = (value) => {
            this._newPageOptions.enableChat = value;
        };
        this.setMetadata(CTCLNewConversationMetadata.instance);
    }
    static get is() {
        return "ct-cl-new-conversation";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.layer.setBackHandler(() => {
                this._back();
            });
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener();
        this.addListener(Events_1.ChatEvents.ConversationAdded, (detail) => __awaiter(this, void 0, void 0, function* () {
            if (this._pendingConversationId && this._pendingConversationId === detail.conversation.id) {
                this._pendingConversationId = null;
                yield this._resetUserList();
                yield this.layer.setCurrentConversation(detail.conversation);
                yield this.dismissWaitingMessage();
                this.emitComponentEvent("go-chat");
            }
        }));
        // Catch the disconnect and remove the waiting message so the user doesn't get stuck if they are disconnected while creating the conversation
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            if (detail.status === models_1.ConnectionStatus.Disconnected) {
                this.dismissWaitingMessage();
            }
        }, { dontSuppress: true });
        this.addListener(Events_1.ChatEvents.AudioRecordingStarted, () => {
            this.isRecording = true;
            this.createNamedConversationDisabled = true;
        });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;height:100%;font-size:1em}:host hr{display:block;height:1px;border:0;border-top:1px solid var(--default-border-color, #ddd);margin:10px 5px;padding:0}:host .new-conversation{flex:1 1 auto;display:flex;flex-direction:column;height:100%}:host .new-conversation .header .action{cursor:pointer}:host .new-conversation .contact-list{flex:1 1 auto;display:flex;flex-direction:column;overflow:auto}:host .new-conversation .contact-list #user-list{display:flex;flex-direction:column;flex:1}:host .new-conversation .contact-list.hidden{display:none}:host .new-conversation .named-conversation-details{flex:1 1 auto;display:flex;flex-direction:column;overflow:auto;background:var(--secondary-color, #f2f2f2);padding:10px}:host .new-conversation .named-conversation-details.hidden{display:none}:host .new-conversation .named-conversation-details .priority-type-description{text-align:center;padding:15px 30px 0 30px}:host .new-conversation .footer{flex:0 0 auto;background:var(--secondary-color, #f2f2f2);border-top:var(--secondary-border, 1px solid #ddd);display:flex;padding:10px 20px}:host .new-conversation .footer .button{flex:1 1;margin:0 5px;font-size:1.4em}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "new-conversation" },
            this._renderHeader(),
            this._renderContactList(),
            this._renderNamedConversationDetails(),
            this._renderFooter()));
    }
    _renderHeader() {
        const maxParticipants = this.layer.config.behaviour.maxConversationParticipants || 0;
        const participantCountHeaderTemplate = (maxParticipants === 0)
            ? this.translateI18nItem(I18nKeys.TOTAL_CONTACTS)
            : this.translateI18nItem(I18nKeys.TOTAL_CONTACTS_MAX);
        const partipantCountInfo = (this.showCountFrom !== null) && (this.selectedParticipantCount >= this.showCountFrom)
            ? participantCountHeaderTemplate
                .replace("{{number}}", this.selectedParticipantCount.toString())
                .replace("{{maximum}}", (maxParticipants - 1).toString())
            : this.translateI18nItem(I18nKeys.CHOOSE_CONTACT);
        let title = "";
        let subTitle = "";
        if (this.step === NEW_CONVERSATION_STEP.CONTACT_LIST) {
            title = this.translateI18nItem(I18nKeys.SELECT_CONTACTS);
            subTitle = partipantCountInfo;
        }
        if (this.step === NEW_CONVERSATION_STEP.NAMED_CONVERSATION_DETAILS) {
            title = this._config.name;
            subTitle = this._config.shortDescription;
        }
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, title),
            subTitle && window.__CTRender("div", { slot: "sub-heading" }, subTitle)));
    }
    _renderContactList() {
        const currentUserJid = this.layer.getCurrentUserJid();
        const maxParticipants = this.layer.config.behaviour.maxConversationParticipants;
        const userListProps = {
            excludeUsers: [currentUserJid],
            allowSearch: this.allowSearch,
            requireSearch: this.requireSearch,
            searchPlaceholder: this.translateI18nItem(I18nKeys.SEARCH_PLACEHOLDER),
            initialMessage: this.translateI18nItem(I18nKeys.INITIAL_MESSAGE),
            noMatchesMessage: this.translateI18nItem(I18nKeys.NO_MATCHES),
            allowSelection: true,
            maxSelections: (maxParticipants - 1),
            onChangeSelection: (selections) => {
                this.selectedParticipantCount = selections.length;
            },
            // tslint:disable-next-line no-any
            onClickUser: (user) => {
                if (!user.users) {
                    this.layer.showContactInfo(user, null, false);
                }
            },
            onClickGroup: (group) => this.layer.showRoleUsersModal(group)
        };
        const cssClasses = [
            "contact-list"
        ];
        if (this.step !== NEW_CONVERSATION_STEP.CONTACT_LIST)
            cssClasses.push("hidden");
        return (window.__CTRender("div", { class: cssClasses.join(" ") },
            window.__CTRender(components_1.CTUserList, Object.assign({ id: "user-list" }, userListProps))));
    }
    _renderNamedConversationDetails() {
        if (!this._config)
            return null;
        const cssClasses = [
            "named-conversation-details"
        ];
        if (this.step !== NEW_CONVERSATION_STEP.NAMED_CONVERSATION_DETAILS)
            cssClasses.push("hidden");
        const subjectLimit = this._config.maxSubjectLength;
        const descriptionLimit = this._config.maxDescriptionLength;
        return (window.__CTRender("div", { class: cssClasses.join(" ") },
            window.__CTRender("div", { class: "form-item subject" },
                window.__CTRender(components_1.CTTextbox, { type: "text", name: "subject", max: subjectLimit, required: this._config.subjectRequired, fullBorder: true, placeholder: this._config.subjectFieldLabel, callback: e => this._onChangeNamedConversationDetail(e) })),
            window.__CTRender("div", { class: "form-item description" },
                window.__CTRender(components_1.CTTextbox, { type: "textarea", name: "description", max: descriptionLimit, required: this._config.descriptionRequired, fullBorder: true, placeholder: this._config.descriptionFieldLabel, callback: e => this._onChangeNamedConversationDetail(e) })),
            this._renderResponseOptions(),
            this._config.image && (window.__CTRender("div", null,
                window.__CTRender("hr", null),
                window.__CTRender(ct_cl_image_attachment_1.CTCLImageAttachment, { callback: this._setImgAttachment }),
                window.__CTRender("hr", null))),
            this._config.audio && (window.__CTRender("div", null,
                window.__CTRender(ct_cl_audio_attachment_1.CTCLAudioAttachment, { callback: this._setAudioAttachment, allowAttach: this._config.attachPreRecordedFile, allowRecorc: this._config.attachLiveRecordedAudio }),
                window.__CTRender("hr", null))),
            this._config.video && (window.__CTRender("div", null,
                window.__CTRender(ctcl_video_attachment_1.CTCLVideoAttachment, { callback: this._setVideoAttachment }),
                window.__CTRender("hr", null))),
            this._config.chatAvailable === "user-choice" &&
                window.__CTRender(ct_single_checkbox_1.CTSingleCheckbox, { label: "Enable chat", value: true, callback: this._onEnableChatChange })));
    }
    _renderResponseOptions() {
        if (!this._config.alertResponseOptions)
            return null;
        const options = [
            ...this._config.alertResponseOptions
        ];
        if (this._config.alertResponseOptions.length === 0) {
            options.push(Models_1.defaultAlertResponseOption);
        }
        const selectionOptions = options.map((item, idx) => ({ key: idx, value: item.name }));
        return (window.__CTRender("div", null,
            window.__CTRender("div", { class: "form-item priority" },
                window.__CTRender(components_1.CTSelectionList, { name: "priority", options: selectionOptions, selected: 0, forceDropdown: true, onSelect: this._onReplyTemplateChange }))));
    }
    _renderFooter() {
        return (window.__CTRender("div", { class: "footer" }, this._renderFooterButtons()));
    }
    _renderFooterButtons() {
        if (this.step === NEW_CONVERSATION_STEP.CONTACT_LIST) {
            const sheetButtons = this.layer.getConfiguredConversations().map(x => ({
                primaryText: x.name,
                subtitleText: x.shortDescription,
                action: () => this._startNewConversation(x)
            }));
            return [window.__CTRender(ct_action_sheet_1.CTActionSheet, { buttons: sheetButtons, openSheetButtonText: "Create" })];
        }
        if (this.step === NEW_CONVERSATION_STEP.NAMED_CONVERSATION_DETAILS) {
            return [
                window.__CTRender(components_1.CTButton, { type: "primary", class: "button", disabled: !this.isOnline || this.createNamedConversationDisabled, onClick: this._startNamedConversation.bind(this) }, this.translateI18nItem(I18nKeys.CREATE))
            ];
        }
    }
    // === Event handlers === //
    _back() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.step === NEW_CONVERSATION_STEP.CONTACT_LIST) {
                yield this._resetUserList();
                this.emitComponentEvent("go-back");
            }
            if (this.step === NEW_CONVERSATION_STEP.NAMED_CONVERSATION_DETAILS) {
                this.step = NEW_CONVERSATION_STEP.CONTACT_LIST;
                // We want to ensure that the virtual list in the user list gets recalced when we go back to ensure it uses all available space
                // Set timeout out to give it time to be drawn
                // TODO:LR: Put this logic in the user list component so it can recalc when it knows it has done an initial draw
                setTimeout(() => {
                    const userList = this.shadowRoot.querySelector("#user-list");
                    if (userList) {
                        userList.forceRecalcList();
                    }
                }, 250);
            }
        });
    }
    _startNewConversation(config) {
        this._config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, null, config);
        if (this.selectedParticipantCount === 0 && this._config.errorWhenNoContacts) {
            const alert = new Models.DefaultAlerts(this).AlertErrorWithOkayButton(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.ERROR)), this.translateI18nItem(I18nKeys.PARTICIPANT_ERROR), 1, {
                okay: () => {
                    return;
                }
            });
            this.emitEvent(Events_1.ChatEvents._Request_RaiseAlert, alert);
        }
        else if (this.selectedParticipantCount === 0 && this._config.warnWhenNoContacts) {
            const alert = new Models.DefaultAlerts(this).AlertYesNoQuestion(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.ARE_YOU_SURE)), this.translateI18nItem(I18nKeys.WARN_NO_CONTACTS), 1, {
                yes: () => {
                    this._config.namedSettings
                        ? this._goToNamedConversationDetailsStep()
                        : this._startDirectConversation();
                },
                no: () => {
                    return;
                }
            });
            this.emitEvent(Events_1.ChatEvents._Request_RaiseAlert, alert);
        }
        else {
            this._config.namedSettings
                ? this._goToNamedConversationDetailsStep()
                : this._startDirectConversation();
        }
    }
    _onChangeNamedConversationDetail(e) {
        if (e && e.key === "subject") {
            this._namedConversationSubject = e.value;
        }
        if (e && e.key === "description") {
            this._namedConversationDescription = e.value;
        }
        const hasSubject = this._config.subjectRequired ? this._namedConversationSubject.trim().length > 0 : true;
        const hasDescription = this._config.descriptionRequired ? this._namedConversationDescription.trim().length > 0 : true;
        if (!this.isRecording)
            this.createNamedConversationDisabled = !hasSubject || !hasDescription;
        this.forceRedraw();
    }
    _startNamedConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.createNamedConversationDisabled)
                return;
            if (!this._config.suppressAlertModalWarning && this._config.autoAlert) {
                const alert = new Models.DefaultAlerts(this).AlertYesNoQuestion(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.ARE_YOU_SURE)), this.translateI18nItem(I18nKeys.THIS_PRIORITY_WILL_POP_UP_WARNING), 1, {
                    yes: () => __awaiter(this, void 0, void 0, function* () {
                        this._completeStartNamedConversation();
                    }),
                    no: () => __awaiter(this, void 0, void 0, function* () {
                        return;
                    })
                });
                this.emitEvent(Events_1.ChatEvents._Request_RaiseAlert, alert);
            }
            else {
                this._completeStartNamedConversation();
            }
        });
    }
    // === Private functions === //
    _completeStartNamedConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            const participants = yield this._getConversationParticipants(true);
            yield this.showWaitingMessage(this.translateI18nItem(I18nKeys.CREATING_CONVERSATION));
            this._pendingConversationId = yield this.layer.createConversation(participants, this._namedConversationSubject.trim(), this._namedConversationDescription.trim(), this._config.defaultConversationExpiryTTL, this._config.defaultConversationActivityTTL, this._config.constructConfigurationToSend(this._alertResponseOption, this._config.chatAvailable), this._attachments);
        });
    }
    _getSelectedUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            const userList = this.shadowRoot.querySelector("#user-list");
            if (!userList)
                return [];
            const selections = yield userList.getSelections();
            return utils_1.sortUsersByName(selections);
        });
    }
    _resetUserList() {
        return __awaiter(this, void 0, void 0, function* () {
            const userList = this.shadowRoot.querySelector("#user-list");
            if (!userList)
                return;
            yield userList.reset();
        });
    }
    _getConversationParticipants(makeCurrentUserTheOwner) {
        return __awaiter(this, void 0, void 0, function* () {
            const groupMemberMap = yield this.layer.getGroupMemberCache();
            const currentUserJid = this.layer.getCurrentUserJid();
            const selectedUsers = yield this._getSelectedUsers();
            const selectedUserJids = new Map();
            for (const item of selectedUsers) {
                if (item.name) {
                    groupMemberMap[item.name].forEach(user => {
                        selectedUserJids.set(user.jid.toLowerCase(), user);
                    });
                }
                else {
                    selectedUserJids.set(item.jid.toLowerCase(), item);
                }
            }
            const jids = Array.from(selectedUserJids.keys());
            const owners = makeCurrentUserTheOwner
                ? [currentUserJid]
                : null;
            const participants = makeCurrentUserTheOwner
                ? jids
                : [currentUserJid, ...jids];
            return ChatUtils_1.buildConversationParticipants(owners, null, participants);
        });
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTCLNewConversation.prototype, "allowSearch", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTCLNewConversation.prototype, "requireSearch", void 0);
__decorate([
    base_1.prop({ type: base_1.NullableNumber, attribute: true, default: null })
], CTCLNewConversation.prototype, "showCountFrom", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTCLNewConversation.prototype, "selectedParticipantCount", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: NEW_CONVERSATION_STEP.CONTACT_LIST })
], CTCLNewConversation.prototype, "step", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLNewConversation.prototype, "createNamedConversationDisabled", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLNewConversation.prototype, "isRecording", void 0);
exports.CTCLNewConversation = CTCLNewConversation;
CTCLNewConversation.register();


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__strophe_ct__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__strophe_ct___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__strophe_ct__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__strophe_stream_management__ = __webpack_require__(72);
/**
 * Created by Leon.Revill on 11/08/2017.
 */


// Apply Strophe plugins


/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__strophe_stream_management__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__strophe_ct___default.a));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 19/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
const ieWindow = window;
const ieDocument = document;
function getPlatformName() {
    const userAgent = window.navigator.userAgent;
    if (/Android/i.test(userAgent)) {
        return "android";
    }
    else if (/iPhone|iPad|iPod/i.test(userAgent)) {
        return "ios";
    }
    else if (/Electron/i.test(userAgent)) {
        return "electron";
    }
    else if (/Chrome/i.test(userAgent)) {
        return "chrome";
    }
    else if (/Safari/i.test(userAgent)) {
        return "safari";
    }
    else if (/Edge/i.test(userAgent)) {
        return "edge";
    }
    else if (!!ieWindow.MSInputMethodContext && !!ieDocument.documentMode) {
        return "ie";
    }
    else {
        // Unsupported platform
        return null;
    }
}
exports.getPlatformName = getPlatformName;
function isElectron() {
    return (getPlatformName() === "electron");
}
exports.isElectron = isElectron;
function isWindows() {
    return (navigator.userAgent.toUpperCase().indexOf("WINDOWS") !== -1);
}
exports.isWindows = isWindows;
function isDevice() {
    const platformName = getPlatformName();
    return (platformName === "android" || platformName === "ios");
}
exports.isDevice = isDevice;
function isBrowser() {
    const platformName = getPlatformName();
    return (platformName === "chrome" || platformName === "safari" || platformName === "ie" || platformName === "edge");
}
exports.isBrowser = isBrowser;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(24);
const base_1 = __webpack_require__(0);
const mixins_1 = __webpack_require__(92);
// tslint:disable typedef
// tslint:disable no-any
window.__CTRender = window.skate.h;
const allMixins = [
    mixins_1.OverridingStylesMixin,
    mixins_1.ComponentStylesMixin,
    mixins_1.RenderMixin
];
const allMixinsBase = allMixins.reduce((cls, mixin) => mixin(cls), skate.Component);
class CTBaseComponent extends allMixinsBase {
    // === Public utility functions === //
    renderHtml(htmlString, id) {
        if (htmlString === undefined || htmlString === null)
            htmlString = "";
        const containsHtml = (htmlString.indexOf("<") !== -1 || htmlString.indexOf(">") !== -1)
            || (htmlString.indexOf("&lt;") !== -1 || htmlString.indexOf("&gt;") !== -1);
        if (!containsHtml)
            return htmlString;
        const htmlId = `html_${id || performance.now().toString().replace(".", "")}`;
        const skateElement = skate.h("span", { id: htmlId, class: "user-html", style: { display: "inline-block" } });
        this.onRenderComplete(() => {
            if (!this.shadowRoot)
                return;
            const el = this.shadowRoot.querySelector(`#${htmlId}`);
            if (el)
                el.innerHTML = htmlString;
        }, true);
        return skateElement;
    }
    onRenderComplete(handler, oneTimeOnly = false) {
        this.addEventListener("render-complete", function wrappedFunction() {
            handler();
            if (oneTimeOnly) {
                this.removeEventListener("render-complete", wrappedFunction);
            }
        });
    }
    renderedCallback() {
        super.renderedCallback();
        this.dispatchEvent(new CustomEvent("render-complete"));
    }
    forceRedraw() {
        // need to update a property to trigger a re-render
        this._renderTrigger = new Date().getTime();
    }
    // === Static functions === //
    static register() {
        if (this.is === null) {
            // tslint:disable-next-line no-console
            console.error("Could not register component, please ensure that it has a static is property");
            return;
        }
        const existing = customElements.get(this.is);
        if (!existing) {
            customElements.define(this.is, this);
        }
    }
}
CTBaseComponent.is = null;
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTBaseComponent.prototype, "_renderTrigger", void 0);
exports.CTBaseComponent = CTBaseComponent;
// tslint:enable no-any
// tslint:enable typedef


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
class LayerRegistration {
    static addInstance(name, instance) {
        LayerRegistration.ensureRegistrationsObject();
        window.__CTLayers[name] = {
            instance: instance,
            isReady: false
        };
    }
    static getInstance(name) {
        LayerRegistration.ensureRegistrationsObject();
        const layer = window.__CTLayers[name];
        return (!!layer)
            ? layer.instance
            : null;
    }
    static onReady(name, callback) {
        LayerRegistration.ensureRegistrationsObject();
        const layer = window.__CTLayers[name];
        const isReady = (!!layer)
            ? layer.isReady
            : false;
        if (isReady) {
            setTimeout(() => {
                callback();
            }, 0);
        }
        else {
            document.addEventListener(`base-layer-ready:${name}`, (e) => {
                setTimeout(() => {
                    callback();
                }, 0);
            });
        }
    }
    static fireReady(name) {
        LayerRegistration.ensureRegistrationsObject();
        const layer = window.__CTLayers[name];
        if (!!layer) {
            layer.isReady = true;
        }
        document.dispatchEvent(new CustomEvent(`base-layer-ready:${name}`, { detail: { layer: layer.instance } }));
    }
    static ensureRegistrationsObject() {
        if (!window.__CTLayers) {
            window.__CTLayers = {};
        }
    }
}
exports.LayerRegistration = LayerRegistration;
window.CtLayerRegistration = LayerRegistration;
// tslint:enable no-any


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = __webpack_require__(11);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["PLEASE_WAIT"] = "Please wait..."] = "PLEASE_WAIT";
    I18nKeys[I18nKeys["ERROR"] = "Error"] = "ERROR";
    I18nKeys[I18nKeys["ERROR_OCCURED"] = "An error occurred"] = "ERROR_OCCURED";
    I18nKeys[I18nKeys["YES"] = "Yes"] = "YES";
    I18nKeys[I18nKeys["NO"] = "No"] = "NO";
    I18nKeys[I18nKeys["OKAY"] = "Okay"] = "OKAY";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class DefaultAlertsMetadata {
    static _create() {
        return new metadata_1.Metadata(DefaultAlerts, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
DefaultAlertsMetadata._instance = null;
exports.DefaultAlertsMetadata = DefaultAlertsMetadata;
class DefaultAlerts {
    constructor(translationProvider) {
        this._translationProvider = translationProvider;
        this._metadata = DefaultAlertsMetadata.instance;
    }
    AlertWaiting(message) {
        return {
            id: this.generateId(),
            raisedOn: new Date().getTime(),
            priority: 1,
            type: "info",
            title: this._translate(I18nKeys.PLEASE_WAIT),
            body: message,
            showLoadingAnimation: true
        };
    }
    AlertErrorWithOkayButton(title = this._translate(I18nKeys.ERROR), body = this._translate(I18nKeys.OKAY), priority = 1, action = {}) {
        return {
            id: this.generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "error",
            title: title,
            body: body,
            buttons: [
                {
                    text: this._translate(I18nKeys.OKAY),
                    action: action.okay,
                    type: "primary"
                }
            ]
        };
    }
    AlertYesNoQuestion(title, body, priority = 0, action = {}) {
        return {
            id: this.generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "question",
            title: title,
            body: body,
            buttons: [
                {
                    text: this._translate(I18nKeys.NO),
                    action: action.no,
                    type: "primary"
                },
                {
                    text: this._translate(I18nKeys.YES),
                    action: action.yes,
                    type: "primary"
                }
            ]
        };
    }
    AlertQuestion(title, body, priority = 0, buttons) {
        return {
            id: this.generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "question",
            title: title,
            body: body,
            buttons: buttons
        };
    }
    AlertAcknowledge(title, body, priority = 0, action = {}, buttonLabel = this._translate(I18nKeys.OKAY)) {
        return {
            id: this.generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "success",
            title: title,
            body: body,
            buttons: [
                {
                    text: buttonLabel,
                    action: action.okay,
                    type: "primary"
                }
            ]
        };
    }
    generateId() {
        return "alert_" + new Date().getTime().toString();
    }
    _translate(key) {
        return this._translationProvider.translateI18nItem(this._metadata.getI18nItem(key));
    }
}
exports.DefaultAlerts = DefaultAlerts;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var Icons;
(function (Icons) {
    Icons.COMMON = {
        StatusOnline: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M470.923457,555.52087 L517.156966,555.52087 L678.97425,987.033627 L309.106173,987.033627 L470.923457,555.52087 Z M581.144144,581.041767 L537.561355,537.458979 C548.780687,526.239647 555.684891,510.828477 555.684891,493.87619 C555.684891,459.848327 528.068075,432.231511 494.040212,432.231511 C459.950704,432.231511 432.395532,459.848327 432.395532,493.87619 C432.395532,510.828477 439.238091,526.239647 450.457423,537.458979 L406.874635,581.041767 C384.559261,558.726393 370.750852,527.904054 370.750852,493.87619 C370.750852,425.75882 425.922841,370.586831 494.040212,370.586831 C562.095938,370.586831 617.329571,425.75882 617.329571,493.87619 C617.329571,527.904054 603.459518,558.726393 581.144144,581.041767 Z M494.040212,185.652792 L493.916922,185.652792 C664.179527,185.652792 802.14032,323.67523 802.14032,493.87619 C802.14032,579.007493 767.680944,656.063343 711.892509,711.851778 L668.309721,668.268989 C712.940469,623.638241 740.495641,561.993561 740.495641,493.937835 C740.495641,357.764738 630.213309,247.359117 494.040212,247.359117 C357.80547,247.359117 247.461493,357.764738 247.461493,493.937835 C247.461493,561.993561 274.95502,623.638241 319.647413,668.268989 L276.064625,711.851778 C220.337834,656.063343 185.816814,579.007493 185.816814,493.87619 C185.816814,323.67523 323.777607,185.652792 494.040212,185.652792 Z M494.040212,0.718753674 C766.386406,0.718753674 987.197648,221.529996 987.197648,493.87619 C987.197648,630.049288 931.964016,753.338647 842.702519,842.600143 L799.119731,799.017354 C877.22354,720.97519 925.552969,613.097001 925.552969,493.87619 C925.552969,255.557859 732.296898,62.3634333 494.040212,62.3634333 C255.72188,62.3634333 62.5274544,255.557859 62.5274544,493.87619 C62.5274544,613.097001 110.733594,720.97519 188.899048,799.017354 L145.316259,842.600143 C56.0547631,753.338647 0.882774838,630.049288 0.882774838,493.87619 C0.882774838,221.529996 221.632372,0.718753674 494.040212,0.718753674 Z"
            ]
        },
        StatusOffline: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M586.678306,210.286115 C562.139482,203.996961 536.419525,200.652792 509.916922,200.652792 L510.040212,200.652792 C339.777607,200.652792 201.816814,338.67523 201.816814,508.87619 C201.816814,535.342777 205.153389,561.028843 211.426433,585.537988 L264.560722,532.403699 C263.833299,524.67956 263.461493,516.852047 263.461493,508.937835 C263.461493,372.764738 373.80547,262.359117 510.040212,262.359117 C517.95418,262.359117 525.7807,262.732021 533.503206,263.461215 L586.678306,210.286115 Z M806.86787,425.990261 C814.213724,452.364232 818.14032,480.162284 818.14032,508.87619 C818.14032,594.007493 783.680944,671.063343 727.892509,726.851778 L684.309721,683.268989 C728.940469,638.638241 756.495641,576.993561 756.495641,508.937835 C756.495641,498.546495 755.853446,488.305204 754.606559,478.251572 L806.86787,425.990261 Z",
                "M729.725748,67.238671 C663.573003,34.2656239 588.970927,15.7187537 510.040212,15.7187537 C237.632372,15.7187537 16.8827748,236.529996 16.8827748,508.87619 C16.8827748,587.810373 35.420918,662.415536 68.3909758,728.573445 L114.711707,682.252714 C91.4312107,629.204161 78.5274544,570.558265 78.5274544,508.87619 C78.5274544,270.557859 271.72188,77.3634333 510.040212,77.3634333 C571.684303,77.3634333 630.316005,90.2960769 683.367584,113.596835 L729.725747,67.2386739 L729.725748,67.238671 Z M948.986253,283.87188 C983.639793,351.333945 1003.19765,427.822772 1003.19765,508.87619 C1003.19765,645.049288 947.964016,768.338647 858.702519,857.600143 L815.119731,814.017354 C893.22354,735.97519 941.552969,628.097001 941.552969,508.87619 C941.552969,445.074231 927.701805,384.506419 902.844202,330.013931 L948.98625,283.871881 L948.986253,283.87188 Z",
                "M568.387956,664.470175 L694.97425,1002.03363 L325.106173,1002.03363 L381.675174,851.182956 L568.387956,664.470175 Z M38.537334,1018.85532 L3.14468065,983.537334 L984.462666,0.144680652 L1019.85532,35.462666 L38.537334,1018.85532 Z"
            ]
        },
        LoadingSpinner: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1005.714 512c0 272.571-221.143 493.714-493.714 493.714s-493.714-221.143-493.714-493.714c0-248 182.857-453.143 420.571-488.571v130.286c-166.857 33.714-292.571 181.714-292.571 358.286 0 201.714 164 365.714 365.714 365.714s365.714-164 365.714-365.714c0-176.571-125.714-324.571-292.571-358.286v-130.286c237.714 35.429 420.571 240.571 420.571 488.571z"
            ]
        },
        Menu: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M64 192h896v128h-896v-128z",
                "M64 448h896v128h-896v-128z",
                "M64 704h896v128h-896v-128z"
            ]
        },
        ChevronDown: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M614.286 420.571q0 7.429-5.714 13.143l-266.286 266.286q-5.714 5.714-13.143 5.714t-13.143-5.714l-266.286-266.286q-5.714-5.714-5.714-13.143t5.714-13.143l28.571-28.571q5.714-5.714 13.143-5.714t13.143 5.714l224.571 224.571 224.571-224.571q5.714-5.714 13.143-5.714t13.143 5.714l28.571 28.571q5.714 5.714 5.714 13.143z"
            ]
        },
        ChevronLeft: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M669.143 172l-303.429 303.429 303.429 303.429q10.857 10.857 10.857 25.714t-10.857 25.714l-94.857 94.857q-10.857 10.857-25.714 10.857t-25.714-10.857l-424-424q-10.857-10.857-10.857-25.714t10.857-25.714l424-424q10.857-10.857 25.714-10.857t25.714 10.857l94.857 94.857q10.857 10.857 10.857 25.714t-10.857 25.714z"
            ]
        },
        ChevronRight: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M632.571 501.143l-424 424q-10.857 10.857-25.714 10.857t-25.714-10.857l-94.857-94.857q-10.857-10.857-10.857-25.714t10.857-25.714l303.429-303.429-303.429-303.429q-10.857-10.857-10.857-25.714t10.857-25.714l94.857-94.857q10.857-10.857 25.714-10.857t25.714 10.857l424 424q10.857 10.857 10.857 25.714t-10.857 25.714z"
            ]
        },
        ChevronUp: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M614.286 676.571q0 7.429-5.714 13.143l-28.571 28.571q-5.714 5.714-13.143 5.714t-13.143-5.714l-224.571-224.571-224.571 224.571q-5.714 5.714-13.143 5.714t-13.143-5.714l-28.571-28.571q-5.714-5.714-5.714-13.143t5.714-13.143l266.286-266.286q5.714-5.714 13.143-5.714t13.143 5.714l266.286 266.286q5.714 5.714 5.714 13.143z"
            ]
        },
        ClearTextbox: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1014.662 822.66c-0.004-0.004-0.008-0.008-0.012-0.010l-310.644-310.65 310.644-310.65c0.004-0.004 0.008-0.006 0.012-0.010 3.344-3.346 5.762-7.254 7.312-11.416 4.246-11.376 1.824-24.682-7.324-33.83l-146.746-146.746c-9.148-9.146-22.45-11.566-33.828-7.32-4.16 1.55-8.070 3.968-11.418 7.31 0 0.004-0.004 0.006-0.008 0.010l-310.648 310.652-310.648-310.65c-0.004-0.004-0.006-0.006-0.010-0.010-3.346-3.342-7.254-5.76-11.414-7.31-11.38-4.248-24.682-1.826-33.83 7.32l-146.748 146.748c-9.148 9.148-11.568 22.452-7.322 33.828 1.552 4.16 3.97 8.072 7.312 11.416 0.004 0.002 0.006 0.006 0.010 0.010l310.65 310.648-310.65 310.652c-0.002 0.004-0.006 0.006-0.008 0.010-3.342 3.346-5.76 7.254-7.314 11.414-4.248 11.376-1.826 24.682 7.322 33.83l146.748 146.746c9.15 9.148 22.452 11.568 33.83 7.322 4.16-1.552 8.070-3.97 11.416-7.312 0.002-0.004 0.006-0.006 0.010-0.010l310.648-310.65 310.648 310.65c0.004 0.002 0.008 0.006 0.012 0.008 3.348 3.344 7.254 5.762 11.414 7.314 11.378 4.246 24.684 1.826 33.828-7.322l146.746-146.748c9.148-9.148 11.57-22.454 7.324-33.83-1.552-4.16-3.97-8.068-7.314-11.414z"
            ]
        },
        CircleCross: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 0c-282.77 0-512 229.23-512 512s229.23 512 512 512 512-229.23 512-512-229.23-512-512-512zM512 928c-229.75 0-416-186.25-416-416s186.25-416 416-416 416 186.25 416 416-186.25 416-416 416z",
                "M672 256l-160 160-160-160-96 96 160 160-160 160 96 96 160-160 160 160 96-96-160-160 160-160z"
            ]
        },
        Info: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M448 304c0-26.4 21.6-48 48-48h32c26.4 0 48 21.6 48 48v32c0 26.4-21.6 48-48 48h-32c-26.4 0-48-21.6-48-48v-32z",
                "M640 768h-256v-64h64v-192h-64v-64h192v256h64z",
                "M512 0c-282.77 0-512 229.23-512 512s229.23 512 512 512 512-229.23 512-512-229.23-512-512-512zM512 928c-229.75 0-416-186.25-416-416s186.25-416 416-416 416 186.25 416 416-186.25 416-416 416z"
            ]
        },
        RequiredField: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1022.442 406.048c-4.274-13.2-16.566-22.142-30.442-22.142l-343.458-0.012-106.122-325.128c-4.296-13.164-16.572-22.072-30.42-22.072s-26.124 8.908-30.42 22.072l-106.12 325.128-343.46 0.012c-13.876 0-26.168 8.942-30.444 22.142-4.274 13.2 0.446 27.65 11.688 35.784l277.736 200.922-106.056 325.026c-4.298 13.174 0.37 27.618 11.568 35.784 11.198 8.162 26.378 8.194 37.606 0.070l277.902-201.006 277.9 201.004c5.598 4.048 12.176 6.072 18.754 6.072 6.62 0 13.236-2.048 18.854-6.142 11.198-8.166 15.868-22.61 11.568-35.784l-106.056-325.024 277.734-200.922c11.242-8.132 15.962-22.582 11.688-35.784z"
            ]
        },
        ShowPassword: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 192c-223.318 0-416.882 130.042-512 320 95.118 189.958 288.682 320 512 320 223.312 0 416.876-130.042 512-320-95.116-189.958-288.688-320-512-320zM764.45 361.704c60.162 38.374 111.142 89.774 149.434 150.296-38.292 60.522-89.274 111.922-149.436 150.296-75.594 48.218-162.89 73.704-252.448 73.704-89.56 0-176.858-25.486-252.452-73.704-60.158-38.372-111.138-89.772-149.432-150.296 38.292-60.524 89.274-111.924 149.434-150.296 3.918-2.5 7.876-4.922 11.86-7.3-9.96 27.328-15.41 56.822-15.41 87.596 0 141.382 114.616 256 256 256 141.382 0 256-114.618 256-256 0-30.774-5.452-60.268-15.408-87.598 3.978 2.378 7.938 4.802 11.858 7.302v0zM512 416c0 53.020-42.98 96-96 96s-96-42.98-96-96 42.98-96 96-96 96 42.982 96 96z"
            ]
        },
        AlertQuestion: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 786.286v-109.714q0-8-5.143-13.143t-13.143-5.143h-109.714q-8 0-13.143 5.143t-5.143 13.143v109.714q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143zM658.286 402.286q0-50.286-31.714-93.143t-79.143-66.286-97.143-23.429q-138.857 0-212 121.714-8.571 13.714 4.571 24l75.429 57.143q4 3.429 10.857 3.429 9.143 0 14.286-6.857 30.286-38.857 49.143-52.571 19.429-13.714 49.143-13.714 27.429 0 48.857 14.857t21.429 33.714q0 21.714-11.429 34.857t-38.857 25.714q-36 16-66 49.429t-30 71.714v20.571q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143q0-10.857 12.286-28.286t31.143-28.286q18.286-10.286 28-16.286t26.286-20 25.429-27.429 16-34.571 7.143-46.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        AlertWarning: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 785.714v-108.571c0-10.286-8-18.857-18.286-18.857h-109.714c-10.286 0-18.286 8.571-18.286 18.857v108.571c0 10.286 8 18.857 18.286 18.857h109.714c10.286 0 18.286-8.571 18.286-18.857zM584 572l10.286-262.286c0-3.429-1.714-8-5.714-10.857-3.429-2.857-8.571-6.286-13.714-6.286h-125.714c-5.143 0-10.286 3.429-13.714 6.286-4 2.857-5.714 8.571-5.714 12l9.714 261.143c0 7.429 8.571 13.143 19.429 13.143h105.714c10.286 0 18.857-5.714 19.429-13.143zM576 38.286l438.857 804.571c12.571 22.286 12 49.714-1.143 72s-37.143 36-62.857 36h-877.714c-25.714 0-49.714-13.714-62.857-36s-13.714-49.714-1.143-72l438.857-804.571c12.571-23.429 37.143-38.286 64-38.286s51.429 14.857 64 38.286z"
            ]
        },
        Search: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M658.286 475.429c0-141.143-114.857-256-256-256s-256 114.857-256 256 114.857 256 256 256 256-114.857 256-256zM950.857 950.857c0 40-33.143 73.143-73.143 73.143-19.429 0-38.286-8-51.429-21.714l-196-195.429c-66.857 46.286-146.857 70.857-228 70.857-222.286 0-402.286-180-402.286-402.286s180-402.286 402.286-402.286 402.286 180 402.286 402.286c0 81.143-24.571 161.143-70.857 228l196 196c13.143 13.143 21.143 32 21.143 51.429z"
            ]
        },
        Filter: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M869.49 192l-293.49 293.49v296.542l-128 32v-328.542l-293.49-293.49h714.98zM1024 128h-1024l384 384v384l256-64v-320l384-384z"
            ]
        },
        UserIconEmpty: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M686.286 448c80.571 23.429 191.429 102.857 191.429 362.857 0 117.714-87.429 213.143-194.857 213.143h-488c-107.429 0-194.857-95.429-194.857-213.143 0-260 110.857-339.429 191.429-362.857-28.571-45.143-45.143-98.286-45.143-155.429 0-161.143 131.429-292.571 292.571-292.571s292.571 131.429 292.571 292.571c0 57.143-16.571 110.286-45.143 155.429zM438.857 73.143c-121.143 0-219.429 98.286-219.429 219.429s98.286 219.429 219.429 219.429 219.429-98.286 219.429-219.429-98.286-219.429-219.429-219.429zM682.857 950.857c66.857 0 121.714-62.286 121.714-140 0-180-60.571-292.571-173.714-298.286-51.429 45.143-118.286 72.571-192 72.571s-140.571-27.429-192-72.571c-113.143 5.714-173.714 118.286-173.714 298.286 0 77.714 54.857 140 121.714 140h488z"
            ]
        },
        PlusSign: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M804.571 420.571v109.714q0 22.857-16 38.857t-38.857 16h-237.714v237.714q0 22.857-16 38.857t-38.857 16h-109.714q-22.857 0-38.857-16t-16-38.857v-237.714h-237.714q-22.857 0-38.857-16t-16-38.857v-109.714q0-22.857 16-38.857t38.857-16h237.714v-237.714q0-22.857 16-38.857t38.857-16h109.714q22.857 0 38.857 16t16 38.857v237.714h237.714q22.857 0 38.857 16t16 38.857z"
            ]
        },
        Tick: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M864 128l-480 480-224-224-160 160 384 384 640-640z"
            ]
        },
        TickHollow: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M397.434 917.696l-397.868-391.6 197.378-194.27 200.49 197.332 429.62-422.852 197.378 194.27-626.998 617.12zM107.912 526.096l289.524 284.962 518.656-510.482-89.036-87.632-429.62 422.852-200.49-197.334-89.034 87.634z"
            ]
        },
        Cross: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1014.662 822.66c-0.004-0.004-0.008-0.008-0.012-0.010l-310.644-310.65 310.644-310.65c0.004-0.004 0.008-0.006 0.012-0.010 3.344-3.346 5.762-7.254 7.312-11.416 4.246-11.376 1.824-24.682-7.324-33.83l-146.746-146.746c-9.148-9.146-22.45-11.566-33.828-7.32-4.16 1.55-8.070 3.968-11.418 7.31 0 0.004-0.004 0.006-0.008 0.010l-310.648 310.652-310.648-310.65c-0.004-0.004-0.006-0.006-0.010-0.010-3.346-3.342-7.254-5.76-11.414-7.31-11.38-4.248-24.682-1.826-33.83 7.32l-146.748 146.748c-9.148 9.148-11.568 22.452-7.322 33.828 1.552 4.16 3.97 8.072 7.312 11.416 0.004 0.002 0.006 0.006 0.010 0.010l310.65 310.648-310.65 310.652c-0.002 0.004-0.006 0.006-0.008 0.010-3.342 3.346-5.76 7.254-7.314 11.414-4.248 11.376-1.826 24.682 7.322 33.83l146.748 146.746c9.15 9.148 22.452 11.568 33.83 7.322 4.16-1.552 8.070-3.97 11.416-7.312 0.002-0.004 0.006-0.006 0.010-0.010l310.648-310.65 310.648 310.65c0.004 0.002 0.008 0.006 0.012 0.008 3.348 3.344 7.254 5.762 11.414 7.314 11.378 4.246 24.684 1.826 33.828-7.322l146.746-146.748c9.148-9.148 11.57-22.454 7.324-33.83-1.552-4.16-3.97-8.068-7.314-11.414z"
            ]
        },
        MenuDots: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M384 192c0-70.692 57.308-128 128-128s128 57.308 128 128c0 70.692-57.308 128-128 128s-128-57.308-128-128zM384 512c0-70.692 57.308-128 128-128s128 57.308 128 128c0 70.692-57.308 128-128 128s-128-57.308-128-128zM384 832c0-70.692 57.308-128 128-128s128 57.308 128 128c0 70.692-57.308 128-128 128s-128-57.308-128-128z"
            ]
        },
        User: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M576 706.612v-52.78c70.498-39.728 128-138.772 128-237.832 0-159.058 0-288-192-288s-192 128.942-192 288c0 99.060 57.502 198.104 128 237.832v52.78c-217.102 17.748-384 124.42-384 253.388h896c0-128.968-166.898-235.64-384-253.388z"
            ]
        },
        Users: {
            viewBox: "0 0 1408 1024",
            paths: [
                "M768 705.306v-13.256c92.524-35.408 160-145.59 160-276.050 0-159.058-100.29-288-224-288-123.712 0-224 128.942-224 288 0 130.46 67.476 240.642 160 276.050v13.256c-217.102 8.874-384 62.21-384 126.694v128h896v-128c0-64.484-166.898-117.82-384-126.694z",
                "M1152 448.592v-5.078c73.032-20.754 128-111.146 128-219.514 0-123.712-71.634-224-160-224s-160 100.288-160 224c0 108.37 54.968 198.76 128 219.514v5.078c-31.81 1.172-62.054 4.074-89.878 8.412-6.28 68.208-28.092 131.24-61.738 182.996h471.616v-96c0-49.414-112.006-90.1-256-95.408z",
                "M409.878 457.004c-27.824-4.338-58.070-7.24-89.878-8.412v-5.078c73.032-20.754 128-111.146 128-219.514 0-123.712-71.634-224-160-224s-160 100.288-160 224c0 108.37 54.968 198.76 128 219.514v5.078c-143.994 5.308-256 45.994-256 95.408v96h471.618c-33.646-51.756-55.458-114.788-61.74-182.996z"
            ]
        }
    };
})(Icons = exports.Icons || (exports.Icons = {}));


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const plugins_1 = __webpack_require__(27);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
const Models_1 = __webpack_require__(5);
const utils_1 = __webpack_require__(2);
const ctcl_audio_recorder_player_1 = __webpack_require__(49);
const Events_1 = __webpack_require__(4);
const ctcl_video_recorder_player_1 = __webpack_require__(51);
var AttachmentHandlerViewState;
(function (AttachmentHandlerViewState) {
    // tslint:disable no-any
    AttachmentHandlerViewState[AttachmentHandlerViewState["LOADING"] = "loading"] = "LOADING";
    AttachmentHandlerViewState[AttachmentHandlerViewState["IMAGE_FILE"] = "image-file"] = "IMAGE_FILE";
    AttachmentHandlerViewState[AttachmentHandlerViewState["AUDIO_FILE"] = "audio-file"] = "AUDIO_FILE";
    AttachmentHandlerViewState[AttachmentHandlerViewState["VIDEO_FILE"] = "video-file"] = "VIDEO_FILE";
    AttachmentHandlerViewState[AttachmentHandlerViewState["ERROR"] = "error"] = "ERROR";
    // tslint:enable no-any
})(AttachmentHandlerViewState || (AttachmentHandlerViewState = {}));
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ERROR_DEFAULT"] = "There was an error loading the attachment."] = "ERROR_DEFAULT";
    I18nKeys[I18nKeys["ERROR_NO_URI"] = "No attachment URI provided"] = "ERROR_NO_URI";
    I18nKeys[I18nKeys["ERROR_FAILED_DOWNLOAD"] = "Attachment failed to download."] = "ERROR_FAILED_DOWNLOAD";
    I18nKeys[I18nKeys["ERROR_CANNOT_LOAD_AUDIO"] = "Unable to load audio file."] = "ERROR_CANNOT_LOAD_AUDIO";
    I18nKeys[I18nKeys["ERROR_UNSUPPORTED_ATTACHMENT"] = "Unsupported attachment type."] = "ERROR_UNSUPPORTED_ATTACHMENT";
    I18nKeys[I18nKeys["ERROR_TAP_TO_RETRY"] = "Tap to retry."] = "ERROR_TAP_TO_RETRY";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLAttachmentHandler = class CTCLAttachmentHandler extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        this._allowRetry = true;
        this._options = {};
        this._defaultOptions = {
            height: 150,
            width: 150,
            quality: 100
        };
        // === Private === //
        this._processRemoteAttachment = () => __awaiter(this, void 0, void 0, function* () {
            try {
                this.state = AttachmentHandlerViewState.LOADING;
                const bypass = this.type === Models_1.SupportedAttachmentType.VIDEO;
                const filepath = yield this.layer.downloadFileWithoutCatch(this.uri, bypass);
                this._processAttachmentAfterDownload(filepath);
            }
            catch (ex) {
                this._errorMessage = this.translateI18nItem(I18nKeys.ERROR_FAILED_DOWNLOAD);
                this._allowRetry = true;
                this.state = AttachmentHandlerViewState.ERROR;
            }
        });
        this._openImageFullScreen = () => __awaiter(this, void 0, void 0, function* () {
            if (!utils_1.isDesktop() && this.allowOpenImageInFullScreen) {
                yield this.layer.showMediaFullscreen(this._fullImgFilepath);
            }
        });
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._options = Object.assign({}, this._options, this._defaultOptions);
            if (this.uri && this.uri.includes("http")) {
                this._processRemoteAttachment();
            }
            else {
                if (this.uri) {
                    this._processAttachmentAfterDownload(this.uri, true);
                }
                else {
                    this._errorMessage = this.translateI18nItem(I18nKeys.ERROR_NO_URI);
                    this._allowRetry = false;
                    this.state = AttachmentHandlerViewState.ERROR;
                }
            }
        });
    }
    setupListeners() { }
    _processAttachmentAfterDownload(filepath, suppressEvents = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!suppressEvents)
                this.emitEvent(Events_1.ChatEvents.AttachmentDownloadComplete, new Events_1.AttachmentDownloadComplete(filepath, this.conversationId, this.type));
            switch (this.type) {
                case Models_1.SupportedAttachmentType.AUDIO:
                    setTimeout(() => {
                        this.file = filepath;
                        this.state = AttachmentHandlerViewState.AUDIO_FILE;
                        if (!suppressEvents)
                            this.emitEvent(Events_1.ChatEvents.AudioAttachmentDownloadComplete, new Events_1.AudioAttachmentDownloadComplete(this.file));
                    }, 1000);
                    break;
                case Models_1.SupportedAttachmentType.IMAGE:
                    // Handle a base 64 supplied image
                    if (this.uri.includes("data:image")) {
                        this.file = this.uri;
                    }
                    else {
                        this.file = yield plugins_1.getThumbnail(filepath, this._options.width, this._options.height, this._options.quality);
                    }
                    this._fullImgFilepath = filepath;
                    this.state = AttachmentHandlerViewState.IMAGE_FILE;
                    break;
                case Models_1.SupportedAttachmentType.VIDEO:
                    this.file = filepath;
                    this.state = AttachmentHandlerViewState.VIDEO_FILE;
                    break;
                default:
                    throw new Error(this.translateI18nItem(I18nKeys.ERROR_UNSUPPORTED_ATTACHMENT));
            }
        });
    }
    // === Render === //
    generateComponentMarkup() {
        let inner;
        switch (this.state) {
            case AttachmentHandlerViewState.AUDIO_FILE:
                inner = this._renderAudio();
                break;
            case AttachmentHandlerViewState.IMAGE_FILE:
                inner = this._renderImage();
                break;
            case AttachmentHandlerViewState.VIDEO_FILE:
                inner = this._renderVideo();
                break;
            case AttachmentHandlerViewState.ERROR:
                inner = this._renderError();
                break;
            case AttachmentHandlerViewState.LOADING:
            default:
                inner = this._renderLoading();
                break;
        }
        return (window.__CTRender("div", { class: "container" }, inner));
    }
    _renderLoading() {
        return window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true });
    }
    _renderError() {
        return (window.__CTRender("div", { class: "error", onClick: this._allowRetry ? this._processRemoteAttachment : null },
            window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.AlertWarning }),
            window.__CTRender("p", null,
                this._errorMessage || this.translateI18nItem(I18nKeys.ERROR_DEFAULT),
                this._allowRetry && ` ${this.translateI18nItem(I18nKeys.ERROR_TAP_TO_RETRY)}`)));
    }
    _renderImage() {
        return window.__CTRender("img", { src: this.file, onClick: this._openImageFullScreen });
    }
    _renderAudio() {
        return window.__CTRender(ctcl_audio_recorder_player_1.CTCLAudioRecorderPlayer, { showRecord: false, source: this.file, stream: this.stream, volumeToPlayAt: this.volumeToPlayAt, disablePlay: this.disablePlay, preventRemoteStart: this.preventRemoteStart });
    }
    _renderVideo() {
        return window.__CTRender(ctcl_video_recorder_player_1.CTCLVideoRecorderPlayer, { source: this.file, showRecord: false, allowRemoval: false, showControls: true });
    }
};
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLAttachmentHandler.prototype, "uri", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLAttachmentHandler.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLAttachmentHandler.prototype, "file", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: AttachmentHandlerViewState.LOADING })
], CTCLAttachmentHandler.prototype, "state", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLAttachmentHandler.prototype, "allowOpenImageInFullScreen", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLAttachmentHandler.prototype, "conversationId", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAttachmentHandler.prototype, "disablePlay", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: Models_1.VolumeStream.Music })
], CTCLAttachmentHandler.prototype, "stream", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: -1 })
], CTCLAttachmentHandler.prototype, "volumeToPlayAt", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAttachmentHandler.prototype, "preventRemoteStart", void 0);
CTCLAttachmentHandler = __decorate([
    component_1.component({ tag: "ctcl-attachment-handler", styles: [`:host{display:block;width:100%;height:100%}:host div.container{height:100%;align-items:center;display:flex;justify-content:center}:host div.container div.error{display:flex;align-items:center}:host div.container div.error ct-icon{margin-right:10px}:host div.container img{height:100%}
    `], i18nKeys: I18nKeys })
], CTCLAttachmentHandler);
exports.CTCLAttachmentHandler = CTCLAttachmentHandler;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const components_1 = __webpack_require__(3);
const Models_1 = __webpack_require__(5);
const renderUtils_1 = __webpack_require__(8);
const simple_audio_player_1 = __webpack_require__(56);
const Events_1 = __webpack_require__(4);
const simple_audio_recorder_1 = __webpack_require__(152);
const models_1 = __webpack_require__(1);
const Keys_1 = __webpack_require__(20);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["NO_RECORDING_SOURCE"] = "No microphone has been detected on your system."] = "NO_RECORDING_SOURCE";
    I18nKeys[I18nKeys["GENERAL_ERROR"] = "There was an error trying to record audio."] = "GENERAL_ERROR";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLAudioRecorderPlayer = class CTCLAudioRecorderPlayer extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        this._player = new simple_audio_player_1.SimpleAudioPlayer((e) => this._statusCallback(e));
        this._recorder = new simple_audio_recorder_1.SimpleAudioRecorder((filepath) => this._onRecordingFinished(filepath), (e) => this._onRecordingError(e));
        this._currentlyRecording = false;
        this._removeAudio = () => __awaiter(this, void 0, void 0, function* () {
            this.source = "";
            this.currentTime = 0;
            this.duration = 0;
            if (this.onAudioRemoved)
                this.onAudioRemoved();
        });
        this._play = (delay = 200) => this._buffer(() => {
            this.emitEvent(Events_1.ChatEvents.MuteAlertToPlayOtherAudio);
            if (!this._timer) {
                this._timer = setInterval(() => this.currentTime += 200, 200);
            }
            setTimeout(() => {
                this.disablePlay = false;
                this._player.play();
            }, delay);
        });
        this._pause = () => this._buffer(() => {
            this.disablePlay = false;
            clearInterval(this._timer);
            delete this._timer;
            this._player.pause();
            this.emitEvent(Events_1.ChatEvents.ResumeAlertAfterPlayingAudio);
        });
        this._stop = () => this._buffer(() => {
            clearInterval(this._timer);
            delete this._timer;
            this._player.stop(true);
            this.currentTime = 0;
            this.emitEvent(Events_1.ChatEvents.ResumeAlertAfterPlayingAudio);
        });
        this._startRecording = () => this._buffer(() => {
            if (this._currentlyRecording) {
                this._currentlyRecording = false;
                this._recorder.stop();
                this.emitEvent(Events_1.ChatEvents.AudioRecordingStopped);
                this._stopRecordingIndicator();
            }
            else {
                this._startRecordingIndicator();
                this.emitEvent(Events_1.ChatEvents.AudioRecordingStarted);
                this._currentlyRecording = true;
                this._recorder.start();
            }
        });
        this._onRecordingFinished = (filepath) => {
            if (filepath) {
                this.source = filepath;
                this.initPlayer(this.source);
                if (this.onRecordingFinished) {
                    this.onRecordingFinished(this.source);
                }
            }
            else {
                this.source = "";
            }
        };
        this._onRecordingError = (e) => {
            this._stopRecordingIndicator();
            let error = I18nKeys.GENERAL_ERROR;
            switch (e) {
                case simple_audio_recorder_1.AudioRecorderError.NoAudioDevicesFound:
                    error = I18nKeys.NO_RECORDING_SOURCE;
                    break;
            }
            const alert = new models_1.DefaultAlerts(this).AlertErrorWithOkayButton(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.ERROR)), this.translateI18nItem(error), 1, {
                okay: () => {
                    return;
                }
            });
            this.emitEvent(Events_1.ChatEvents._Request_RaiseAlert, alert);
        };
        this._startRecordingIndicator = () => {
            let flash = true;
            if (this._recordBtn) {
                setTimeout(() => this._recordBtn.classList.add("flash"), 100);
                this._flashTimer = setInterval(() => {
                    flash ? this._recordBtn.classList.remove("flash") : this._recordBtn.classList.add("flash");
                    flash = !flash;
                }, 500);
            }
        };
        this._stopRecordingIndicator = () => {
            clearInterval(this._flashTimer);
            if (this._recordBtn) {
                this._recordBtn.classList.remove("flash");
            }
        };
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source) {
                this.initPlayer(this.source);
            }
        });
    }
    setupListeners() {
        if (this.preventRemoteStart === false) {
            this.addListener(Events_1.ChatEvents.RemotelyStartAudioPlayer, () => {
                this._play(1000);
            });
            this.addEventListener(Events_1.ChatEvents.RemotelyStopAudioPlayer, () => {
                this._stop();
            });
        }
    }
    // === Private === //
    /**
     * Can be used to buffer inputs. An attempt to stop really fast double clicks / taps messing
     * things up.
     */
    _buffer(action, duration = 200) {
        if (!this._bufferTime || new Date().valueOf() > this._bufferTime + duration) {
            this._bufferTime = new Date().valueOf();
            action();
        }
    }
    initPlayer(source) {
        this._player.setAudio(source, 1, this.volumeToPlayAt, this.stream, (d) => this.duration = d, () => this.isReady = true);
    }
    _statusCallback(e) {
        this.mediaStatus = e;
        // Audio track ended
        if (this.mediaStatus === simple_audio_player_1.MediaStatus.MEDIA_STOPPED) {
            this.disablePlay = false;
            clearInterval(this._timer);
            delete this._timer;
            this.currentTime = 0;
            this.emitEvent(Events_1.ChatEvents.ResumeAlertAfterPlayingAudio);
        }
    }
    // === Render === //
    /**
     * Converts milliseconds into a time format like: 0:00. Is not very clever.
     */
    _millisToMinutesAndSeconds(millis) {
        if (millis === 0) {
            return `0:00`;
        }
        const minutes = Math.floor(millis / 60000);
        const seconds = Math.round((millis % 60000) / 1000);
        return `${minutes}:${(seconds < 10 ? "0" : "")}${seconds}`;
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._player.stop(true);
        this._player.release();
    }
    generateComponentMarkup() {
        const recordEnabled = this.source ? false : true;
        const playEnabled = this._currentlyRecording || this.disablePlay ? false : this.showRecord && this.source ? true : (this.source ? true : false);
        // const playEnabled: boolean = this._currentlyRecording ? false : this.isReady && (this.showRecord && this.source ? true : (this.source ? true : false));
        const stopEnabled = this._currentlyRecording ? false : playEnabled && (this.mediaStatus === simple_audio_player_1.MediaStatus.MEDIA_RUNNING || this.mediaStatus === simple_audio_player_1.MediaStatus.MEDIA_PAUSED);
        const removalEnabled = this.allowRemoval && this.source && this.mediaStatus !== simple_audio_player_1.MediaStatus.MEDIA_RUNNING;
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("div", { class: "controls" },
                this.showRecord &&
                    window.__CTRender("div", { class: `action ${recordEnabled ? "" : "disabled"}`, ref: (ref) => this._recordBtn = ref },
                        window.__CTRender(components_1.CTIcon, { color: "red", width: "16", height: "16", icon: Models_1.Icons.UI.CircleFilled, onClick: this._startRecording })),
                window.__CTRender("div", { class: `action ${playEnabled ? "" : "disabled"}` }, this.mediaStatus === simple_audio_player_1.MediaStatus.MEDIA_RUNNING
                    ? window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Pause, onClick: playEnabled ? this._pause : null })
                    : window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Play, onClick: playEnabled ? this._play : null })),
                window.__CTRender("div", { class: `action ${stopEnabled ? "" : "disabled"}` },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.SquareFilled, onClick: stopEnabled ? this._stop : null })),
                (this.allowRemoval && this.source) &&
                    window.__CTRender("div", { class: `action ${removalEnabled ? "" : "disabled"}` },
                        window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Cross, onClick: removalEnabled ? this._removeAudio : null }))),
            this.source &&
                window.__CTRender("div", { class: "progress" },
                    window.__CTRender("div", { class: "length left" },
                        window.__CTRender("span", null, this._millisToMinutesAndSeconds(this.currentTime))),
                    window.__CTRender("div", { class: "bar" },
                        window.__CTRender("span", { style: renderUtils_1.buildStyles({ width: `${(this.currentTime / this.duration) * 100}%` }) })),
                    window.__CTRender("div", { class: "length right" },
                        window.__CTRender("span", null, this._millisToMinutesAndSeconds(this.duration))))));
    }
};
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioRecorderPlayer.prototype, "showRecord", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioRecorderPlayer.prototype, "allowRemoval", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioRecorderPlayer.prototype, "disablePlay", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLAudioRecorderPlayer.prototype, "source", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTCLAudioRecorderPlayer.prototype, "mediaStatus", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTCLAudioRecorderPlayer.prototype, "currentTime", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTCLAudioRecorderPlayer.prototype, "duration", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioRecorderPlayer.prototype, "isReady", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: Models_1.VolumeStream.Music })
], CTCLAudioRecorderPlayer.prototype, "stream", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: -1 })
], CTCLAudioRecorderPlayer.prototype, "volumeToPlayAt", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioRecorderPlayer.prototype, "preventRemoteStart", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTCLAudioRecorderPlayer.prototype, "onAudioRemoved", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTCLAudioRecorderPlayer.prototype, "onRecordingFinished", void 0);
CTCLAudioRecorderPlayer = __decorate([
    component_1.component({ tag: "ctcl-audio-recorder-player", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex:1}:host div.container{display:flex;flex:1}:host div.container div.progress{display:flex;width:100%;align-items:center;margin:auto 0}:host div.container div.progress div.bar{display:flex;flex:1;background-color:var(--default-border-color, #ddd);height:3px;width:100%}:host div.container div.progress div.bar span{display:inline-block;height:3px;background-color:var(--primary-color, #22b1c8);transition:all 100ms linear}:host div.container div.progress div.length{font-size:0.8em}:host div.container div.progress div.length.left{margin-right:10px}:host div.container div.progress div.length.right{margin-left:10px}:host div.container div.controls{display:flex;align-items:center;justify-content:center}:host div.container div.controls div.action{display:flex;justify-content:center;align-items:center;flex:none;width:36px;height:36px;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border-radius:50%;cursor:pointer;margin-right:10px;transition:background 300ms ease-in;transition:opacity 300ms linear}:host div.container div.controls div.action.disabled{background:var(--subtle-font-color, #828688);cursor:default}:host div.container div.controls div.action.flash{opacity:0.5}
    `], i18nKeys: I18nKeys })
], CTCLAudioRecorderPlayer);
exports.CTCLAudioRecorderPlayer = CTCLAudioRecorderPlayer;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const components_1 = __webpack_require__(3);
const UserLookup_1 = __webpack_require__(26);
const utils_1 = __webpack_require__(2);
const models_1 = __webpack_require__(1);
const ConversationConfigReader_1 = __webpack_require__(14);
const renderUtils_1 = __webpack_require__(8);
let CTCLResponseView = class CTCLResponseView extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        this._renderUserLine = (participant) => {
            const user = this._userLookup.get(participant.jid);
            const received = this.conversation.receivedList.find(x => x.jid === participant.jid);
            const response = this.conversation.acknowledgements.find(x => x.jid === participant.jid);
            let responseColor = "#aaa";
            if (response) {
                const responseTemplate = this._config.alertResponseOptionTemplates.find(x => x.value === response.value);
                responseColor = responseTemplate ? responseTemplate.color || "#aaa" : "#aaa";
            }
            return (window.__CTRender("div", { class: "user-row" },
                window.__CTRender("div", { class: "user" },
                    window.__CTRender(components_1.CTUserAvatar, { user: user }),
                    window.__CTRender("span", null, user.displayName)),
                received && (window.__CTRender("div", { class: "received" },
                    window.__CTRender("div", { class: "pill" },
                        window.__CTRender("span", { class: "ts" }, this._renderTime(received.ts))))),
                response && (window.__CTRender("div", { class: "response" },
                    window.__CTRender("div", { class: "pill", style: renderUtils_1.buildStyles({ backgroundColor: responseColor }) },
                        window.__CTRender("span", { class: "res" }, response.value),
                        window.__CTRender("span", { class: "ts" }, this._renderTime(response.ts)))))));
        };
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._userLookup = new UserLookup_1.UserLookup(this.layer);
            yield this._userLookup.populate([this.conversation]);
            this._config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, this.conversation);
        });
    }
    setupListeners() { }
    // === Private === //
    // === Render === //
    generateComponentMarkup() {
        if (!this.conversation)
            return null;
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("div", { class: "headings" },
                window.__CTRender("div", { class: "user" },
                    window.__CTRender("span", null, "Participant")),
                window.__CTRender("div", { class: "received" },
                    window.__CTRender("span", null, "Received")),
                window.__CTRender("div", { class: "response" },
                    window.__CTRender("span", null, "Responded"))),
            window.__CTRender("div", { class: "user-list" }, this.conversation.participants.filter(x => x.role !== models_1.ChatRole.Owner).map(this._renderUserLine))));
    }
    _renderTime(ts) {
        let time = ts;
        if (typeof ts === "string") {
            time = parseInt(ts);
        }
        return ts && ((utils_1.daysFromNow(time) === 0)
            ? utils_1.getFriendlyTime(time)
            : utils_1.getFriendlyDate(time, this)) || null;
    }
};
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLResponseView.prototype, "conversation", void 0);
CTCLResponseView = __decorate([
    component_1.component({ tag: "ctcl-response-view", styles: [`/*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;width:100%;flex:1 1}:host div.container{display:flex;flex-direction:column;width:100%}:host div.container div.headings{display:flex;background:var(--secondary-color, #f2f2f2);border-top:var(--secondary-border, 1px solid #ddd);border-bottom:var(--secondary-border, 1px solid #ddd);color:var(--subtle-font-color);align-items:center;padding:5px 10px}@media only screen and (min-width: 960px){:host div.container div.headings{border-top:none}}:host div.container div.headings div.user{padding-left:10px;flex-basis:40%}:host div.container div.headings div.received{flex-basis:30%}:host div.container div.headings div.response{flex-basis:30%}:host div.container div.headings div span{text-transform:uppercase}:host div.container div.user-list{display:flex;flex-direction:column;height:100%;overflow-y:scroll}:host div.container div.user-list div.user-row{display:flex;flex-shrink:0;padding:10px 20px;align-items:center;border-bottom:1px solid var(--default-border-color, #ddd)}@media only screen and (max-width: 640px){:host div.container div.user-list div.user-row{font-size:0.8em}}:host div.container div.user-list div.user-row div.user{display:flex;flex-basis:40%;padding-right:10px;align-items:center;color:var(--default-font-color, #212121)}:host div.container div.user-list div.user-row div.user ct-user-avatar{margin-right:20px}:host div.container div.user-list div.user-row div.received{flex-basis:30%;padding-right:10px}:host div.container div.user-list div.user-row div.received div.pill{background-color:#aaa}:host div.container div.user-list div.user-row div.response{flex-basis:30%}:host div.container div.user-list div.user-row div.pill{color:var(--tertiary-font-color, white);padding:5px 20px;border-radius:20px;display:flex;justify-content:space-around;align-items:center}:host div.container div.user-list div.user-row div.pill span.res{font-weight:bold;margin-right:5px}
    `] })
], CTCLResponseView);
exports.CTCLResponseView = CTCLResponseView;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const components_1 = __webpack_require__(3);
const Models_1 = __webpack_require__(5);
const simple_video_recorder_1 = __webpack_require__(153);
const Events_1 = __webpack_require__(4);
let CTCLVideoRecorderPlayer = class CTCLVideoRecorderPlayer extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        // === Private === //
        this._initVideoElm = (ref) => {
            this._videoElm = ref;
            this._videoElm.onplay = this._onPlay;
            this._videoElm.onpause = this._onEndOrPause;
            this._videoElm.onended = this._onEndOrPause;
        };
        this._onPlay = () => {
            this.emitEvent(Events_1.ChatEvents.MuteAlertToPlayOtherAudio);
        };
        this._onEndOrPause = () => {
            this.emitEvent(Events_1.ChatEvents.ResumeAlertAfterPlayingAudio);
        };
        this._startRecording = () => {
            if (!this.recording) {
                this.recording = true;
                this.showControls = false;
                this._startRecordingIndicator();
                this._recorder = new simple_video_recorder_1.SimpleVideoRecorder(this._videoElm, this._onVideoRecordingFinished);
                this._recorder.start();
            }
            else {
                this.recording = false;
                this._recorder.stop();
                this._stopRecordingIndicator();
            }
        };
        this._onVideoRecordingFinished = (filepath) => {
            this.showControls = true;
            this.source = filepath;
            this._videoElm.src = filepath;
            this._videoElm.muted = false;
            if (this.onRecordingFinished)
                this.onRecordingFinished(filepath);
        };
        this._remove = () => {
            this.source = "";
            this._videoElm.src = "";
            this.showControls = false;
            if (this.onVideoRemoved)
                this.onVideoRemoved();
        };
        this._startRecordingIndicator = () => {
            let flash = true;
            if (this._recordBtn) {
                setTimeout(() => this._recordBtn.classList.add("flash"), 100);
                this._flashTimer = setInterval(() => {
                    flash ? this._recordBtn.classList.remove("flash") : this._recordBtn.classList.add("flash");
                    flash = !flash;
                }, 500);
            }
        };
        this._stopRecordingIndicator = () => {
            clearInterval(this._flashTimer);
            if (this._recordBtn) {
                this._recordBtn.classList.remove("flash");
            }
        };
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() { }
    // === Render === //
    disconnectedCallback() {
        super.disconnectedCallback();
        this._videoElm.pause();
    }
    generateComponentMarkup() {
        const recordEnabled = this.showRecord;
        const removalEnabled = this.allowRemoval && this.source !== "";
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("div", { class: "controls" },
                this.showRecord &&
                    window.__CTRender("div", { class: `action ${recordEnabled ? "" : "disabled"}`, ref: (ref) => this._recordBtn = ref },
                        window.__CTRender(components_1.CTIcon, { color: "red", width: "16", height: "16", icon: Models_1.Icons.UI.CircleFilled, onClick: this._startRecording })),
                (this.allowRemoval) &&
                    window.__CTRender("div", { class: `action ${removalEnabled ? "" : "disabled"}` },
                        window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Cross, onClick: removalEnabled ? this._remove : null }))),
            window.__CTRender("div", { class: "player" },
                window.__CTRender("video", { ref: this._initVideoElm, width: 320, height: 240, controls: this.showControls, autoplay: this.autoplay, src: this.source }))));
    }
};
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLVideoRecorderPlayer.prototype, "showRecord", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLVideoRecorderPlayer.prototype, "allowRemoval", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLVideoRecorderPlayer.prototype, "recording", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLVideoRecorderPlayer.prototype, "showControls", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLVideoRecorderPlayer.prototype, "autoplay", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLVideoRecorderPlayer.prototype, "source", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTCLVideoRecorderPlayer.prototype, "onVideoRemoved", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTCLVideoRecorderPlayer.prototype, "onRecordingFinished", void 0);
CTCLVideoRecorderPlayer = __decorate([
    component_1.component({ tag: "ctcl-video-recorder-player", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex:1}:host div.container{display:flex;flex:1;justify-content:space-between}:host div.container div.controls{display:flex;align-items:flex-start;justify-content:center}:host div.container div.controls div.action{display:flex;justify-content:center;align-items:center;flex:none;width:36px;height:36px;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border-radius:50%;cursor:pointer;margin-right:10px;transition:background 300ms ease-in;transition:opacity 300ms linear}:host div.container div.controls div.action.disabled{background:var(--subtle-font-color, #828688);cursor:default}:host div.container div.controls div.action.flash{opacity:0.5}:host div.container div.player{display:flex;width:100%;align-items:center;margin:auto 0;justify-content:center}
    `] })
], CTCLVideoRecorderPlayer);
exports.CTCLVideoRecorderPlayer = CTCLVideoRecorderPlayer;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class BaseChatEventArgs extends events_1.BaseEventArgs {
    constructor() {
        super();
    }
}
exports.BaseChatEventArgs = BaseChatEventArgs;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatEventArgs_1 = __webpack_require__(52);
class ChatEntryEventArgs extends BaseChatEventArgs_1.BaseChatEventArgs {
    constructor(chatEntry) {
        super();
        this.chatEntry = chatEntry;
    }
}
exports.ChatEntryEventArgs = ChatEntryEventArgs;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatEventArgs_1 = __webpack_require__(52);
class ConversationEventArgs extends BaseChatEventArgs_1.BaseChatEventArgs {
    constructor(conversation) {
        super();
        this.conversation = conversation;
    }
}
exports.ConversationEventArgs = ConversationEventArgs;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class PriorityConversationAcknowledgedEventArgs extends events_1.BaseEventArgs {
    constructor(conversation, pendingCount, instigator) {
        super();
        this.conversation = conversation;
        this.pendingCount = pendingCount;
        this.instigator = instigator;
    }
}
exports.PriorityConversationAcknowledgedEventArgs = PriorityConversationAcknowledgedEventArgs;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(2);
const plugin_1 = __webpack_require__(22);
const Models_1 = __webpack_require__(5);
const importedMedia = plugin_1.getSource("Media");
const fileEncryption = plugin_1.getSource("fileEncryption");
const mediaProperties = plugin_1.getSource("mediaproperties");
const volumeControl = plugin_1.getSource("volumecontrol");
var MediaStatus;
(function (MediaStatus) {
    MediaStatus[MediaStatus["MEDIA_NONE"] = 0] = "MEDIA_NONE";
    MediaStatus[MediaStatus["MEDIA_STARTING"] = 1] = "MEDIA_STARTING";
    MediaStatus[MediaStatus["MEDIA_RUNNING"] = 2] = "MEDIA_RUNNING";
    MediaStatus[MediaStatus["MEDIA_PAUSED"] = 3] = "MEDIA_PAUSED";
    MediaStatus[MediaStatus["MEDIA_STOPPED"] = 4] = "MEDIA_STOPPED";
})(MediaStatus = exports.MediaStatus || (exports.MediaStatus = {}));
class SimpleAudioPlayer {
    constructor(callback) {
        this._totalLoops = 1;
        this._loopsRemaining = 0;
        this._loopIndefinitely = false;
        this._audioStream = Models_1.VolumeStream.Notification;
        this._volumeToPlayAt = -1;
        this._notifiedReady = false;
        this._failTimerWillRetry = true;
        /**
         * State based off numeric value:
         * 0 = MEDIA_NONE
         * 1 = MEDIA_STARTING
         * 2 = MEDIA_RUNNING
         * 3 = MEDIA_PAUSED
         * 4 = MEDIA_STOPPED
         */
        this.state = 0;
        this._reportDuration = () => __awaiter(this, void 0, void 0, function* () {
            if (this._durationCallback) {
                this._durationCallback(yield this.duration());
            }
        });
        this._mediaStatusUpdate = (e) => {
            this._updateMediaState(e);
            if (e === MediaStatus.MEDIA_STOPPED) {
                if (this._forceStop !== true) {
                    this._checkIfVolumeHasChanged(() => this._loop());
                }
                else {
                    clearTimeout(this._delayTimer);
                    this._resetVolume(() => delete this._previousVolume);
                }
                // Clear failure timeout
                clearTimeout(this._failTimer);
            }
            if (e === MediaStatus.MEDIA_RUNNING) {
                // Clear failure timeout
                clearTimeout(this._failTimer);
            }
            if (e === MediaStatus.MEDIA_STARTING) {
                // Start failure timeout
                this._failTimer = setTimeout(() => {
                    if (this._failTimerWillRetry) {
                        // var crap: any = document.querySelector('ct-cl-conversation-alert').shadowRoot.querySelector('ct-cl-header').shadowRoot.querySelector('.heading');                
                        // crap.style.backgroundColor = "green";
                        this.play();
                        this._failTimerWillRetry = false;
                    }
                    else {
                        // var crap: any = document.querySelector('ct-cl-conversation-alert').shadowRoot.querySelector('ct-cl-header').shadowRoot.querySelector('.heading');                
                        // crap.style.backgroundColor = "pink";
                    }
                }, 5000);
            }
        };
        this._loop = () => {
            // this._updateMediaState(MediaStatus.MEDIA_STOPPED);
            if (!this._forceStop && this._loopIndefinitely) {
                this._delayTimer = setTimeout(() => {
                    if (!this._forceStop && this._media) {
                        this.play();
                        // if (this._media.setStreamId) {
                        //     this._media.setStreamId(() => this.play(), this._audioStream.toString());
                        // }
                        // else {
                        //     this.play();
                        // }
                    }
                }, 2000);
            }
            else {
                this._loopsRemaining--;
                if (this._loopsRemaining > 0) {
                    this._delayTimer = setTimeout(() => !this._forceStop ? this.play() : null, 2000);
                }
                else {
                    this._resetVolume(() => delete this._previousVolume);
                }
            }
        };
        this._isMobile = utils_1.isMobile();
        this._volumeControl = volumeControl;
        if (callback) {
            this._callbackOnStateChange = callback;
        }
    }
    // === Private === //
    _init(src) {
        if (this._media) {
            this._forceStop = true;
            this.stop();
        }
        this._audioSrc = this._getAssetPath(src);
        if (this._isMobile) {
            this._notifiedReady = false;
            this._media = new importedMedia(this._audioSrc, (e) => {
                if (this._readyCallback && this._notifiedReady === false) {
                    this._notifiedReady = true;
                    this._readyCallback();
                }
            }, (e) => {
                if (e.code && e.code === 1 && this._loadingFromAssets) {
                    this.setAudio("pager_responder_alert.m4a", this._totalLoops, this._volumeToPlayAt, this._audioStream);
                    setTimeout(() => this.play(), 500);
                }
            }, this._mediaStatusUpdate);
            if (this._durationCallback) {
                if (this._audioSrc.includes("encrypted")) {
                    fileEncryption.getAudioFileDuration((result) => {
                        this._duration = Math.ceil(result) * 1000;
                        this._reportDuration();
                    }, (err) => {
                        // tslint:disable-next-line no-console
                        console.error("Media properties error:", err);
                    }, this._getAssetPath(this._audioSrc, true));
                }
                else {
                    mediaProperties.getProperties((result) => {
                        this._duration = Math.ceil(result.duration) * 1000;
                        this._reportDuration();
                    }, (err) => {
                        // tslint:disable-next-line no-console
                        console.error("Media properties error:", err);
                    }, this._getAssetPath(this._audioSrc, true));
                }
            }
        }
        else if (window.cti) {
            this._audioElm = document.createElement("audio");
            this._audioElm.setAttribute("preload", "true");
            this._audioElm.onloadeddata = () => __awaiter(this, void 0, void 0, function* () {
                yield this._reportDuration();
                if (this._readyCallback && this._notifiedReady === false) {
                    this._notifiedReady = true;
                    this._readyCallback();
                }
            });
            this._audioElm.setAttribute("src", this._audioSrc);
            this._audioElm.onended = this._loop;
            this._audioElm.onplay = () => this._updateMediaState(MediaStatus.MEDIA_RUNNING);
            this._audioElm.onpause = () => this._updateMediaState(MediaStatus.MEDIA_PAUSED);
            this._audioElm.onended = () => this._updateMediaState(MediaStatus.MEDIA_STOPPED);
            this._media = this._audioElm;
        }
    }
    _getAssetPath(src, forceFilePrefix = false) {
        this._loadingFromAssets = false;
        let prefix = "";
        if (forceFilePrefix === true) {
            prefix = "file://";
        }
        if (src.includes("/") || src.includes("\\")) {
            return src.includes("file://") ? src : `${prefix}${src}`;
        }
        else {
            this._loadingFromAssets = true;
            const win = window;
            // Why is this undefined on devices, wtf is the point of CTI...!?!?!!?!
            const baseDir = win.cti ? win.cti.store.schema.assetDir || "user-assets/" : "";
            return win.cti ? `${baseDir}${src}` : src;
        }
    }
    _updateMediaState(state) {
        this.state = state;
        if (this._callbackOnStateChange) {
            this._callbackOnStateChange(this.state);
        }
    }
    _getAndSetVolume(onFinish) {
        this._volumeControl.getDeviceVolume((v) => {
            if (this._previousVolume === undefined) {
                this._previousVolume = parseFloat(v);
            }
            this._volumeControl.setDeviceVolume(() => this._media.setStreamId(onFinish, this._audioStream.toString()), () => this.stop(), this._volumeToPlayAt / 100.0, this._audioStream);
        }, (e) => this.stop(), this._audioStream);
    }
    _resetVolume(onFinish = () => { }) {
        if (this._volumeToPlayAt !== -1 && this._volumeControl) {
            this._volumeControl.setDeviceVolume(onFinish, () => { }, this._previousVolume, this._audioStream);
        }
    }
    _checkIfVolumeHasChanged(onFinish = () => { }) {
        if (this._volumeToPlayAt !== -1 && this._volumeControl) {
            this._volumeControl.getDeviceVolume((v) => {
                const curVol = parseFloat(v);
                if (Math.ceil(curVol * 100) !== this._volumeToPlayAt) {
                    this._volumeControl.setDeviceVolume(onFinish, () => this.stop(), this._volumeToPlayAt / 100.0, this._audioStream);
                }
                else {
                    onFinish();
                }
            }, onFinish, this._audioStream);
        }
        else {
            onFinish();
        }
    }
    // === Public === //
    /**
     * Set the audio track and settings to play.
     * @param src - Source to the audio file
     * @param loops - Number of times to play the track. Default is 1, set to 0 for indefinite
     * looping
     * @param volume - Percentage of the volume to play at
     * @param stream - Provide a stream to _attempt_ to play on
     * @param durationCallback - Callback to pass duration of the track to
     */
    setAudio(src, loops = 1, volume = -1, stream = Models_1.VolumeStream.Notification, durationCallback, readyCallback) {
        this._durationCallback = durationCallback;
        this._readyCallback = readyCallback;
        this._init(src);
        this._totalLoops = loops;
        this._loopsRemaining = this._totalLoops;
        this._loopIndefinitely = this._loopsRemaining === 0 ? true : false;
        this._volumeToPlayAt = volume;
        this._audioStream = stream;
        this._updateMediaState(MediaStatus.MEDIA_NONE);
    }
    /**
     * Plays the currently set audio.
     */
    play() {
        this._forceStop = false;
        if (this._audioSrc && this._media) {
            if (this._volumeToPlayAt !== -1 && this._volumeControl) {
                this._getAndSetVolume(() => this._media.play());
            }
            else {
                setTimeout(() => this._media.play(), 100);
            }
        }
    }
    /**
     * Stops the currently playing audio. Next playback is started from the beginning of the audio
     * track. This will also reset the loop count (if specified), starting looping from the
     * beginning.
     * @param force - Force the looping to stop as well
     */
    stop(force = false) {
        if (this._audioSrc && this._media) {
            this._forceStop = force;
            this._updateMediaState(MediaStatus.MEDIA_STOPPED);
            if (this._media.stop) {
                this._media.stop();
                // this._media.release();
            }
            else {
                this._media.pause();
                this._audioElm.currentTime = 0;
            }
            this._loopsRemaining = this._totalLoops;
        }
    }
    /**
     * Pauses the currently playing audio. Next playback is resumed from where the audio was paused.
     */
    pause() {
        if (this._audioSrc && this._media) {
            this._updateMediaState(MediaStatus.MEDIA_PAUSED);
            this._media.pause();
        }
    }
    duration() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._audioSrc) {
                if (utils_1.isMobile()) {
                    return this._duration;
                }
                else {
                    // Apparently there is a nice little bug in Chrome that incorrectly reports
                    // the duration of an audio track. This is mostly surfaced when recording the
                    // audio rather than attaching a file. In any case, trapping this in a while
                    // loop seems to trick the audio element to work and correctly report the duration.
                    if (this._audioElm.duration === Infinity) {
                        while (this._audioElm.duration === Infinity) {
                            yield new Promise(r => setTimeout(r, 100));
                            this._audioElm.currentTime = 10000000 * Math.random();
                        }
                        return this._audioElm.duration * 1000;
                    }
                    else {
                        return this._audioElm.duration * 1000;
                    }
                }
            }
            return 0;
        });
    }
    release() {
        if (this._media && this._media.release) {
            this._media.release();
        }
    }
    reset() {
        clearTimeout(this._delayTimer);
        delete this._delayTimer;
        this._audioSrc = "";
        this._audioElm = null;
        this._media = null;
        this._duration = 0;
        this.state = MediaStatus.MEDIA_NONE;
        this._totalLoops = 1;
        this._loopsRemaining = 0;
        this._loopIndefinitely = false;
        this._audioStream = Models_1.VolumeStream.Notification;
        this._previousVolume = null;
        this._volumeToPlayAt = -1;
        this._forceStop = null;
    }
}
exports.SimpleAudioPlayer = SimpleAudioPlayer;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var VolumeStream;
(function (VolumeStream) {
    // tslint:disable no-any
    VolumeStream[VolumeStream["Music"] = "music"] = "Music";
    VolumeStream[VolumeStream["Notification"] = "notification"] = "Notification";
    VolumeStream[VolumeStream["Ring"] = "ring"] = "Ring";
    VolumeStream[VolumeStream["Alarm"] = "alarm"] = "Alarm";
    VolumeStream[VolumeStream["Voice"] = "voice"] = "Voice";
    VolumeStream[VolumeStream["System"] = "system"] = "System";
    VolumeStream[VolumeStream["Dtmf"] = "dtmf"] = "Dtmf";
    // tslint:enable no-any
})(VolumeStream = exports.VolumeStream || (exports.VolumeStream = {}));


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const components_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(8);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["CANCEL"] = "Cancel"] = "CANCEL";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTActionSheet = class CTActionSheet extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        // === Private === //
        this._toggle = () => {
            this.open = !this.open;
        };
        this._action = (action) => {
            this._toggle();
            if (action) {
                action();
            }
        };
        this._renderActionSheetButton = (button, primary = false) => {
            return (window.__CTRender(components_1.CTButton
            // textColor={button.color ? decideTextColorFromBgColor(button.color) : null}
            // type={`${button.color ? "none" : "action-sheet"}`}
            , { 
                // textColor={button.color ? decideTextColorFromBgColor(button.color) : null}
                // type={`${button.color ? "none" : "action-sheet"}`}
                type: "action-sheet", class: "button", disabled: button.disabled, onClick: () => this._action(button.action) },
                window.__CTRender("p", { class: `${button.subtitleText ? "hasSubtitle" : ""}` }, button.primaryText),
                button.subtitleText &&
                    window.__CTRender("span", { class: "subtitle" }, button.subtitleText)));
        };
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() { }
    // === Render === //
    generateComponentMarkup() {
        if (!this.buttons || !this.buttons.length)
            return null;
        if (this.buttons.length === 1) {
            return (window.__CTRender("div", { class: "container" },
                window.__CTRender(components_1.CTButton, { type: `${this.openSheetBackgroundColor ? "none" : "primary"}`, textColor: this.openSheetBackgroundColor ? renderUtils_1.decideTextColorFromBgColor(this.openSheetBackgroundColor) : null, style: renderUtils_1.buildStyles({ backgroundColor: this.openSheetBackgroundColor }), class: "button", disabled: this.buttons[0].disabled, onClick: () => this._action(this.buttons[0].action) }, this.buttons[0].primaryText)));
        }
        else {
            return (window.__CTRender("div", { class: "container" },
                window.__CTRender(components_1.CTButton, { type: `${this.openSheetBackgroundColor ? "none" : "primary"}`, textColor: this.openSheetBackgroundColor ? renderUtils_1.decideTextColorFromBgColor(this.openSheetBackgroundColor) : null, style: renderUtils_1.buildStyles({ backgroundColor: this.openSheetBackgroundColor }), class: "button", onClick: this._toggle }, this.openSheetButtonText),
                window.__CTRender("div", { class: `sheet-bg ${this.open ? "" : "hidden"}` },
                    window.__CTRender("div", { class: "sheet-buttons" },
                        window.__CTRender("div", { class: `inner-sheet-buttons ${this.open ? "" : "hidden"}` },
                            window.__CTRender("div", { class: "inner-buttons" }, this.buttons.map((x) => this._renderActionSheetButton(x))),
                            window.__CTRender("div", { class: "close" },
                                window.__CTRender(components_1.CTButton, { type: "action-sheet", class: "button", onClick: this._toggle }, this.translateI18nItem(I18nKeys.CANCEL))))))));
        }
    }
};
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTActionSheet.prototype, "open", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [{ text: "Sample" }] })
], CTActionSheet.prototype, "buttons", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "Open" })
], CTActionSheet.prototype, "openSheetButtonText", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTActionSheet.prototype, "openSheetBackgroundColor", void 0);
CTActionSheet = __decorate([
    component_1.component({ tag: "ct-action-sheet", styles: [`/*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;width:100%}:host div.container ct-button{font-size:1.4em}:host div.container div.sheet-bg{display:flex;position:absolute;top:0;left:0;height:100%;width:100%;background-color:rgba(0,0,0,0.3);transition:all 0.1s ease-in;opacity:1;overflow:hidden}:host div.container div.sheet-bg.hidden{opacity:0;pointer-events:none}:host div.container div.sheet-bg div.sheet-buttons{display:flex;flex-direction:column;justify-content:flex-end;flex:1;padding:10px 20px}:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons{transform:translateY(0);transition:all 0.3s ease-in-out}:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.inner-buttons,:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.close{border-radius:10px;overflow:hidden}:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.inner-buttons ct-button,:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.close ct-button{border-bottom:1px solid var(--action-sheet-border-color, #ddd);border-radius:0}:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.inner-buttons ct-button:last-child,:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.close ct-button:last-child{border-bottom:0}:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons div.close{margin-top:10px}:host div.container div.sheet-bg div.sheet-buttons div.inner-sheet-buttons.hidden{transform:translateY(100%)}
    `], i18nKeys: I18nKeys })
], CTActionSheet);
exports.CTActionSheet = CTActionSheet;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
class CTButton extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        // === End properties === //
        this._rippleTimeout = null;
    }
    static get is() {
        return "ct-button";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}@keyframes ripple{100%{transform:scale(2);opacity:0}}:host{display:block;position:relative;border-radius:10px;overflow:hidden}:host button{position:relative;background:transparent;color:#000;padding:0.55em 1em;border:1px solid transparent;font-family:inherit;font-size:inherit;font-weight:inherit;outline:none;cursor:pointer;overflow:hidden;width:100%;height:100%;min-height:45px;border-radius:inherit}:host button .button-content{pointer-events:none;display:inline-flex;justify-content:center;align-items:center}:host button .button-content .icon{display:block}:host button .button-content .label{display:block}:host button .button-content .icon+.label{margin:0 0 0 5px}:host button .ripple{background-color:white;border-radius:50%;opacity:0.4;transform:scale(0.01);position:absolute;pointer-events:none}:host button .ripple.animate{animation:ripple 0.6s ease-out}:host button.primary{background-color:var(--button-primary-bg, #22b1c8);border:var(--button-primary-border, 1px solid #22b1c8);color:var(--button-primary-text, #fff)}:host button.primary .ripple{background-color:var(--button-primary-ripple, #fff)}:host button.secondary{background-color:var(--button-secondary-bg, rgba(0,0,0,0));border:var(--button-secondary-border, 1px solid #22b1c8);color:var(--button-secondary-text, #22b1c8)}:host button.secondary .ripple{background-color:var(--button-secondary-ripple, #22b1c8)}:host button.tertiary{background-color:var(--button-tertiary-bg, #ddd);border:var(--button-tertiary-border, 1px solid #ddd);color:var(--button-tertiary-text, #000)}:host button.tertiary .ripple{background-color:var(--button-tertiary-ripple, #fff)}:host button.invert-primary{background:var(--button-invert-primary-bg, #fff);border:var(--button-invert-primary-border, 1px solid #fff);color:var(--button-invert-primary-text, #f2f2f2)}:host button.invert-primary .ripple{background-color:var(--button-invert-primary-ripple, #f2f2f2)}:host button.invert-secondary{background:var(--button-invert-secondary-bg, rgba(0,0,0,0));border:var(--button-invert-secondary-border, 1px solid #fff);color:var(--button-invert-secondary-text, #fff)}:host button.invert-secondary .ripple{background-color:var(--button-invert-secondary-ripple, #fff)}:host button.selected{background-color:var(--button-selected-bg, #22b1c8);border:var(--button-selected-border, 1px solid #22b1c8);color:var(--button-selected-text, #fff)}:host button.selected .ripple{background-color:var(--button-selected-ripple, #fff)}:host button.cancel{background-color:var(--button-cancel-bg, rgba(0,0,0,0));border:var(--button-cancel-border, 1px solid #fff);color:var(--button-cancel-text, #000)}:host button.cancel .ripple{background-color:var(--button-cancel-ripple, #000)}:host button.warning{background-color:var(--button-warning-bg, #fdb851);border:var(--button-warning-border, #fdb851);color:var(--button-warning-text, #fff)}:host button.warning .ripple{background-color:var(--button-warning-ripple, #fff)}:host button.dangerous{background-color:var(--button-dangerous-bg, #ce0a24);border:var(--button-dangerous-border, #ce0a24);color:var(--button-dangerous-text, #fff)}:host button.dangerous .ripple{background-color:var(--button-dangerous-ripple, #fff)}:host button.headerBack{background-color:#231f20;border:none;color:white}:host button.headerBack .ripple{background-color:white}:host button.transparent{background-color:transparent;border:none}:host button.large{padding:1.25em 1em}:host button[disabled]{opacity:0.5;cursor:not-allowed}:host button.action-sheet{background-color:var(--action-sheet-button-bg, #fff);color:var(--button-primary-bg, #22b1c8)}:host button.action-sheet div.label{display:flex;flex-direction:column;justify-content:flex-start}::slotted(p){margin:0}::slotted(p.hasSubtitle){padding-top:6px}::slotted(span){padding-bottom:10px;font-size:0.7em;color:var(--action-sheet-subtitle-color, #828688)}
        `;
    }
    generateComponentMarkup() {
        const cssClasses = [
            this.type
        ];
        if (this.selected) {
            cssClasses.push("selected");
        }
        if (this.large) {
            cssClasses.push("large");
        }
        if (this.isWaiting) {
            cssClasses.push("waiting");
        }
        if (this.isTransparent) {
            cssClasses.push("transparent");
        }
        const loadingSpinnerIcon = models_1.Icons.COMMON.LoadingSpinner;
        const buttonStyles = renderUtils_1.buildStyles();
        if (!!this.width) {
            buttonStyles.width = this.width;
        }
        if (!!this.textColor) {
            buttonStyles.color = this.textColor;
        }
        return (window.__CTRender("button", { class: cssClasses.join(" "), style: buttonStyles, disabled: this.isWaiting || this.disabled, onClick: e => this.handleButtonClick(e) },
            window.__CTRender("div", { class: "button-content" },
                renderUtils_1.renderIf(!this.isWaiting && !!this.icon, window.__CTRender(components_1.CTIcon, { icon: this.icon, color: this.iconColor, width: this.iconWidth, height: this.iconHeight, class: "icon" })),
                renderUtils_1.renderIfElse(this.isWaiting, window.__CTRender(components_1.CTIcon, { icon: loadingSpinnerIcon, color: this.iconColor, width: this.iconHeight, height: this.iconHeight, spin: true, class: "icon" }), window.__CTRender("div", { class: "label" },
                    window.__CTRender("slot", null))))));
    }
    // === Event handlers === //
    handleButtonClick(e) {
        if (!this.disabled) {
            this._ripple(e.offsetX, e.offsetY, e.target);
            if (typeof (this.onClick) === "function") {
                const clickEvent = Object.create(e, {
                    target: {
                        value: this
                    }
                });
                this.onClick(clickEvent);
            }
        }
    }
    // === Helper functions === //
    _ripple(clickX, clickY, button) {
        const previousRipple = button.querySelector(".ripple");
        if (previousRipple) {
            previousRipple.remove();
        }
        const width = button.clientWidth;
        const height = button.clientHeight;
        const size = Math.max(width, height);
        const x = clickX - (size / 2);
        const y = clickY - (size / 2);
        clearTimeout(this._rippleTimeout);
        this._rippleTimeout = setTimeout(() => {
            const ripple = document.createElement("span");
            ripple.classList.add("ripple");
            ripple.style.width = `${size}px`;
            ripple.style.height = `${size}px`;
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            button.insertBefore(ripple, button.firstChild);
            ripple.addEventListener("animationend", () => {
                ripple.remove();
            });
            ripple.classList.add("animate");
        }, 0);
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "primary" })
], CTButton.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "selected", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: null })
], CTButton.prototype, "width", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "large", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTButton.prototype, "textColor", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "auto" })
], CTButton.prototype, "iconColor", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "18px" })
], CTButton.prototype, "iconWidth", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "18px" })
], CTButton.prototype, "iconHeight", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: true })
], CTButton.prototype, "onClick", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "isTransparent", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTButton.prototype, "icon", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTButton.prototype, "isWaiting", void 0);
exports.CTButton = CTButton;
CTButton.register();


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
class CTGroupAvatar extends base_1.CTLayerComponent {
    static get is() {
        return "ct-group-avatar";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host .bg{position:relative;flex:none;display:flex;flex-direction:column;justify-content:center;align-items:center;border-radius:50%;overflow:hidden;background:var(--avatar-bg, #7b7e80);color:var(--avatar-color, #fff)}:host .bg .image{position:absolute;top:0;left:0;border-radius:50%}
        `;
    }
    generateComponentMarkup() {
        const styles = renderUtils_1.buildStyles({
            width: `${this.size}px`,
            height: `${this.size}px`
        });
        const iconSize = Math.floor(this.size / 2);
        return (window.__CTRender("div", { class: "bg", style: styles },
            window.__CTRender(components_1.CTIcon, { icon: models_1.Icons.COMMON.Users, width: iconSize, height: iconSize }),
            this.group.icon && window.__CTRender("img", { class: "image", src: this.group.icon, width: this.size, height: this.size })));
    }
}
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 40 })
], CTGroupAvatar.prototype, "size", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false })
], CTGroupAvatar.prototype, "group", void 0);
exports.CTGroupAvatar = CTGroupAvatar;
CTGroupAvatar.register();


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(2);
let CTSelectionTextFilter = class CTSelectionTextFilter extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        this._delay = 200;
        // === Private === //
        this._onSelectChange = (e) => {
            const newValue = e.currentTarget.value;
            this._selectValue = newValue;
            if (newValue !== this.defaultSelectionValue) {
                this.highlightSelection = true;
            }
            else {
                this.highlightSelection = false;
            }
            if (this.onSearch) {
                this.onSearch(newValue, this._textValue);
            }
        };
        this._onSearch = (e) => {
            const searchTerm = e.currentTarget.value;
            const isEmpty = searchTerm.length === 0;
            if (isEmpty) {
                this.cancelDebounce("search");
                this.showClear = false;
                this._textValue = "";
                if (this.onSearch) {
                    this.onSearch(this._selectValue, "");
                }
            }
            else {
                this.showClear = true;
                this.debounce("search", () => {
                    this._textValue = searchTerm;
                    if (typeof (this.onSearch) === "function") {
                        this.onSearch(this._selectValue, searchTerm);
                    }
                }, this._delay);
            }
        };
        this._clear = () => {
            // NOTE: we do not clear the _selectValue here intentionally.
            this._input.value = "";
            this._textValue = "";
            this.showClear = false;
            if (this.onSearch) {
                this.onSearch(this._selectValue, "");
            }
        };
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() { }
    // === Render === //
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("div", { class: `select ${this.highlightSelection ? "highlight" : ""}` },
                window.__CTRender("select", { onChange: this._onSelectChange, ref: ref => this._select = ref },
                    window.__CTRender("option", null, this.defaultSelectionValue),
                    this.selectionItems.map(x => window.__CTRender("option", null, x))),
                window.__CTRender(components_1.CTIcon, { class: "select-icon", width: "12", height: "12", color: this.highlightSelection ? utils_1.getCSSVariable("--header-text") : "auto", icon: models_1.Icons.COMMON.ChevronDown })),
            window.__CTRender("input", { type: "text", placeholder: this.placeholder, oninput: this._onSearch, ref: ref => this._input = ref }),
            this.showClear && window.__CTRender(components_1.CTIcon, { class: "clear", width: "12", height: "12", icon: models_1.Icons.COMMON.CircleCross, onClick: this._clear })));
    }
};
__decorate([
    base_1.prop({ type: String, attribute: false, default: "All" })
], CTSelectionTextFilter.prototype, "defaultSelectionValue", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTSelectionTextFilter.prototype, "selectionItems", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTSelectionTextFilter.prototype, "highlightSelection", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTSelectionTextFilter.prototype, "placeholder", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, defaul: null })
], CTSelectionTextFilter.prototype, "onSearch", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTSelectionTextFilter.prototype, "showClear", void 0);
CTSelectionTextFilter = __decorate([
    component_1.component({ tag: "ct-selection-text-filter", styles: [`/*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex:1}:host div.container{display:flex;flex:1;height:40px;border-radius:20px;border:1px solid var(--select-border-color, #ddd);background-color:var(--default-bg-color-light, #fff);position:relative;color:var(--default-bg-color-light-font, #212121)}:host div.container div.select>select,:host div.container input{outline:0;font-size:1em;padding:0 10px;border:0}:host div.container div.select{border-top-left-radius:20px;border-bottom-left-radius:20px;border-top-right-radius:0;border-bottom-right-radius:0;flex:0 0 30%;width:30%;height:100%;position:relative;border-right:1px solid var(--select-border-color, #ddd)}:host div.container div.select select{border-top-left-radius:20px;border-bottom-left-radius:20px;-webkit-appearance:none;padding-right:26px;width:100%;height:100%;cursor:pointer;background-color:transparent;color:inherit}:host div.container div.select.highlight,:host div.container div.select.highlight>select{color:var(--primary-color, #22b1c8);font-weight:bold}:host div.container input{flex:1;border-top-right-radius:20px;border-bottom-right-radius:20px;padding-right:26px;margin:0;border-top-left-radius:0;border-bottom-left-radius:0;background-color:transparent;color:inherit}:host div.container input::placeholder{color:var(--select-placeholder-color, #828688)}:host div.container input::-webkit-input-placeholder{color:var(--select-placeholder-color, #828688)}:host div.container ct-icon.select-icon{pointer-events:none}:host div.container ct-icon.clear,:host div.container ct-icon.select-icon{position:absolute;top:0;right:0;height:100%;padding:0 7px;cursor:pointer}
    `] })
], CTSelectionTextFilter);
exports.CTSelectionTextFilter = CTSelectionTextFilter;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
class CTUserAvatar extends base_1.CTLayerComponent {
    static get is() {
        return "ct-user-avatar";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host .bg{position:relative;flex:none;display:flex;flex-direction:column;justify-content:center;align-items:center;border-radius:50%;overflow:hidden;background:var(--avatar-bg, #7b7e80);color:var(--avatar-color, #fff)}:host .bg .image{position:absolute;top:0;left:0;border-radius:50%}
        `;
    }
    generateComponentMarkup() {
        const styles = renderUtils_1.buildStyles({
            width: `${this.size}px`,
            height: `${this.size}px`
        });
        if (this.bgColor) {
            styles.backgroundColor = this.bgColor;
        }
        const iconSize = Math.floor(this.size / 2);
        return (window.__CTRender("div", { class: "bg", style: styles },
            window.__CTRender(components_1.CTIcon, { icon: this.defaultIcon, width: iconSize, height: iconSize }),
            this.user.avatar && window.__CTRender("img", { class: "image", src: this.user.avatar, width: this.size, height: this.size })));
    }
}
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 40 })
], CTUserAvatar.prototype, "size", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false })
], CTUserAvatar.prototype, "user", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: models_1.Icons.COMMON.User })
], CTUserAvatar.prototype, "defaultIcon", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTUserAvatar.prototype, "bgColor", void 0);
exports.CTUserAvatar = CTUserAvatar;
CTUserAvatar.register();


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(194)
var ieee754 = __webpack_require__(196)
var isArray = __webpack_require__(197)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var require;/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.1.0
 */

(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = __webpack_require__(210);
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
      GET_THEN_ERROR.error = null;
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));
//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(206), __webpack_require__(35)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.stateify = exports.TokenState = exports.CharacterState = undefined;

var _class = __webpack_require__(28);

function createStateClass() {
	return function (tClass) {
		this.j = [];
		this.T = tClass || null;
	};
}

/**
	A simple state machine that can emit token classes

	The `j` property in this class refers to state jumps. It's a
	multidimensional array where for each element:

	* index [0] is a symbol or class of symbols to transition to.
	* index [1] is a State instance which matches

	The type of symbol will depend on the target implementation for this class.
	In Linkify, we have a two-stage scanner. Each stage uses this state machine
	but with a slighly different (polymorphic) implementation.

	The `T` property refers to the token class.

	TODO: Can the `on` and `next` methods be combined?

	@class BaseState
*/
var BaseState = createStateClass();
BaseState.prototype = {
	defaultTransition: false,

	/**
 	@method constructor
 	@param {Class} tClass Pass in the kind of token to emit if there are
 		no jumps after this state and the state is accepting.
 */

	/**
 	On the given symbol(s), this machine should go to the given state
 		@method on
 	@param {Array|Mixed} symbol
 	@param {BaseState} state Note that the type of this state should be the
 		same as the current instance (i.e., don't pass in a different
 		subclass)
 */
	on: function on(symbol, state) {
		if (symbol instanceof Array) {
			for (var i = 0; i < symbol.length; i++) {
				this.j.push([symbol[i], state]);
			}
			return this;
		}
		this.j.push([symbol, state]);
		return this;
	},


	/**
 	Given the next item, returns next state for that item
 	@method next
 	@param {Mixed} item Should be an instance of the symbols handled by
 		this particular machine.
 	@return {State} state Returns false if no jumps are available
 */
	next: function next(item) {
		for (var i = 0; i < this.j.length; i++) {
			var jump = this.j[i];
			var symbol = jump[0]; // Next item to check for
			var state = jump[1]; // State to jump to if items match

			// compare item with symbol
			if (this.test(item, symbol)) {
				return state;
			}
		}

		// Nowhere left to jump!
		return this.defaultTransition;
	},


	/**
 	Does this state accept?
 	`true` only of `this.T` exists
 		@method accepts
 	@return {Boolean}
 */
	accepts: function accepts() {
		return !!this.T;
	},


	/**
 	Determine whether a given item "symbolizes" the symbol, where symbol is
 	a class of items handled by this state machine.
 		This method should be overriden in extended classes.
 		@method test
 	@param {Mixed} item Does this item match the given symbol?
 	@param {Mixed} symbol
 	@return {Boolean}
 */
	test: function test(item, symbol) {
		return item === symbol;
	},


	/**
 	Emit the token for this State (just return it in this case)
 	If this emits a token, this instance is an accepting state
 	@method emit
 	@return {Class} T
 */
	emit: function emit() {
		return this.T;
	}
};

/**
	State machine for string-based input

	@class CharacterState
	@extends BaseState
*/
var CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {
	/**
 	Does the given character match the given character or regular
 	expression?
 		@method test
 	@param {String} char
 	@param {String|RegExp} charOrRegExp
 	@return {Boolean}
 */
	test: function test(character, charOrRegExp) {
		return character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);
	}
});

/**
	State machine for input in the form of TextTokens

	@class TokenState
	@extends BaseState
*/
var TokenState = (0, _class.inherits)(BaseState, createStateClass(), {

	/**
  * Similar to `on`, but returns the state the results in the transition from
  * the given item
  * @method jump
  * @param {Mixed} item
  * @param {Token} [token]
  * @return state
  */
	jump: function jump(token) {
		var tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

		var state = this.next(new token('')); // dummy temp token
		if (state === this.defaultTransition) {
			// Make a new state!
			state = new this.constructor(tClass);
			this.on(token, state);
		} else if (tClass) {
			state.T = tClass;
		}
		return state;
	},


	/**
 	Is the given token an instance of the given token class?
 		@method test
 	@param {TextToken} token
 	@param {Class} tokenClass
 	@return {Boolean}
 */
	test: function test(token, tokenClass) {
		return token instanceof tokenClass;
	}
});

/**
	Given a non-empty target string, generates states (if required) for each
	consecutive substring of characters in str starting from the beginning of
	the string. The final state will have a special value, as specified in
	options. All other "in between" substrings will have a default end state.

	This turns the state machine into a Trie-like data structure (rather than a
	intelligently-designed DFA).

	Note that I haven't really tried these with any strings other than
	DOMAIN.

	@param {String} str
	@param {CharacterState} start State to jump from the first character
	@param {Class} endToken Token class to emit when the given string has been
		matched and no more jumps exist.
	@param {Class} defaultToken "Filler token", or which token type to emit when
		we don't have a full match
	@return {Array} list of newly-created states
*/
function stateify(str, start, endToken, defaultToken) {
	var i = 0,
	    len = str.length,
	    state = start,
	    newStates = [],
	    nextState = void 0;

	// Find the next state without a jump to the next character
	while (i < len && (nextState = state.next(str[i]))) {
		state = nextState;
		i++;
	}

	if (i >= len) {
		return [];
	} // no new tokens were added

	while (i < len - 1) {
		nextState = new CharacterState(defaultToken);
		newStates.push(nextState);
		state.on(str[i], nextState);
		state = nextState;
		i++;
	}

	nextState = new CharacterState(endToken);
	newStates.push(nextState);
	state.on(str[len - 1], nextState);

	return newStates;
}

exports.CharacterState = CharacterState;
exports.TokenState = TokenState;
exports.stateify = stateify;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function createTokenClass() {
	return function (value) {
		if (value) {
			this.v = value;
		}
	};
}

exports.createTokenClass = createTokenClass;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const errors_1 = __webpack_require__(25);
const models_1 = __webpack_require__(1);
const Logger_1 = __webpack_require__(17);
const Comms_1 = __webpack_require__(104);
const Store_1 = __webpack_require__(161);
const Models_1 = __webpack_require__(5);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const I18n_1 = __webpack_require__(155);
const Keys_1 = __webpack_require__(20);
const utils_1 = __webpack_require__(2);
const ChatUtils_1 = __webpack_require__(10);
const PriorityConversationNotificationEventArgs_1 = __webpack_require__(117);
const ConversationConfigReader_1 = __webpack_require__(14);
const simple_audio_player_1 = __webpack_require__(56);
const vibration_controller_1 = __webpack_require__(154);
class ChatLayer extends base_1.BaseLayer {
    // === Constructor === //
    constructor(name, config, dependencyInjections) {
        super(name, config);
        // === Version === //
        this.VERSION = "1.0.0";
        this.bootstrapper = null;
        this._allConversations = null;
        this._currentConversation = null;
        this._conversationsBeingPurged = [];
        this._pendingConversationAlerts = [];
        this._isFetchingChatEntries = false;
        this.name = name;
        this.config = this._checkConfigForPreferences(config);
        if (!this.config.xmpp)
            throw new Error("What are you doing not specifying XMPP configuration?");
        if (this.config.xmpp.mam)
            this.config.xmpp.mam.autoFetch = false; // enforce no autoFetch of MAM
        this.config.xmpp.updateUserDirectoryOnLogin = true; // enfoce fetching users on login
        this.config.xmpp.bringToForegroundOnVoipPush = false;
        const store = (dependencyInjections && dependencyInjections.store) || new Store_1.Store(name, this.logger, config);
        const comms = (dependencyInjections && dependencyInjections.comms) || new Comms_1.Comms(name, config.xmpp, store, this.logger, this);
        this.bootstrapper = this.bootstrap(comms, store);
        this.bootstrapper.then(() => {
            // this.setStatusBarColor(getCSSVariable("--primary-color"));
            this.on(Events_1.ChatEvents.ForceQuitConversation, (detail) => __awaiter(this, void 0, void 0, function* () {
                const currentConversation = yield this.getCurrentConversation();
                if (currentConversation && currentConversation.id === detail.conversation.id) {
                    yield this.clearCurrentConversation();
                    yield this.purgeConversation(currentConversation);
                }
            }));
            this.on(Events_1.ChatEvents.PriorityConversationNotification, (data) => {
                if (data.conversation && !this._pendingConversationAlerts.find(x => x.id === data.conversation.id)) {
                    this._pendingConversationAlerts.push(data.conversation);
                }
            });
            this.on(Events_1.ChatEvents.PriorityConversationAcknowledged, (data) => {
                const idx = this._pendingConversationAlerts.findIndex(x => x.id === data.conversation.id);
                if (idx > -1) {
                    this._pendingConversationAlerts.splice(idx, 1);
                }
            });
        });
        // Setup SimpleAudioPlayer
        // tslint:disable-next-line no-any
        window.simpleAudioPlayer = new simple_audio_player_1.SimpleAudioPlayer();
        // tslint:disable-next-line no-any
        window.vibrationController = new vibration_controller_1.VibrationController();
    }
    /**
     * Checks the config and forces it to work with preferences. All config fields can be replaced
     * with a __readFromPreferences__ property that is designed to be replaced via preference
     * driven configuration. This function checks if this has been set up and if so, re-jigs the
     * objects to work with how the ChatLayer expects them to be formed.
     */
    _checkConfigForPreferences(config) {
        // tslint:disable-next-line no-any
        function checkForPreferences(option, defaultValue = null) {
            if (!option) {
                return defaultValue;
            }
            if (option && option instanceof Array === false && Object.keys(option).includes("readFromPreferences")) {
                // tslint:disable-next-line no-any
                return option.readFromPreferences;
            }
            else {
                return option;
            }
        }
        config.xmpp = checkForPreferences(config.xmpp, {});
        config.behaviour = checkForPreferences(config.behaviour, {});
        config.conversationTypes = checkForPreferences(config.conversationTypes, []);
        config.roles = checkForPreferences(config.roles, {});
        config.priorities = checkForPreferences(config.priorities, []);
        return config;
    }
    // === Abstract implementations methods === //
    generateCommonComponents(host) {
        return __awaiter(this, void 0, void 0, function* () {
            this._contactInfoModal = document.querySelector("ct-cl-contact-info");
            if (!this._contactInfoModal) {
                this._contactInfoModal = document.createElement("ct-cl-contact-info");
                this._contactInfoModal.owner = this.name;
                host.appendChild(this._contactInfoModal);
            }
            // STUFF HERE
            this._alertModal = document.querySelector("ct-cl-conversation-alert");
            if (!this._alertModal) {
                this._alertModal = document.createElement("ct-cl-conversation-alert");
                this._alertModal.owner = this.name;
                host.appendChild(this._alertModal);
            }
            this._roleInfoModal = document.querySelector("ct-cl-role-users-modal");
            if (!this._roleInfoModal) {
                this._roleInfoModal = document.createElement("ct-cl-role-users-modal");
                this._roleInfoModal.owner = this.name;
                host.appendChild(this._roleInfoModal);
            }
            this._responseModal = document.querySelector("ctcl-responses-modal");
            if (!this._responseModal) {
                this._responseModal = document.createElement("ctcl-responses-modal");
                this._responseModal.owner = this.name;
                host.appendChild(this._responseModal);
            }
        });
    }
    // tslint:disable-next-line no-any
    getHandlers() {
        return Handlers_1.get(this);
    }
    // === Public functions === //
    mute() {
        this.emit(Events_1.ChatEvents.Mute);
    }
    getCurrentXmppDisplayName() {
        const currentUser = this.getCurrentUser();
        return currentUser && utils_1.formatUserName(currentUser, utils_1.NameFormat.PREFIX_INITIAL_LAST) || "";
    }
    getCurrentUser() {
        return this.comms.user;
    }
    loadAllConversations() {
        return __awaiter(this, void 0, void 0, function* () {
            const conversationsInStore = yield this.store.loadConversations();
            const latestIdentifier = yield this.store.getLatestIdentifier();
            const max = (latestIdentifier === 0)
                ? 1 // only fetch 1 message per conversation if this is the very first fetch
                : 10; // fetch up to 10 messages per conversation if we are doing a delta
            const data = {
                timestamp: latestIdentifier,
                max
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.FetchConversations, data);
            if (response.data && response.data.lastIdentifier) {
                yield this.store.updateLatestIdentifier(response.data.lastIdentifier);
            }
            const conversationsSinceLastFetch = response.data && response.data.conversations || [];
            const allConversations = [
                ...conversationsInStore
            ];
            if (conversationsSinceLastFetch.length > 0) {
                conversationsSinceLastFetch.forEach(update => {
                    const existingIdx = allConversations.findIndex(x => x.id === update.id);
                    if (existingIdx !== -1) {
                        allConversations[existingIdx] = update;
                    }
                    else {
                        allConversations.push(update);
                    }
                });
                yield this.store.saveConversations(allConversations);
            }
            allConversations.forEach(x => {
                if (x.preview && x.preview.date > (x.hideBefore || x.lastHideBefore)) {
                    x.lastHideBefore = (x.hideBefore || x.lastHideBefore);
                    x.hideBefore = 0;
                }
            });
            this._allConversations = allConversations;
        });
    }
    getConversations() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.deepCloneArray(this._allConversations || []);
        });
    }
    getConversationById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const conversations = yield this.getConversations();
            return conversations.find(x => x.id === id) || null;
        });
    }
    getConversationByRoomJid(roomJid) {
        return __awaiter(this, void 0, void 0, function* () {
            const conversations = yield this.getConversations();
            return conversations.find(x => x.roomJid === roomJid) || null;
        });
    }
    getDirectConversationByParticipants(participants) {
        return __awaiter(this, void 0, void 0, function* () {
            const map = new Map();
            const allConversations = yield this.getConversations();
            allConversations
                .filter(x => x.type === Models_1.ConversationType.Direct)
                .forEach(x => {
                map.set(ChatUtils_1.getParticipantHash(x.participants), x);
            });
            const contactHash = ChatUtils_1.getParticipantHash(participants);
            return map.get(contactHash) || null;
        });
    }
    createConversationFromProvisional(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversation.isProvisional)
                return null;
            return this.createConversation(conversation.participants, conversation.subject, conversation.description, conversation.expiryTTL, conversation.activityTTL, conversation.config);
        });
    }
    addConversation(conversation, startMeta) {
        return __awaiter(this, void 0, void 0, function* () {
            const idx = this._allConversations.findIndex(x => x.id === conversation.id);
            if (idx !== -1)
                return;
            conversation.preview = startMeta;
            this._allConversations.push(conversation);
            yield this.store.saveConversations(this._allConversations);
            this.emit(Events_1.ChatEvents.ConversationAdded, new Events_1.ConversationEventArgs(conversation));
        });
    }
    updateConversation(conversation, updateOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const idx = this._allConversations.findIndex(x => x.id === conversation.id);
            if (idx === -1)
                return;
            const existingConversation = this._allConversations[idx];
            if (updateOptions.preview) {
                // if we have a preview, and it is newer than the existing conversation preview... set it
                if (!existingConversation.preview || updateOptions.preview.date > existingConversation.preview.date) {
                    conversation.preview = updateOptions.preview;
                    if (!updateOptions.overrideHasUnread) {
                        conversation.hasUnread = true;
                    }
                }
                if (conversation.hideBefore) {
                    conversation.lastHideBefore = conversation.hideBefore;
                    conversation.hideBefore = 0;
                }
            }
            this._allConversations[idx] = utils_1.deepCloneObject(conversation);
            yield this.store.saveConversations(this._allConversations);
            const currentConversation = yield this.getCurrentConversation();
            if (currentConversation && currentConversation.id === conversation.id) {
                yield this.setCurrentConversation(conversation);
            }
            this.emit(Events_1.ChatEvents.ConversationUpdated, new Events_1.ConversationEventArgs(conversation));
            if (updateOptions.isParticipantChange) {
                this.emit(Events_1.ChatEvents.ConversationParticipantsChanged, new Events_1.ConversationParticiantsEventArgs(conversation, conversation.participants));
            }
        });
    }
    saveConversationDraft(conversation, draft) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundConversation = this._allConversations.find(x => x.id === conversation.id);
            if (!foundConversation)
                return;
            if (draft)
                foundConversation.draft = draft;
            else
                delete foundConversation.draft;
            yield this.updateConversation(foundConversation);
        });
    }
    closeConversation(conversation, reasonMeta) {
        return __awaiter(this, void 0, void 0, function* () {
            conversation.participants = [];
            conversation.isClosed = true;
            yield this.comms.clearStoredConversationMessages(conversation);
            yield this.comms.clearStoredConversationAttachments(conversation);
            yield this.updateConversation(conversation, { preview: reasonMeta });
            yield this._alertModal.conversationClosed(conversation);
            this.emit(Events_1.ChatEvents.ConversationClosed, new Events_1.ConversationEventArgs(conversation));
        });
    }
    /**
     * Launch an alert for the conversation, and emit the event to infinity to make a sound
     * @param {Conversation} conversation
     * @returns {Promise<boolean> false if the alert sound was fired (so we don't need any other noises)}
     */
    priorityAlert(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = new ConversationConfigReader_1.ConversationConfigReader(this, conversation);
            let alertSound = true;
            if (config.alert) {
                // If the priority shows an auto alert then we don't want the other alert sound playing
                alertSound = (config.alert && config.autoAlert === false);
                // Is it from myself?
                if (conversation.instigator !== this.getCurrentUserJid()) {
                    if (!ChatUtils_1.isExpiredConversation(conversation)) {
                        if (!this.shouldUserGetAlert(conversation)) {
                            return alertSound;
                        }
                        if (config.alert && config.autoAlert) {
                            // tslint:disable-next-line no-any
                            if (window.cti) {
                                // tslint:disable-next-line no-any
                                window.cti.store.variables.default_urgent_volume = config.alertVolume;
                            }
                            yield this.sendConversationReceived(conversation);
                            yield this.emit(Events_1.ChatEvents.PriorityConversationNotification, new PriorityConversationNotificationEventArgs_1.PriorityConversationNotificationEventArgs(conversation, config.alert ? true : false, config.autoAlert, true));
                        }
                        if (config.alert && config.autoAlert) {
                            yield this.store.addToPendingAlerts(conversation);
                            yield this.showConversationAlert(null, true);
                        }
                    }
                }
            }
            return alertSound;
        });
    }
    reopenConversation(conversation, participants, reasonMeta) {
        return __awaiter(this, void 0, void 0, function* () {
            conversation.participants = participants;
            conversation.isClosed = false;
            yield this.updateConversation(conversation, { preview: reasonMeta, isParticipantChange: true });
            this.emit(Events_1.ChatEvents.ConversationAdded, new Events_1.ConversationEventArgs(conversation));
        });
    }
    getCurrentConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._currentConversation;
        });
    }
    setCurrentConversation(conversation, clearExistingMessages = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const oldId = this._currentConversation && this._currentConversation.id || "";
            this._currentConversation = conversation;
            if (clearExistingMessages) {
                yield this.comms.clearStoredConversationMessages(conversation);
            }
            if (conversation.id !== oldId) {
                this.emit(Events_1.ChatEvents.CurrentConversationChanged);
            }
        });
    }
    setProvisionalConversation(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversation.isProvisional)
                return;
            const oldId = this._currentConversation && this._currentConversation.id || "";
            this._currentConversation = conversation;
            if (conversation.id !== oldId) {
                this.emit(Events_1.ChatEvents.CurrentConversationChanged);
            }
        });
    }
    belongsToCurrentConversation(chatEntry) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentConversation = yield this.getCurrentConversation();
            if (!currentConversation)
                return false;
            return utils_1.jidsMatch(chatEntry.to, currentConversation.roomJid);
        });
    }
    clearCurrentConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            this._currentConversation = null;
        });
    }
    removeConversationById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const idx = this._allConversations.findIndex(x => x.id === id);
            if (idx === -1)
                return;
            const conversation = this._allConversations[idx];
            if (!conversation.isClosed)
                return;
            this._allConversations.splice(idx, 1);
            yield this.store.saveConversations(this._allConversations);
            this.emit(Events_1.ChatEvents.ConversationRemoved);
        });
    }
    fetchConversationEntries(conversation, lastEntry = null, pageSize = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversation || conversation.isClosed || conversation.isProvisional)
                return [];
            this._isFetchingChatEntries = true;
            let lastId = lastEntry && lastEntry.id || null;
            const isInitialFetch = lastId === null;
            if (lastId === null) {
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c FETCHING INITIAL CHAT ENTRIES FOR CONVERSATION: %c${conversation.id}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            else {
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c FETCHING EARLIER CHAT ENTRIES FOR CONVERSATION: %c${conversation.id} (before ${lastId})`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            let entries = [];
            if (isInitialFetch) {
                entries = yield this._getChatEntriesFromMessageStore(conversation);
                if (entries.length)
                    lastId = entries[0].id;
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c FETCHED ${entries.length} ENTRIES FROM THE STORE`, "color: #669; font-weight: bold;", entries);
            }
            if (entries.length < pageSize) {
                if (isInitialFetch) {
                    this.logger.log(Logger_1.LoggerTypes.Mam, `%c ...NOT ENOUGH ENTRIES FOUND IN THE STORE, SUPPLEMENTING WITH MAM MESSAGES`, "color: #669; font-weight: bold;");
                }
                const mamEntries = (yield this._getChatEntriesFromMam(conversation, lastId, pageSize - entries.length)) || [];
                entries = [
                    ...mamEntries,
                    ...entries
                ];
            }
            this.logger.log(Logger_1.LoggerTypes.Mam, `%c FETCHED ${entries.length} CHAT ENTRIES`, "color: #669; font-weight: bold;", entries);
            this._isFetchingChatEntries = false;
            this.emit(Events_1.ChatEvents.ChatEntriesFetched, new Events_1.ConversationEventArgs(conversation));
            if (conversation.hideBefore || conversation.lastHideBefore) {
                return entries.filter(x => x.date > (conversation.hideBefore || conversation.lastHideBefore));
            }
            else {
                return entries;
            }
        });
    }
    fetchAllConversationEntries(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversation || conversation.isClosed || conversation.isProvisional)
                return [];
            return yield this._getChatEntriesFromMessageStore(conversation);
        });
    }
    sendConversationMessage(conversation, text, attachmentPaths, useChatMarkers) {
        return __awaiter(this, void 0, void 0, function* () {
            const echo = yield this.sendRoomChatMessage(conversation.id, text, attachmentPaths, useChatMarkers, true);
            const id = echo._id;
            const date = echo.ts;
            const currentUserJid = this.getCurrentUserJid();
            const from = currentUserJid;
            const to = conversation.roomJid;
            const attachments = echo.attachments.map(x => ({
                remote: x.get,
                local: x.path
            }));
            const chatMessage = ChatUtils_1.createChatMessage(id, date, currentUserJid, from, to, text, attachments);
            // Only update preview if the current message was sent after the preview
            if (date > conversation.preview.date) {
                conversation.preview = chatMessage;
            }
            conversation.hasUnread = false;
            if (conversation.hideBefore && conversation.preview.date > (conversation.hideBefore || conversation.lastHideBefore)) {
                conversation.lastHideBefore = (conversation.hideBefore || conversation.lastHideBefore);
                conversation.hideBefore = 0;
            }
            yield this.updateConversation(conversation);
            yield this.updateLatestIdentifier(echo);
            return chatMessage;
        });
    }
    deleteConversationMessageById(id, deleteAttachments = true) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.comms.deleteMessageById(id, deleteAttachments);
        });
    }
    updateLatestIdentifier(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const archiveId = parseInt(message.archive_id, 10);
            yield this.store.updateLatestIdentifier(archiveId);
        });
    }
    showContactInfo(contact, context, allowStartDirect, goChatFunction = null) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._contactInfoModal.show(contact, context, allowStartDirect, true, goChatFunction);
        });
    }
    showRoleUsersModal(group, animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._roleInfoModal.show(group, animate);
        });
    }
    showResponsesModal(conversation, animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._responseModal.show(conversation, animate);
        });
    }
    updateUserDirectory() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.updateUserDirectory();
        });
    }
    dismissContactInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._contactInfoModal.dismiss();
        });
    }
    showConversationAlert(conversation, animate) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._alertModal.show(conversation, animate);
        });
    }
    dismissConversationAlert() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._alertModal.dismiss();
        });
    }
    setShowChatFunction(goChatFunction) {
        this._alertModal.setShowChatFunction(goChatFunction);
    }
    markDirectConversationAsDeleted(conversation, ts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation: conversation,
                timestamp: ts || conversation.preview.date
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.HideDirectConversation, data);
            if (response.updated && response.updated.$attributes.id === conversation.id) {
                return true;
            }
            else {
                return false;
            }
        });
    }
    // === IQ-based commands === //
    createConversation(
        // type: ConversationType,
        participants, subject, description, expiry_ttl, activity_ttl, configuration, attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = new ConversationConfigReader_1.ConversationConfigReader(this, null, configuration);
            const consoleUsers = [];
            for (let i = 0; i < config.autoIncludeMembersInRoles.length; i++) {
                const group = config.autoIncludeMembersInRoles[i];
                const users = yield this.searchUsers(group, ["group"]);
                users.filter(x => x.group === group).map(x => ({ jid: x.jid, role: models_1.ChatRole.Owner })).forEach(x => {
                    if (!participants.find(p => p.jid.toLowerCase() === x.jid.toLowerCase())) {
                        consoleUsers.push(x);
                    }
                });
            }
            const data = {
                type: config.namedSettings ? Models_1.ConversationType.Named : Models_1.ConversationType.Direct,
                participants: [...participants, ...consoleUsers],
                subject,
                description,
                config: configuration,
                attachments: attachments
            };
            if (config.priorityPush) {
                data.priority = config.priorityPush;
            }
            if (config.defaultConversationExpiryTTL > 0) {
                data.expiry_ttl = config.defaultConversationExpiryTTL;
            }
            if (config.defaultConversationActivityTTL > 0) {
                data.activity_ttl = config.defaultConversationActivityTTL;
            }
            // Upload any supplied attachments
            if (data.attachments && data.attachments.length) {
                try {
                    for (let i = 0; i < data.attachments.length; i++) {
                        const getPath = yield this.comms.uploadFile(attachments[i].path);
                        data.attachments[i].path = getPath;
                    }
                }
                catch (ex) {
                    this.logger.log(Logger_1.LoggerTypes.MessageSent, ex.toString(), "Unable to upload attachment:", data.attachments);
                    this.error(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.UPLOAD_ERROR_TITLE)), this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.UPLOAD_ERROR_DESCRIPTION)));
                    return null;
                }
            }
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.CreateConversation, data);
            if (!response)
                return null;
            if (response.data.exists === true) {
                // TODO:KP: we should really go and fetch the existing conversation here, or at least be supplied with the details of the conversation
                // TODO:LR: This text needs I18ning
                this.error("Unable to create conversation", "A direct conversation between these participants already exists.");
                return null;
            }
            return response.data.newConversationId;
        });
    }
    updateNamedConversation(conversation, newSubject, newDescription) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation,
                newSubject,
                newDescription
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.UpdateConversation, data);
            this.dismissWaitingMessage();
            return !!response;
        });
    }
    addParticipantsToConversation(conversation, participants) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation,
                participants
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.AddParticipants, data);
            this.dismissWaitingMessage();
            return !!response;
        });
    }
    removeParticipantsFromConversation(conversation, participants) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation,
                participants
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.RemoveParticipants, data);
            this.dismissWaitingMessage();
            return !!response;
        });
    }
    changeParticipantRoleInConversation(conversation, participant, newRole) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation,
                participant,
                newRole
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.ChangeParticipantRole, data);
            this.dismissWaitingMessage();
            return !!response;
        });
    }
    leaveConversation(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.LeaveConversation, data);
            this.dismissWaitingMessage();
            return !!response;
        });
    }
    endConversation(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            this.showWaitingMessage(this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.PLEASE_WAIT)));
            const data = {
                conversation
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.EndConversation, data);
            this.dismissWaitingMessage();
            return !!response;
        });
    }
    getConfiguredPriorityById(id) {
        return this.config.priorities.find(p => p.id === id);
    }
    // === External function calls === //
    captureOrSelectMedia() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.externalFunctions || typeof (this.config.externalFunctions.captureOrSelectMedia) !== "function") {
                this.error("External function not implemented", "External function 'captureOrSelectMedia' is not implemented");
                throw new Error("External function 'captureOrSelectMedia' is not implemented");
            }
            try {
                return yield this.config.externalFunctions.captureOrSelectMedia();
            }
            catch (err) {
                this.error("Could not attach media", err || "An unspecified error occured");
                throw err;
            }
        });
    }
    cancelMediaSeletion(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.externalFunctions || typeof (this.config.externalFunctions.cancelMediaSeletion) !== "function") {
                this.error("External function not implemented", "External function 'cancelMediaSeletion' is not implemented");
                throw new Error("External function 'cancelMediaSeletion' is not implemented");
            }
            try {
                yield this.config.externalFunctions.cancelMediaSeletion(path);
            }
            catch (err) {
                this.error("Could not attach media", err || "An unspecified error occured");
                throw err;
            }
        });
    }
    hasMediaFullscreenHandler() {
        return (this.config.externalFunctions && typeof (this.config.externalFunctions.showMediaFullscreen) === "function");
    }
    showMediaFullscreen(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasMediaFullscreenHandler())
                return;
            try {
                yield this.config.externalFunctions.showMediaFullscreen(path);
            }
            catch (err) {
                this.error("Could not show media fullscreen", err || "An unspecified error occured");
                throw err;
            }
        });
    }
    sendConversationReceived(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.ReceivedConversation, conversation);
            return !!response;
        });
    }
    sendConversationAcknowledgement(conversation, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = {
                conversation: conversation,
                value: value
            };
            const response = yield this._sendIqCommand(Handlers_1.ChatMessageType.AcknowledgeConversation, data);
            return !!response;
        });
    }
    addToPendingAlerts(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.store.addToPendingAlerts(conversation);
        });
    }
    getNewestPendingAlert() {
        const pending = this.store.getPendingAlerts();
        if (pending.length > 0) {
            return pending[0];
        }
        else {
            return null;
        }
    }
    clearPendingAlert(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.clearPendingAlert(conversation);
        });
    }
    getPendingAlertCount() {
        return this.store.getPendingAlerts().filter(x => !ChatUtils_1.isExpiredConversation(x)).length;
    }
    purgeAllConversations() {
        return __awaiter(this, void 0, void 0, function* () {
            // Escape early if there is no value set
            if (!this.config.behaviour.maxChatEntriesToStore)
                return;
            let start = 0;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.CleanUp)) {
                start = new Date().getTime();
            }
            this.logger.log(Logger_1.LoggerTypes.CleanUp, " Purging all conversations...");
            // Get all the messages
            const allMessages = yield this.comms.getAllMessages();
            let messagesToPurge = [];
            for (const conversation of this._allConversations) {
                // Filter down to only messages in the conversation
                const messagesInConversation = allMessages.filter((message) => message.recipient_id === `${conversation.id}@${this.comms.getMucHost()}` || message.sender_id === `${conversation.id}@${this.comms.getMucHost()}`);
                // Order them by timestamp
                const messagesInConversationOrdered = messagesInConversation.sort((a, b) => {
                    return a.ts - b.ts;
                });
                // Filter out the messages to be kept (i.e. the newest n - default 30)
                const messagesInConversationToPurge = messagesInConversationOrdered.splice(0, messagesInConversationOrdered.length - this.config.behaviour.maxChatEntriesToStore);
                messagesToPurge = [...messagesToPurge, ...messagesInConversationToPurge];
            }
            // Go through the chat entries and delete them.
            for (const message of messagesToPurge) {
                yield this.deleteConversationMessageById(message._id, true);
            }
            if (this.logger.shouldLog(Logger_1.LoggerTypes.CleanUp)) {
                const end = new Date().getTime();
                const duration = (end - start);
                this.logger.log(Logger_1.LoggerTypes.CleanUp, ` Purged ${messagesToPurge.length} messages in ${duration}ms.`);
            }
        });
    }
    _executePurge(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            // Add the conversation into a list of conversations being purged
            this._conversationsBeingPurged.push(conversation.id);
            // Get the chat entries for the conversation.
            const chatEntries = yield this.comms.findChatEntriesToPurge(conversation);
            this.logger.debug(Logger_1.LoggerTypes.Other, `Purging ${chatEntries.length} messages(s) from conversation ${conversation.id}`);
            // Go through the chat entries and delete them.
            for (const chatEntry of chatEntries) {
                yield this.deleteConversationMessageById(chatEntry._id, true);
            }
            // Remove the conversation from the list of conversations being purged and emit an event out.
            this._conversationsBeingPurged = this._conversationsBeingPurged.filter(item => item !== conversation.id);
            this.emit(Events_1.ChatEvents.ConversationPurged, new Events_1.ConversationEventArgs(conversation));
        });
    }
    purgeConversation(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check for a conversation before anything else.
            if (!conversation)
                return;
            // Escape early if there is no value set
            if (!this.config.behaviour.maxChatEntriesToStore)
                return;
            // To avoid errors from trying to retrieve a chat entry at the same time as deletion avoid a purge of the conversation if it the current conversation
            if (this._currentConversation && conversation.id === this._currentConversation.id)
                return;
            // Do not purge the conversation if it is an priority alert sent whilst the app was not open
            if (this._pendingConversationAlerts.find(x => x.id === conversation.id)) {
                return;
            }
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (this._isFetchingChatEntries || this.isProcessing()) {
                    this.on(Events_1.ChatEvents.MessageProcessorQueueEmpty, () => __awaiter(this, void 0, void 0, function* () {
                        yield this._executePurge(conversation);
                        resolve();
                    }), true);
                }
                else {
                    yield this._executePurge(conversation);
                    resolve();
                }
            }));
        });
    }
    isConversationBeingPurged(conversationId) {
        return this._conversationsBeingPurged.includes(conversationId);
    }
    /**
     * Returns an array of the configured conversation types that is sorted and ready to be used.
     */
    getConfiguredConversations() {
        if (!this.config.conversationTypes) {
            return [];
        }
        return this.config.conversationTypes
            .sort((a, b) => a.sortOrder > b.sortOrder ? 1 : a.sortOrder < b.sortOrder ? -1 :
            a.name > b.name ? 1 : a.name < b.name ? -1 : 0);
    }
    doesDirectConversationExistInConfiguration() {
        return this.config.conversationTypes.find(x => !x.behaviour.namedSettings);
    }
    // === Private functions === //
    _sendIqCommand(messageType, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendIq(this.config.xmpp.iq.host, "set", messageType, data);
        });
    }
    _getChatEntriesFromMessageStore(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            const xmppMessages = yield this.comms.getChatHistory(conversation.roomJid);
            const chatEntries = yield Promise.all(xmppMessages.map((message) => __awaiter(this, void 0, void 0, function* () { return yield ChatUtils_1.convertToChatEntry(message, this); })));
            return chatEntries.filter(x => x !== null);
        });
    }
    _getChatEntriesFromMam(conversation, lastId = null, count = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionStatus = this.getConnectionStatus();
            if (connectionStatus !== models_1.ConnectionStatus.Connected)
                throw new errors_1.NotConnectedError(connectionStatus);
            try {
                let timestamp = conversation.hideBefore || conversation.lastHideBefore || null;
                if (timestamp)
                    timestamp++;
                return yield this.comms.fetchConversationMessages(conversation, lastId, count, timestamp);
            }
            catch (ex) {
                const title = this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.FETCH_ERROR));
                this.error(title, ex);
                return [];
            }
        });
    }
    // === I18n static helper === //
    static getUniqueTranslationKeys(fullyQualified = false, ...scopes) {
        return [
            ...base_1.BaseLayer.getUniqueTranslationKeys(fullyQualified, ...scopes),
            ...I18n_1.getChatI18nKeys(fullyQualified, ...scopes)
        ]
            .filter((key, idx, arr) => {
            return arr.indexOf(key) === idx;
        })
            .sort();
    }
    setStatusBarColor(color) {
        // tslint:disable-next-line no-any
        const win = window;
        if (win.cti && win.StatusBar) {
            win.StatusBar.backgroundColorByHexString(color);
        }
    }
    shouldUserGetAlert(conversation) {
        if (conversation.instigator === this.getCurrentUserJid())
            return false;
        const config = new ConversationConfigReader_1.ConversationConfigReader(this, conversation);
        const autoIncludeMembersInRoles = Array.isArray(config.autoIncludeMembersInRoles) ? config.autoIncludeMembersInRoles.map(x => x.toLowerCase()) : [];
        const currentUsersGroups = this.getCurrentUser().group.split(", ").map(x => x.toLowerCase());
        const inAutoIncludeGroup = autoIncludeMembersInRoles.some(r => currentUsersGroups.includes(r));
        if (!inAutoIncludeGroup)
            return true;
        const isOwnerOfConversation = conversation.participants.find(x => x.jid === this.getCurrentUserJid()).role === models_1.ChatRole.Owner;
        return !isOwnerOfConversation;
    }
}
exports.ChatLayer = ChatLayer;
window.CtChatLayer = ChatLayer;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const utils_1 = __webpack_require__(2);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const component_1 = __webpack_require__(15);
const VirtualList_1 = __webpack_require__(33);
const renderUtils_1 = __webpack_require__(8);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["NO_USERS"] = "There are no users for this role."] = "NO_USERS";
    I18nKeys[I18nKeys["USERS"] = "Users"] = "USERS";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLRoleUsersModal = class CTCLRoleUsersModal extends Base_1.CTCLComponent {
    constructor() {
        // === Attribute properties === //
        super(...arguments);
        // === End properties === //
        this._chatGroup = null;
        this._animationDuration = 500;
        this._goChatFunction = null;
        this.TILE_HEIGHT = 70;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._virtualList = new VirtualList_1.VirtualList(this, [], {
                itemHeight: this.TILE_HEIGHT,
                itemKeyGetter: x => x.jid
            });
            this._virtualList.setItems([]);
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener();
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "contact-info" },
            this._renderHeader(),
            window.__CTRender("div", { class: "user-list-items" }, this._renderUsers())));
    }
    _renderHeader() {
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, `${this._chatGroup ? this._chatGroup.name : ""} ${this.translateI18nItem(I18nKeys.USERS)}`),
            window.__CTRender("div", { slot: "sub-heading" })));
    }
    _renderUsers() {
        const totalUsers = this.usersToDisplay.length;
        if (totalUsers === 0) {
            return (window.__CTRender("div", { class: "no-users" }, this.translateI18nItem(I18nKeys.NO_USERS)));
        }
        return this._virtualList.render(this._renderItem.bind(this), "users", "users-content");
    }
    _renderItem(item, props) {
        const classes = [
            "user"
        ];
        // if (typeof (this.onClickUser) === "function") classes.push("clickable");
        const detailStyle = renderUtils_1.buildStyles({
            paddingRight: "36px"
        });
        return (window.__CTRender("div", Object.assign({ class: classes.join(" ") }, props),
            window.__CTRender(components_1.CTUserTile, { user: item, nameFormat: this.nameFormat, height: `${this.TILE_HEIGHT}px`, detailStyle: detailStyle })));
    }
    // === Event handlers === //
    _back() {
        this.dismiss();
    }
    // === Public functions === //
    show(group, animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const groupMemberMap = yield this.layer.getGroupMemberCache();
            this._chatGroup = group;
            this.usersToDisplay = groupMemberMap[group.name];
            this._virtualList.setItems(this.usersToDisplay);
            this.animate = animate;
            this.showing = true;
            this.layer.setBackHandler(() => {
                this._back();
            });
            yield utils_1.sleep(animate ? this._animationDuration : 0);
        });
    }
    dismiss(animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.animate = animate;
            this.showing = false;
            this.layer.popBackHandler();
            yield utils_1.sleep(animate ? this._animationDuration : 0);
            this._chatGroup = null;
            this.usersToDisplay = [];
            this._virtualList.setItems([]);
        });
    }
};
__decorate([
    base_1.prop({ type: Object, attribute: false, default: utils_1.NameFormat.PREFIX_FIRST_LAST })
], CTCLRoleUsersModal.prototype, "nameFormat", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: true })
], CTCLRoleUsersModal.prototype, "animate", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTCLRoleUsersModal.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTCLRoleUsersModal.prototype, "usersToDisplay", void 0);
CTCLRoleUsersModal = __decorate([
    component_1.component({ tag: "ct-cl-role-users-modal", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex-direction:column;position:fixed;top:0;left:0;height:100%;width:100%;background:#ffffff;font-size:1em;transform:translateY(100%);will-change:transform;z-index:99997}:host .contact-info{flex:1 1 auto;display:flex;flex-direction:column;height:100%;background-color:var(--list-bg);color:var(--default-font-color)}:host .contact-info .header .action{cursor:pointer}:host .contact-info .user-list-items{position:relative;display:flex;flex-direction:column;flex:1 1 auto;height:100%;overflow:hidden}:host .contact-info .user-list-items .users-loading-bg{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;background:var(--list-bg, #f2f2f2);z-index:-1}:host .contact-info .user-list-items .users{flex:1 1 auto;overflow:auto;-webkit-overflow-scrolling:touch}:host .contact-info .user-list-items .users .user{position:relative}:host .contact-info .user-list-items .users .user .selection{position:absolute;top:0;right:0;height:100%;display:flex;justify-content:center;align-items:center;padding:0 20px;cursor:pointer}:host .contact-info .user-list-items .users .user .selection .checkbox{display:flex;justify-content:center;align-items:center;width:16px;height:16px;color:var(--subtle-font-color, #828688);border:2px solid var(--subtle-font-color, #828688)}:host .contact-info .user-list-items .users .user.selected .selection .checkbox{border:0}:host .contact-info .user-list-items .users .user.selection-disabled .selection{opacity:0;cursor:not-allowed}:host .contact-info .user-list-items .users .user.clickable{cursor:pointer}:host([animate]){transition:transform var(--animation-normal, .5s) ease-out}:host([showing]){transform:translateY(0)}
    `], i18nKeys: I18nKeys })
], CTCLRoleUsersModal);
exports.CTCLRoleUsersModal = CTCLRoleUsersModal;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const component_1 = __webpack_require__(15);
const Base_1 = __webpack_require__(12);
const models_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(2);
const ct_cl_header_1 = __webpack_require__(19);
const components_1 = __webpack_require__(3);
const ctcl_response_view_1 = __webpack_require__(50);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["RESPONSES"] = "Responses"] = "RESPONSES";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLResponsesModal = class CTCLResponsesModal extends Base_1.CTCLComponent {
    constructor() {
        // === Props === //
        super(...arguments);
        this._animationDuration = 500;
    }
    // === Init === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() { }
    show(conversation, animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.conversation = conversation;
            this.animate = animate;
            this.showing = true;
            this.layer.setBackHandler(() => {
                this._back();
            });
            yield utils_1.sleep(animate ? this._animationDuration : 0);
        });
    }
    dismiss(animate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.animate = animate;
            this.showing = false;
            this.layer.popBackHandler();
            yield utils_1.sleep(animate ? this._animationDuration : 0);
            this.conversation = null;
        });
    }
    // === Private === //
    _back() {
        this.dismiss();
    }
    // === Render === //
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "container" },
            this._renderHeader(),
            window.__CTRender("div", { class: "user-responses" }, this.conversation && window.__CTRender(ctcl_response_view_1.CTCLResponseView, { conversation: this.conversation }))));
    }
    _renderHeader() {
        return (window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header" },
            window.__CTRender("div", { slot: "left-action" },
                window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: this._back.bind(this) })),
            window.__CTRender("div", { slot: "heading" }, `${this.translateI18nItem(I18nKeys.RESPONSES)}`),
            window.__CTRender("div", { slot: "sub-heading" })));
    }
};
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLResponsesModal.prototype, "conversation", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: true })
], CTCLResponsesModal.prototype, "animate", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTCLResponsesModal.prototype, "showing", void 0);
CTCLResponsesModal = __decorate([
    component_1.component({ tag: "ctcl-responses-modal", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex-direction:column;position:fixed;top:0;left:0;height:100%;width:100%;background:#ffffff;font-size:1em;transform:translateY(100%);will-change:transform;z-index:99997}:host .container{flex:1 1 auto;display:flex;flex-direction:column;height:100%;background-color:var(--list-bg);color:var(--default-font-color)}:host .container .header .action{cursor:pointer}:host .container .user-responses{position:relative;display:flex;flex-direction:column;flex:1 1 auto;height:100%;overflow:hidden}:host([animate]){transition:transform var(--animation-normal, .5s) ease-out}:host([showing]){transform:translateY(0)}
    `] })
], CTCLResponsesModal);
exports.CTCLResponsesModal = CTCLResponsesModal;


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = workerFunction;
function workerFunction() {

    // The crypto library, null if using pure JS implementation
    let subtle = null;
    let _initialised = false;
    let _idx = null;
    let _idxKey = "lunr_index";
    let _idxBlock = "idxBlock";
    let _docBlock = "docBlock";
    const elasticlunr = createLunr();
    let _key = null;
    let _iv = null;
    let _blockSize = 2000;
    let _debug = true;
    const _promiseMap = new Map();

    function utoa(str) {
        return btoa(unescape(encodeURIComponent(str)));
    }

    // DB row for whether using pure JS
    let _usePureJs = "pureJs";

    self.onmessage = function (e) {

        switch (e.data.action) {
            case "initialise":

                const _initSuccess = () => {
                    _initialised = true;
                    self.postMessage({
                        _id: e.data._id,
                        action: "initialisation-complete",
                        success: true,
                        msg: "Successfully initialised the user index."
                    });
                };

                const _initFail = (msg) => {
                    self.postMessage({
                        _id: e.data._id,
                        action: "initialisation-complete",
                        success: false,
                        msg: msg
                    });
                };

                if (!e.data.instanceId) {
                    _initFail("Error initialising user index database.");
                    return;
                }

                _debug = (e.data.debug === true);
                this._blockSize = e.data.blockSize || this._blockSize;
               
                // Should we use pure JS implementation?
                useOldCrypto()
                    .then(old => {
                    if (old) {
                        aes();
                        this.subtle = null;
                    } else {
                        this.subtle = self.crypto.subtle;
                    }

                    importKey(e.data.key)
                        .then(key => {
                        this._key = key;
                        this._iv = e.data.iv;

                        retrieveIndex().then(data => {
                            if (data) {
                                _idx = elasticlunr.Index.load(data);
                            }
                            _initSuccess();
                        }).catch(e => {
                            _initFail("Failed reading database for previously stored index.");
                        });
                    }).catch(e => {
                        _initFail("Failed importing key for previously stored index.");
                    });
                }).catch(e => {
                    _initFail("Failed detecting crypto type for previously stored index");
                });
                
                break;
            case "fetch":
                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "index-complete",
                        msg: "Initialisation must be completed before the 'fetch' action can take place."
                    });
                    return;
                }

                const fetchStart = Date.now();
                fetch(e.data.endpoint, {
                    method: "GET",
                    headers: {
                        "Authorization": "Basic " + utoa(`${e.data.jid}:${e.data.pass}`)
                    }
                }).then(response => {
                    if (response.status !== 200) {
                        throw new Error(`Couldn't download user directory. Status code: '${response.status}'.`);    
                    }
                    return response.json();
                }).then(results => {
                    const data = {
                        added: results.added || [],
                        updated: results.updated || [],
                        removed: results.removed || []
                    };
                    if (results.full !== undefined) {
                        // If we've been given a "full" data set then we need to trash anything we previously new about and start again to ensure everything stays in sync
                        _idx = null;
                        // Then we shift the objects on the "full" property on to the added property
                        data.added = results.full;
                    }
                    const downloadTime = Date.now() - fetchStart;
                    const info = [`Downloaded '${data.added.length}' additions, '${data.updated.length}' updates and '${data.removed.length}' deletions in ${downloadTime}ms`];
                    if (_idx === null) {

                        _idx = elasticlunr(function () {
                            this.setRef("jid");
                            this.addField("jid");
                            this.addField("firstName");
                            this.addField("lastName");
                            this.addField("jobTitle");
                            this.addField("telephone");
                            this.addField("group");
                            this.saveDocument(true);
                        });
                        info.push(`Created a fresh index`);
                    }

                    if (data.added.length > 0) {
                        data.added.forEach(user => _idx.addDoc(user));
                        info.push(`Added '${data.added.length}' users to index`);
                    }
                    if (data.updated.length > 0) {
                        data.updated.forEach(user => _idx.updateDoc(user));
                        info.push(`Updated '${data.updated.length}' users in index`);
                    }
                    if (data.removed.length > 0) {
                        data.removed.forEach(user => _idx.removeDoc(user));
                        info.push(`Removed '${data.removed.length}' users from index`);
                    }

                    saveIndex(_blockSize).then(() => {
                        self.postMessage({
                            _id: e.data._id,
                            success: true,
                            action: "index-complete",
                            hash: results.hash || null,
                            msg: `${info.join(", ")} | Completed in ${Date.now() - fetchStart}ms.`
                        });
                    }).catch(err => {
                        self.postMessage({
                            _id: e.data._id,
                            success: false,
                            action: "index-complete",
                            msg: "Couldn't persist updated index."
                        });
                    });

                }).catch(err => {
                    const msg = `Unable to download user directory from location '${e.data.endpoint}'`;
                    console.error(msg, err);
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "index-complete",
                        msg: msg
                    });
                });

                break;
            case "search":

                // Remove all the stop words, we are searching users here so we will want to search for "and" for example
                elasticlunr.clearStopWords();

                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "search-complete",
                        msg: "Initialisation must be completed before the 'search' action can take place."
                    });
                    return;
                }

                // Make sure we have an index to search
                if (_idx === null) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "search-complete",
                        msg: "There is no index to be searched, have you updated the index yet?"
                    });
                    return;
                }

                const searchStart = Date.now();
                let results = null;

                if (Array.isArray(e.data.fields) && e.data.fields.length > 0) {
                    const config = {
                        fields: {},
                        bool: "OR",
                        expand: true
                    };
                    e.data.fields.forEach(field => {
                        config.fields[field] = {};
                    });
                    results = _idx.search(e.data.query, config);
                } else {
                    results = _idx.search(e.data.query, {
                        expand: true
                    });
                }

                const data = results.map(res => {
                    return res.doc;
                });
                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    action: "search-complete",
                    msg: `Found ${data.length} users in ${Date.now() - searchStart}ms.`,
                    results: data
                });

                break;
            case "jid-search":

                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "jid-search-complete",
                        msg: "Initialisation must be completed before the 'jid-search' action can take place."
                    });
                    return;
                }

                // Make sure we have an index to search
                if (_idx === null) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "jid-search-complete",
                        msg: "There is no index to be searched, have you updated the index yet?"
                    });
                    return;
                }
                const jidSearchStart = Date.now();
                const result = _idx.search(e.data.jid, {
                    expand: true
                })[0];
                const user = (result !== undefined) ? result.doc : null;
                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    action: "jid-search-complete",
                    msg: (user !== null) ? `Found user with JID '${e.data.jid}' in ${Date.now() - jidSearchStart}ms.` : `No user with JID '${e.data.jid}' could be found.`,
                    result: user
                });

                break;

            case "get-all-users":

                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "get-all-users-complete",
                        msg: "Initialisation must be completed before the 'get-all-users' action can take place."
                    });
                    return;
                }

                // Make sure we have an index to search
                if (_idx === null) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "get-all-users-complete",
                        msg: "There is no index available, have you updated the index yet?"
                    });
                    return;
                }

                const getAllUsersStart = Date.now();
                const users = [];
                for (let jid in _idx.documentStore.docs) {
                    users.push(_idx.documentStore.docs[jid])
                }

                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    action: "get-all-users-complete",
                    msg: `Fetched '${users.length}' users in ${Date.now() - getAllUsersStart}ms.`,
                    results: users
                });

                break;
            case "store-record-response":
            case "retrieve-record-response":
                const promises = _promiseMap.get(e.data.key);
                if (promises) {
                    if (e.data.success) {
                        promises.resolve(e.data.record);
                    } else {
                        promises.reject(e.data.msg);
                    }
                    _promiseMap.delete(e.data.key);
                }                
                break;
            default:
                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    msg: `Invalid action '${e.data.action}' was specified.`
                });
        }

        function encryptRecord(user) {
            return new Promise( (resolve, reject) => {
                textToByteArray(JSON.stringify(user)).then(buf => {
                    if (this.subtle) {
                        this.subtle.encrypt({
                            name: "AES-CBC",
                            iv: this._iv
                        }, this._key, buf).then(encrypted => {
                            resolve(encrypted);
                        }).catch(reject);
                    } else {
                        const aes = new aesjs.ModeOfOperation.ctr(this._key);
                        const encrypted = aes.encrypt(buf);
                        resolve(encrypted);
                    }
                }).catch(reject);
            });
        }

        function decryptRecord(encrypted) {
            return new Promise((resolve, reject) => {
                if (this.subtle) {
                    this.subtle.decrypt(
                        {
                            name: "AES-CBC",
                            iv: this._iv
                        },
                        this._key,
                        encrypted
                    ).then(decrypted => {
                        const charArray = new Uint8Array(decrypted);
                        byteArrayToText(charArray).then(str => {
                            resolve(JSON.parse(str));
                        }).catch(reject);
                    }).catch(reject);
                } else {
                    const aes = new aesjs.ModeOfOperation.ctr(this._key);
                    const charArray = aes.decrypt(encrypted);
                    byteArrayToText(charArray).then(str => {
                        resolve(JSON.parse(str));
                    }).catch(reject);
                }
            });
        }

        function storeRecord(key, data) {
            return new Promise((resolve, reject) => {
                _promiseMap.set(key, { resolve, reject });
                self.postMessage({
                    action: "store-record",
                    key: key,
                    record: data
                });
            });
        }

        function retrieveRecord(key) {
            return new Promise((resolve, reject) => {
                _promiseMap.set(key, { resolve, reject });
                self.postMessage({
                    action: "retrieve-record",
                    key: key
                });
            });
        }

        function saveIndex(blocksize = 1000) {
            if (_debug) console.time("encrypt");
            return new Promise((resolve, reject) => {
                let blocks = 0;
                let chunks = 0;
                const index = _idx.toJSON();
                const copy = JSON.parse(JSON.stringify(index));
                const docKeys = Object.keys(copy.documentStore.docs);
                const idxKeys = Object.keys(copy.index);

                function cycle() {
                    if (docKeys.length === 0) {
                        if (_debug) console.timeEnd("encrypt");
                        if (_debug) console.time("index");

                        copy.documentStore.docs = {};
                        if (_debug) console.time("index2");
                        cycle2();
                    } else {
                        const props = docKeys.splice(0, blocksize);
                        const temp = {};
                        props.forEach(prop => {
                            const entry = index.documentStore.docs[prop];
                            temp[prop] = entry;
                        });
                        if (_debug) console.time("block")
                        encryptRecord(temp).then(encrypted => {
                            storeRecord(_docBlock + blocks++, encrypted).then(() => {
                                if (_debug) console.timeEnd("block");
                                cycle();
                            }).catch(reject);
                        }).catch(reject);
                    }
                }

                function cycle2() {
                    if (idxKeys.length === 0) {;

                        copy.index = {};
                        encryptRecord(copy).then(encrypted => {
                            if (_debug) console.timeEnd("index2");
                            storeRecord(_idxKey, encrypted).then(resolve).catch(reject);
                        });
                    } else {
                        const prop = idxKeys.shift();
                        if (_debug) console.time("chunk")
                        encryptRecord({"prop": prop, "data": copy.index[prop]}).then(encrypted => {
                            storeRecord(_idxBlock + chunks++, encrypted).then(() => {
                                if (_debug) console.timeEnd("chunk");
                                cycle2();
                            });
                        });
                    }
                }

                cycle();
            });
        }

        function retrieveIndex() {
            return new Promise((resolve, reject) => {
                let index = null;
                let block = 0;
                let chunk = 0;

                // Get the main block of index
                retrieveRecord(_idxKey).then(encrypted => {
                    if(!encrypted) {
                        // There wasn't one, must be first time
                        return resolve(index);
                    }
                    decryptRecord(encrypted).then(idx => {
                        index = idx;
                        cycle();
                    }).catch(reject);
                }).catch(reject);

                // Cycle through blocks of index, decrypting each until there are no more
                function cycle() {
                    retrieveRecord(_docBlock + block).then(data => {
                        if (!data) {
                            return cycle2();
                        } else {
                            decryptRecord(data).then(parent => {
                                index.documentStore.docs = Object.assign(index.documentStore.docs, parent);
                                block++;
                                cycle();
                            }).catch(reject);
                        }
                    }).catch(reject);
                }

                function cycle2() {
                    retrieveRecord(_idxBlock + chunk).then(data => {
                        if (!data) {
                            return resolve(index);
                        } else {
                            decryptRecord(data).then(parent => {
                                index.index[parent.prop] = parent.data;
                                chunk++;
                                cycle2();
                            }).catch(reject);
                        }
                    }).catch(reject);
                }
            });
        }

        // Detect and store whether using pure JS AES
        function useOldCrypto() {
            return new Promise((resolve, reject) => {
                retrieveRecord(_usePureJs).then(old => {
                    if(old === undefined) {
                        const newOld = self.crypto.subtle === undefined;
                        storeRecord(_usePureJs, newOld).then(() => {
                            resolve(newOld);
                        });
                    } else {
                        resolve(old);
                    }
                });
            });
        }

        function textToByteArray(text) {
            return new Promise( (resolve, reject) => {
                const encoder = new TextEncoder();
                resolve(encoder.encode(text));
            });
        }

        function byteArrayToText(bytes) {
            return new Promise((resolve, reject) => {
                const decoder = new TextDecoder();
                resolve(decoder.decode(bytes));
            });
        }

        function importKey(key) {
            return new Promise((resolve, reject) => {
                if (this.subtle) {
                    this.subtle.importKey("raw", key, {name: "AES-CBC"}, false, ["encrypt", "decrypt"]).then(outKey => {
                        resolve(outKey);
                    });
                } else {
                    resolve(key);
                }
            });
        }

    };

    function createLunr () {

        var elasticlunr = function(config) {
            var idx = new elasticlunr.Index;

            idx.pipeline.add(
                elasticlunr.trimmer,
                elasticlunr.stopWordFilter,
                elasticlunr.stemmer
            );

            if (config) config.call(idx, idx);

            return idx;
        };

        elasticlunr.version = "0.9.5";

        lunr = elasticlunr;

        elasticlunr.utils = {};

        elasticlunr.utils.warn = (function(global) {
            return function(message) {
                if (global.console && console.warn) {
                    console.warn(message);
                }
            };
        })(this);

        elasticlunr.utils.toString = function(obj) {
            if (obj === void 0 || obj === null) {
                return "";
            }

            return obj.toString();
        };

        elasticlunr.EventEmitter = function() {
            this.events = {};
        };

        elasticlunr.EventEmitter.prototype.addListener = function() {
            var args = Array.prototype.slice.call(arguments),
                fn = args.pop(),
                names = args;

            if (typeof fn !== "function") throw new TypeError("last argument must be a function");

            names.forEach(function(name) {
                if (!this.hasHandler(name)) this.events[name] = [];
                this.events[name].push(fn);
            }, this);
        };

        elasticlunr.EventEmitter.prototype.removeListener = function(name, fn) {
            if (!this.hasHandler(name)) return;

            var fnIndex = this.events[name].indexOf(fn);
            if (fnIndex === -1) return;

            this.events[name].splice(fnIndex, 1);

            if (this.events[name].length == 0) delete this.events[name];
        };

        elasticlunr.EventEmitter.prototype.emit = function(name) {
            if (!this.hasHandler(name)) return;

            var args = Array.prototype.slice.call(arguments, 1);

            this.events[name].forEach(function(fn) {
                fn.apply(undefined, args);
            }, this);
        };

        elasticlunr.EventEmitter.prototype.hasHandler = function(name) {
            return name in this.events;
        };

        elasticlunr.tokenizer = function(str) {
            if (!arguments.length || str === null || str === undefined) return [];
            if (Array.isArray(str)) {
                var arr = str.filter(function(token) {
                    if (token === null || token === undefined) {
                        return false;
                    }

                    return true;
                });

                arr = arr.map(function(t) {
                    return elasticlunr.utils.toString(t).toLowerCase();
                });

                var out = [];
                arr.forEach(function(item) {
                    var tokens = item.split(elasticlunr.tokenizer.seperator);
                    out = out.concat(tokens);
                }, this);

                return out;
            }

            return str.toString().trim().toLowerCase().split(elasticlunr.tokenizer.seperator);
        };

        elasticlunr.tokenizer.defaultSeperator = /[\s\-]+/;

        elasticlunr.tokenizer.seperator = elasticlunr.tokenizer.defaultSeperator;

        elasticlunr.tokenizer.setSeperator = function(sep) {
            if (sep !== null && sep !== undefined && typeof(sep) === 'object') {
                elasticlunr.tokenizer.seperator = sep;
            }
        }

        elasticlunr.tokenizer.resetSeperator = function() {
            elasticlunr.tokenizer.seperator = elasticlunr.tokenizer.defaultSeperator;
        }

        elasticlunr.tokenizer.getSeperator = function() {
            return elasticlunr.tokenizer.seperator;
        }

        elasticlunr.Pipeline = function() {
            this._queue = [];
        };

        elasticlunr.Pipeline.registeredFunctions = {};

        elasticlunr.Pipeline.registerFunction = function(fn, label) {
            if (label in elasticlunr.Pipeline.registeredFunctions) {
                elasticlunr.utils.warn('Overwriting existing registered function: ' + label);
            }

            fn.label = label;
            elasticlunr.Pipeline.registeredFunctions[label] = fn;
        };

        elasticlunr.Pipeline.getRegisteredFunction = function(label) {
            if ((label in elasticlunr.Pipeline.registeredFunctions) !== true) {
                return null;
            }

            return elasticlunr.Pipeline.registeredFunctions[label];
        };

        elasticlunr.Pipeline.warnIfFunctionNotRegistered = function(fn) {
            var isRegistered = fn.label && (fn.label in this.registeredFunctions);

            if (!isRegistered) {
                elasticlunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn);
            }
        };

        elasticlunr.Pipeline.load = function(serialised) {
            var pipeline = new elasticlunr.Pipeline;

            serialised.forEach(function(fnName) {
                var fn = elasticlunr.Pipeline.getRegisteredFunction(fnName);

                if (fn) {
                    pipeline.add(fn);
                } else {
                    throw new Error('Cannot load un-registered function: ' + fnName);
                }
            });

            return pipeline;
        };

        elasticlunr.Pipeline.prototype.add = function() {
            var fns = Array.prototype.slice.call(arguments);

            fns.forEach(function(fn) {
                elasticlunr.Pipeline.warnIfFunctionNotRegistered(fn);
                this._queue.push(fn);
            }, this);
        };

        elasticlunr.Pipeline.prototype.after = function(existingFn, newFn) {
            elasticlunr.Pipeline.warnIfFunctionNotRegistered(newFn);

            var pos = this._queue.indexOf(existingFn);
            if (pos === -1) {
                throw new Error('Cannot find existingFn');
            }

            this._queue.splice(pos + 1, 0, newFn);
        };

        elasticlunr.Pipeline.prototype.before = function(existingFn, newFn) {
            elasticlunr.Pipeline.warnIfFunctionNotRegistered(newFn);

            var pos = this._queue.indexOf(existingFn);
            if (pos === -1) {
                throw new Error('Cannot find existingFn');
            }

            this._queue.splice(pos, 0, newFn);
        };

        elasticlunr.Pipeline.prototype.remove = function(fn) {
            var pos = this._queue.indexOf(fn);
            if (pos === -1) {
                return;
            }

            this._queue.splice(pos, 1);
        };

        elasticlunr.Pipeline.prototype.run = function(tokens) {
            var out = [],
                tokenLength = tokens.length,
                pipelineLength = this._queue.length;

            for (var i = 0; i < tokenLength; i++) {
                var token = tokens[i];

                for (var j = 0; j < pipelineLength; j++) {
                    token = this._queue[j](token, i, tokens);
                    if (token === void 0 || token === null) break;
                };

                if (token !== void 0 && token !== null) out.push(token);
            };

            return out;
        };

        elasticlunr.Pipeline.prototype.reset = function() {
            this._queue = [];
        };

        elasticlunr.Pipeline.prototype.get = function() {
            return this._queue;
        };

        elasticlunr.Pipeline.prototype.toJSON = function() {
            return this._queue.map(function(fn) {
                elasticlunr.Pipeline.warnIfFunctionNotRegistered(fn);
                return fn.label;
            });
        };

        elasticlunr.Index = function() {
            this._fields = [];
            this._ref = 'id';
            this.pipeline = new elasticlunr.Pipeline;
            this.documentStore = new elasticlunr.DocumentStore;
            this.index = {};
            this.eventEmitter = new elasticlunr.EventEmitter;
            this._idfCache = {};

            this.on('add', 'remove', 'update', (function() {
                this._idfCache = {};
            }).bind(this));
        };

        elasticlunr.Index.prototype.on = function() {
            var args = Array.prototype.slice.call(arguments);
            return this.eventEmitter.addListener.apply(this.eventEmitter, args);
        };

        elasticlunr.Index.prototype.off = function(name, fn) {
            return this.eventEmitter.removeListener(name, fn);
        };

        elasticlunr.Index.load = function(serialisedData) {
            if (serialisedData.version !== elasticlunr.version) {
                elasticlunr.utils.warn('version mismatch: current ' +
                    elasticlunr.version + ' importing ' + serialisedData.version);
            }

            var idx = new this;

            idx._fields = serialisedData.fields;
            idx._ref = serialisedData.ref;
            idx.documentStore = elasticlunr.DocumentStore.load(serialisedData.documentStore);
            idx.pipeline = elasticlunr.Pipeline.load(serialisedData.pipeline);
            idx.index = {};
            for (var field in serialisedData.index) {
                idx.index[field] = elasticlunr.InvertedIndex.load(serialisedData.index[field]);
            }

            return idx;
        };

        elasticlunr.Index.prototype.addField = function(fieldName) {
            this._fields.push(fieldName);
            this.index[fieldName] = new elasticlunr.InvertedIndex;
            return this;
        };

        elasticlunr.Index.prototype.setRef = function(refName) {
            this._ref = refName;
            return this;
        };

        elasticlunr.Index.prototype.saveDocument = function(save) {
            this.documentStore = new elasticlunr.DocumentStore(save);
            return this;
        };

        elasticlunr.Index.prototype.addDoc = function(doc, emitEvent) {
            if (!doc) return;
            var emitEvent = emitEvent === undefined ? true : emitEvent;

            var docRef = doc[this._ref];

            this.documentStore.addDoc(docRef, doc);
            this._fields.forEach(function(field) {
                var fieldTokens = this.pipeline.run(elasticlunr.tokenizer(doc[field]));
                this.documentStore.addFieldLength(docRef, field, fieldTokens.length);

                var tokenCount = {};
                fieldTokens.forEach(function(token) {
                    if (token in tokenCount) tokenCount[token] += 1;
                    else tokenCount[token] = 1;
                }, this);

                for (var token in tokenCount) {
                    var termFrequency = tokenCount[token];
                    termFrequency = Math.sqrt(termFrequency);
                    this.index[field].addToken(token, {
                        ref: docRef,
                        tf: termFrequency
                    });
                }
            }, this);

            if (emitEvent) this.eventEmitter.emit('add', doc, this);
        };

        elasticlunr.Index.prototype.removeDocByRef = function(docRef, emitEvent) {
            if (!docRef) return;
            if (this.documentStore.isDocStored() === false) {
                return;
            }

            if (!this.documentStore.hasDoc(docRef)) return;
            var doc = this.documentStore.getDoc(docRef);
            this.removeDoc(doc, false);
        };

        elasticlunr.Index.prototype.removeDoc = function(doc, emitEvent) {
            if (!doc) return;

            var emitEvent = emitEvent === undefined ? true : emitEvent;

            var docRef = doc[this._ref];
            if (!this.documentStore.hasDoc(docRef)) return;

            this.documentStore.removeDoc(docRef);

            this._fields.forEach(function(field) {
                var fieldTokens = this.pipeline.run(elasticlunr.tokenizer(doc[field]));
                fieldTokens.forEach(function(token) {
                    this.index[field].removeToken(token, docRef);
                }, this);
            }, this);

            if (emitEvent) this.eventEmitter.emit('remove', doc, this);
        };

        elasticlunr.Index.prototype.updateDoc = function(doc, emitEvent) {
            var emitEvent = emitEvent === undefined ? true : emitEvent;

            this.removeDocByRef(doc[this._ref], false);
            this.addDoc(doc, false);

            if (emitEvent) this.eventEmitter.emit('update', doc, this);
        };

        elasticlunr.Index.prototype.idf = function(term, field) {
            var cacheKey = "@" + field + '/' + term;
            if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey];

            var df = this.index[field].getDocFreq(term);
            var idf = 1 + Math.log(this.documentStore.length / (df + 1));
            this._idfCache[cacheKey] = idf;

            return idf;
        };

        /**
         * get fields of current index instance
         *
         * @return {Array}
         */
        elasticlunr.Index.prototype.getFields = function() {
            return this._fields.slice();
        };

        /**
         * Searches the index using the passed query.
         * Queries should be a string, multiple words are allowed.
         *
         * If config is null, will search all fields defaultly, and lead to OR based query.
         * If config is specified, will search specified with query time boosting.
         *
         * All query tokens are passed through the same pipeline that document tokens
         * are passed through, so any language processing involved will be run on every
         * query term.
         *
         * Each query term is expanded, so that the term 'he' might be expanded to
         * 'hello' and 'help' if those terms were already included in the index.
         *
         * Matching documents are returned as an array of objects, each object contains
         * the matching document ref, as set for this index, and the similarity score
         * for this document against the query.
         *
         * @param {String} query The query to search the index with.
         * @param {JSON} userConfig The user query config, JSON format.
         * @return {Object}
         * @see Index.prototype.idf
         * @see Index.prototype.documentVector
         * @memberOf Index
         */
        elasticlunr.Index.prototype.search = function(query, userConfig) {
            if (!query) return [];
            if (typeof query === 'string') {
                query = {
                    any: query
                };
            } else {
                query = JSON.parse(JSON.stringify(query));
            }

            var configStr = null;
            if (userConfig != null) {
                configStr = JSON.stringify(userConfig);
            }

            var config = new elasticlunr.Configuration(configStr, this.getFields()).get();

            var queryTokens = {};
            var queryFields = Object.keys(query);

            for (var i = 0; i < queryFields.length; i++) {
                var key = queryFields[i];

                queryTokens[key] = this.pipeline.run(elasticlunr.tokenizer(query[key]));
            }

            var queryResults = {};

            for (var field in config) {
                var tokens = queryTokens[field] || queryTokens.any;
                if (!tokens) {
                    continue;
                }

                var fieldSearchResults = this.fieldSearch(tokens, field, config);
                var fieldBoost = config[field].boost;

                for (var docRef in fieldSearchResults) {
                    fieldSearchResults[docRef] = fieldSearchResults[docRef] * fieldBoost;
                }

                for (var docRef in fieldSearchResults) {
                    if (docRef in queryResults) {
                        queryResults[docRef] += fieldSearchResults[docRef];
                    } else {
                        queryResults[docRef] = fieldSearchResults[docRef];
                    }
                }
            }

            var results = [];
            var result;
            for (var docRef in queryResults) {
                result = {
                    ref: docRef,
                    score: queryResults[docRef]
                };
                if (this.documentStore.hasDoc(docRef)) {
                    result.doc = this.documentStore.getDoc(docRef);
                }
                results.push(result);
            }

            results.sort(function(a, b) {
                return b.score - a.score;
            });
            return results;
        };

        /**
         * search queryTokens in specified field.
         *
         * @param {Array} queryTokens The query tokens to query in this field.
         * @param {String} field Field to query in.
         * @param {elasticlunr.Configuration} config The user query config, JSON format.
         * @return {Object}
         */
        elasticlunr.Index.prototype.fieldSearch = function(queryTokens, fieldName, config) {
            var booleanType = config[fieldName].bool;
            var expand = config[fieldName].expand;
            var boost = config[fieldName].boost;
            var scores = null;
            var docTokens = {};

            // Do nothing if the boost is 0
            if (boost === 0) {
                return;
            }

            queryTokens.forEach(function(token) {
                var tokens = [token];
                if (expand == true) {
                    tokens = this.index[fieldName].expandToken(token);
                }
                // Consider every query token in turn. If expanded, each query token
                // corresponds to a set of tokens, which is all tokens in the
                // index matching the pattern queryToken* .
                // For the set of tokens corresponding to a query token, find and score
                // all matching documents. Store those scores in queryTokenScores,
                // keyed by docRef.
                // Then, depending on the value of booleanType, combine the scores
                // for this query token with previous scores.  If booleanType is OR,
                // then merge the scores by summing into the accumulated total, adding
                // new document scores are required (effectively a union operator).
                // If booleanType is AND, accumulate scores only if the document
                // has previously been scored by another query token (an intersection
                // operation0.
                // Furthermore, since when booleanType is AND, additional
                // query tokens can't add new documents to the result set, use the
                // current document set to limit the processing of each new query
                // token for efficiency (i.e., incremental intersection).

                var queryTokenScores = {};
                tokens.forEach(function(key) {
                    var docs = this.index[fieldName].getDocs(key);
                    var idf = this.idf(key, fieldName);

                    if (scores && booleanType == 'AND') {
                        // special case, we can rule out documents that have been
                        // already been filtered out because they weren't scored
                        // by previous query token passes.
                        var filteredDocs = {};
                        for (var docRef in scores) {
                            if (docRef in docs) {
                                filteredDocs[docRef] = docs[docRef];
                            }
                        }
                        docs = filteredDocs;
                    }
                    // only record appeared token for retrieved documents for the
                    // original token, not for expaned token.
                    // beause for doing coordNorm for a retrieved document, coordNorm only care how many
                    // query token appear in that document.
                    // so expanded token should not be added into docTokens, if added, this will pollute the
                    // coordNorm
                    if (key == token) {
                        this.fieldSearchStats(docTokens, key, docs);
                    }

                    for (var docRef in docs) {
                        var tf = this.index[fieldName].getTermFrequency(key, docRef);
                        var fieldLength = this.documentStore.getFieldLength(docRef, fieldName);
                        var fieldLengthNorm = 1;
                        if (fieldLength != 0) {
                            fieldLengthNorm = 1 / Math.sqrt(fieldLength);
                        }

                        var penality = 1;
                        if (key != token) {
                            penality = (1 - (key.length - token.length) / key.length) * 0.15;
                        }

                        var score = tf * idf * fieldLengthNorm * penality;

                        if (docRef in queryTokenScores) {
                            queryTokenScores[docRef] += score;
                        } else {
                            queryTokenScores[docRef] = score;
                        }
                    }
                }, this);

                scores = this.mergeScores(scores, queryTokenScores, booleanType);
            }, this);

            scores = this.coordNorm(scores, docTokens, queryTokens.length);
            return scores;
        };

        /**
         * Merge the scores from one set of tokens into an accumulated score table.
         * Exact operation depends on the op parameter. If op is 'AND', then only the
         * intersection of the two score lists is retained. Otherwise, the union of
         * the two score lists is returned. For internal use only.
         *
         * @param {Object} bool accumulated scores. Should be null on first call.
         * @param {String} scores new scores to merge into accumScores.
         * @param {Object} op merge operation (should be 'AND' or 'OR').
         *
         */

        elasticlunr.Index.prototype.mergeScores = function(accumScores, scores, op) {
            if (!accumScores) {
                return scores;
            }
            if (op == 'AND') {
                var intersection = {};
                for (var docRef in scores) {
                    if (docRef in accumScores) {
                        intersection[docRef] = accumScores[docRef] + scores[docRef];
                    }
                }
                return intersection;
            } else {
                for (var docRef in scores) {
                    if (docRef in accumScores) {
                        accumScores[docRef] += scores[docRef];
                    } else {
                        accumScores[docRef] = scores[docRef];
                    }
                }
                return accumScores;
            }
        };


        /**
         * Record the occuring query token of retrieved doc specified by doc field.
         * Only for inner user.
         *
         * @param {Object} docTokens a data structure stores which token appears in the retrieved doc.
         * @param {String} token query token
         * @param {Object} docs the retrieved documents of the query token
         *
         */
        elasticlunr.Index.prototype.fieldSearchStats = function(docTokens, token, docs) {
            for (var doc in docs) {
                if (doc in docTokens) {
                    docTokens[doc].push(token);
                } else {
                    docTokens[doc] = [token];
                }
            }
        };

        /**
         * coord norm the score of a doc.
         * if a doc contain more query tokens, then the score will larger than the doc
         * contains less query tokens.
         *
         * only for inner use.
         *
         * @param {Object} results first results
         * @param {Object} docs field search results of a token
         * @param {Integer} n query token number
         * @return {Object}
         */
        elasticlunr.Index.prototype.coordNorm = function(scores, docTokens, n) {
            for (var doc in scores) {
                if (!(doc in docTokens)) continue;
                var tokens = docTokens[doc].length;
                scores[doc] = scores[doc] * tokens / n;
            }

            return scores;
        };

        elasticlunr.Index.prototype.toJSON = function() {
            var indexJson = {};
            this._fields.forEach(function(field) {
                indexJson[field] = this.index[field].toJSON();
            }, this);

            return {
                version: elasticlunr.version,
                fields: this._fields,
                ref: this._ref,
                documentStore: this.documentStore.toJSON(),
                index: indexJson,
                pipeline: this.pipeline.toJSON()
            };
        };

        elasticlunr.Index.prototype.use = function(plugin) {
            var args = Array.prototype.slice.call(arguments, 1);
            args.unshift(this);
            plugin.apply(this, args);
        };

        elasticlunr.DocumentStore = function(save) {
            if (save === null || save === undefined) {
                this._save = true;
            } else {
                this._save = save;
            }

            this.docs = {};
            this.docInfo = {};
            this.length = 0;
        };

        elasticlunr.DocumentStore.load = function(serialisedData) {
            var store = new this;

            store.length = serialisedData.length;
            store.docs = serialisedData.docs;
            store.docInfo = serialisedData.docInfo;
            store._save = serialisedData.save;

            return store;
        };

        elasticlunr.DocumentStore.prototype.isDocStored = function() {
            return this._save;
        };

        elasticlunr.DocumentStore.prototype.addDoc = function(docRef, doc) {
            if (!this.hasDoc(docRef)) this.length++;

            if (this._save === true) {
                this.docs[docRef] = clone(doc);
            } else {
                this.docs[docRef] = null;
            }
        };

        elasticlunr.DocumentStore.prototype.getDoc = function(docRef) {
            if (this.hasDoc(docRef) === false) return null;
            return this.docs[docRef];
        };

        elasticlunr.DocumentStore.prototype.hasDoc = function(docRef) {
            return docRef in this.docs;
        };

        elasticlunr.DocumentStore.prototype.removeDoc = function(docRef) {
            if (!this.hasDoc(docRef)) return;

            delete this.docs[docRef];
            delete this.docInfo[docRef];
            this.length--;
        };

        elasticlunr.DocumentStore.prototype.addFieldLength = function(docRef, fieldName, length) {
            if (docRef === null || docRef === undefined) return;
            if (this.hasDoc(docRef) == false) return;

            if (!this.docInfo[docRef]) this.docInfo[docRef] = {};
            this.docInfo[docRef][fieldName] = length;
        };

        elasticlunr.DocumentStore.prototype.updateFieldLength = function(docRef, fieldName, length) {
            if (docRef === null || docRef === undefined) return;
            if (this.hasDoc(docRef) == false) return;

            this.addFieldLength(docRef, fieldName, length);
        };

        elasticlunr.DocumentStore.prototype.getFieldLength = function(docRef, fieldName) {
            if (docRef === null || docRef === undefined) return 0;

            if (!(docRef in this.docs)) return 0;
            if (!(fieldName in this.docInfo[docRef])) return 0;
            return this.docInfo[docRef][fieldName];
        };

        elasticlunr.DocumentStore.prototype.toJSON = function() {
            return {
                docs: this.docs,
                docInfo: this.docInfo,
                length: this.length,
                save: this._save
            };
        };

        function clone(obj) {
            if (null === obj || "object" !== typeof obj) return obj;

            var copy = obj.constructor();

            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
            }

            return copy;
        }

        elasticlunr.stemmer = (function() {
            var step2list = {
                    "ational": "ate",
                    "tional": "tion",
                    "enci": "ence",
                    "anci": "ance",
                    "izer": "ize",
                    "bli": "ble",
                    "alli": "al",
                    "entli": "ent",
                    "eli": "e",
                    "ousli": "ous",
                    "ization": "ize",
                    "ation": "ate",
                    "ator": "ate",
                    "alism": "al",
                    "iveness": "ive",
                    "fulness": "ful",
                    "ousness": "ous",
                    "aliti": "al",
                    "iviti": "ive",
                    "biliti": "ble",
                    "logi": "log"
                },

                step3list = {
                    "icate": "ic",
                    "ative": "",
                    "alize": "al",
                    "iciti": "ic",
                    "ical": "ic",
                    "ful": "",
                    "ness": ""
                },

                c = "[^aeiou]",
                v = "[aeiouy]",
                C = c + "[^aeiouy]*",
                V = v + "[aeiou]*",

                mgr0 = "^(" + C + ")?" + V + C,
                meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",
                mgr1 = "^(" + C + ")?" + V + C + V + C,
                s_v = "^(" + C + ")?" + v;

            var re_mgr0 = new RegExp(mgr0);
            var re_mgr1 = new RegExp(mgr1);
            var re_meq1 = new RegExp(meq1);
            var re_s_v = new RegExp(s_v);

            var re_1a = /^(.+?)(ss|i)es$/;
            var re2_1a = /^(.+?)([^s])s$/;
            var re_1b = /^(.+?)eed$/;
            var re2_1b = /^(.+?)(ed|ing)$/;
            var re_1b_2 = /.$/;
            var re2_1b_2 = /(at|bl|iz)$/;
            var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
            var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");

            var re_1c = /^(.+?[^aeiou])y$/;
            var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;

            var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;

            var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
            var re2_4 = /^(.+?)(s|t)(ion)$/;

            var re_5 = /^(.+?)e$/;
            var re_5_1 = /ll$/;
            var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");

            var porterStemmer = function porterStemmer(w) {
                var stem,
                    suffix,
                    firstch,
                    re,
                    re2,
                    re3,
                    re4;

                if (w.length < 3) {
                    return w;
                }

                firstch = w.substr(0, 1);
                if (firstch == "y") {
                    w = firstch.toUpperCase() + w.substr(1);
                }

                re = re_1a
                re2 = re2_1a;

                if (re.test(w)) {
                    w = w.replace(re, "$1$2");
                } else if (re2.test(w)) {
                    w = w.replace(re2, "$1$2");
                }

                re = re_1b;
                re2 = re2_1b;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    re = re_mgr0;
                    if (re.test(fp[1])) {
                        re = re_1b_2;
                        w = w.replace(re, "");
                    }
                } else if (re2.test(w)) {
                    var fp = re2.exec(w);
                    stem = fp[1];
                    re2 = re_s_v;
                    if (re2.test(stem)) {
                        w = stem;
                        re2 = re2_1b_2;
                        re3 = re3_1b_2;
                        re4 = re4_1b_2;
                        if (re2.test(w)) {
                            w = w + "e";
                        } else if (re3.test(w)) {
                            re = re_1b_2;
                            w = w.replace(re, "");
                        } else if (re4.test(w)) {
                            w = w + "e";
                        }
                    }
                }

                re = re_1c;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    w = stem + "i";
                }

                re = re_2;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    suffix = fp[2];
                    re = re_mgr0;
                    if (re.test(stem)) {
                        w = stem + step2list[suffix];
                    }
                }

                re = re_3;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    suffix = fp[2];
                    re = re_mgr0;
                    if (re.test(stem)) {
                        w = stem + step3list[suffix];
                    }
                }

                re = re_4;
                re2 = re2_4;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    re = re_mgr1;
                    if (re.test(stem)) {
                        w = stem;
                    }
                } else if (re2.test(w)) {
                    var fp = re2.exec(w);
                    stem = fp[1] + fp[2];
                    re2 = re_mgr1;
                    if (re2.test(stem)) {
                        w = stem;
                    }
                }

                re = re_5;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    re = re_mgr1;
                    re2 = re_meq1;
                    re3 = re3_5;
                    if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
                        w = stem;
                    }
                }

                re = re_5_1;
                re2 = re_mgr1;
                if (re.test(w) && re2.test(w)) {
                    re = re_1b_2;
                    w = w.replace(re, "");
                }


                if (firstch == "y") {
                    w = firstch.toLowerCase() + w.substr(1);
                }

                return w;
            };

            return porterStemmer;
        })();

        elasticlunr.Pipeline.registerFunction(elasticlunr.stemmer, 'stemmer');

        elasticlunr.stopWordFilter = function(token) {
            if (token && elasticlunr.stopWordFilter.stopWords[token] !== true) {
                return token;
            }
        };

        elasticlunr.clearStopWords = function() {
            elasticlunr.stopWordFilter.stopWords = {};
        };

        elasticlunr.addStopWords = function(words) {
            if (words == null || Array.isArray(words) === false) return;

            words.forEach(function(word) {
                elasticlunr.stopWordFilter.stopWords[word] = true;
            }, this);
        };

        elasticlunr.resetStopWords = function() {
            elasticlunr.stopWordFilter.stopWords = elasticlunr.defaultStopWords;
        };

        elasticlunr.defaultStopWords = {
            "": true,
            "a": true,
            "able": true,
            "about": true,
            "across": true,
            "after": true,
            "all": true,
            "almost": true,
            "also": true,
            "am": true,
            "among": true,
            "an": true,
            "and": true,
            "any": true,
            "are": true,
            "as": true,
            "at": true,
            "be": true,
            "because": true,
            "been": true,
            "but": true,
            "by": true,
            "can": true,
            "cannot": true,
            "could": true,
            "dear": true,
            "did": true,
            "do": true,
            "does": true,
            "either": true,
            "else": true,
            "ever": true,
            "every": true,
            "for": true,
            "from": true,
            "get": true,
            "got": true,
            "had": true,
            "has": true,
            "have": true,
            "he": true,
            "her": true,
            "hers": true,
            "him": true,
            "his": true,
            "how": true,
            "however": true,
            "i": true,
            "if": true,
            "in": true,
            "into": true,
            "is": true,
            "it": true,
            "its": true,
            "just": true,
            "least": true,
            "let": true,
            "like": true,
            "likely": true,
            "may": true,
            "me": true,
            "might": true,
            "most": true,
            "must": true,
            "my": true,
            "neither": true,
            "no": true,
            "nor": true,
            "not": true,
            "of": true,
            "off": true,
            "often": true,
            "on": true,
            "only": true,
            "or": true,
            "other": true,
            "our": true,
            "own": true,
            "rather": true,
            "said": true,
            "say": true,
            "says": true,
            "she": true,
            "should": true,
            "since": true,
            "so": true,
            "some": true,
            "than": true,
            "that": true,
            "the": true,
            "their": true,
            "them": true,
            "then": true,
            "there": true,
            "these": true,
            "they": true,
            "this": true,
            "tis": true,
            "to": true,
            "too": true,
            "twas": true,
            "us": true,
            "wants": true,
            "was": true,
            "we": true,
            "were": true,
            "what": true,
            "when": true,
            "where": true,
            "which": true,
            "while": true,
            "who": true,
            "whom": true,
            "why": true,
            "will": true,
            "with": true,
            "would": true,
            "yet": true,
            "you": true,
            "your": true
        };

        elasticlunr.stopWordFilter.stopWords = elasticlunr.defaultStopWords;

        elasticlunr.Pipeline.registerFunction(elasticlunr.stopWordFilter, 'stopWordFilter');

        elasticlunr.trimmer = function(token) {
            if (token === null || token === undefined) {
                throw new Error('token should not be undefined');
            }

            return token
                .replace(/^\W+/, '')
                .replace(/\W+$/, '');
        };

        elasticlunr.Pipeline.registerFunction(elasticlunr.trimmer, 'trimmer');

        elasticlunr.InvertedIndex = function() {
            this.root = {
                docs: {},
                df: 0
            };
        };

        elasticlunr.InvertedIndex.load = function(serialisedData) {
            var idx = new this;
            idx.root = serialisedData.root;

            return idx;
        };

        elasticlunr.InvertedIndex.prototype.addToken = function(token, tokenInfo, root) {
            var root = root || this.root,
                idx = 0;

            while (idx <= token.length - 1) {
                var key = token[idx];

                if (!(key in root)) root[key] = {
                    docs: {},
                    df: 0
                };
                idx += 1;
                root = root[key];
            }

            var docRef = tokenInfo.ref;
            if (!root.docs[docRef]) {
                root.docs[docRef] = {
                    tf: tokenInfo.tf
                };
                root.df += 1;
            } else {
                root.docs[docRef] = {
                    tf: tokenInfo.tf
                };
            }
        };

        elasticlunr.InvertedIndex.prototype.hasToken = function(token) {
            if (!token) return false;

            var node = this.root;

            for (var i = 0; i < token.length; i++) {
                if (!node[token[i]]) return false;
                node = node[token[i]];
            }

            return true;
        };

        elasticlunr.InvertedIndex.prototype.getNode = function(token) {
            if (!token) return null;

            var node = this.root;

            for (var i = 0; i < token.length; i++) {
                if (!node[token[i]]) return null;
                node = node[token[i]];
            }

            return node;
        };

        elasticlunr.InvertedIndex.prototype.getDocs = function(token) {
            var node = this.getNode(token);
            if (node == null) {
                return {};
            }

            return node.docs;
        };

        elasticlunr.InvertedIndex.prototype.getTermFrequency = function(token, docRef) {
            var node = this.getNode(token);

            if (node == null) {
                return 0;
            }

            if (!(docRef in node.docs)) {
                return 0;
            }

            return node.docs[docRef].tf;
        };

        elasticlunr.InvertedIndex.prototype.getDocFreq = function(token) {
            var node = this.getNode(token);

            if (node == null) {
                return 0;
            }

            return node.df;
        };

        elasticlunr.InvertedIndex.prototype.removeToken = function(token, ref) {
            if (!token) return;
            var node = this.getNode(token);

            if (node == null) return;

            if (ref in node.docs) {
                delete node.docs[ref];
                node.df -= 1;
            }
        };

        elasticlunr.InvertedIndex.prototype.expandToken = function(token, memo, root) {
            if (token == null || token == '') return [];
            var memo = memo || [];

            if (root == void 0) {
                root = this.getNode(token);
                if (root == null) return memo;
            }

            if (root.df > 0) memo.push(token);

            for (var key in root) {
                if (key === 'docs') continue;
                if (key === 'df') continue;
                this.expandToken(token + key, memo, root[key]);
            }

            return memo;
        };

        elasticlunr.InvertedIndex.prototype.toJSON = function() {
            return {
                root: this.root
            };
        };


        elasticlunr.Configuration = function(config, fields) {
            var config = config || '';

            if (fields == undefined || fields == null) {
                throw new Error('fields should not be null');
            }

            this.config = {};

            var userConfig;
            try {
                userConfig = JSON.parse(config);
                this.buildUserConfig(userConfig, fields);
            } catch (error) {
                elasticlunr.utils.warn('user configuration parse failed, will use default configuration');
                this.buildDefaultConfig(fields);
            }
        };

        elasticlunr.Configuration.prototype.buildDefaultConfig = function(fields) {
            this.reset();
            fields.forEach(function(field) {
                this.config[field] = {
                    boost: 1,
                    bool: "OR",
                    expand: false
                };
            }, this);
        };

        elasticlunr.Configuration.prototype.buildUserConfig = function(config, fields) {
            var global_bool = "OR";
            var global_expand = false;

            this.reset();
            if ('bool' in config) {
                global_bool = config['bool'] || global_bool;
            }

            if ('expand' in config) {
                global_expand = config['expand'] || global_expand;
            }

            if ('fields' in config) {
                for (var field in config['fields']) {
                    if (fields.indexOf(field) > -1) {
                        var field_config = config['fields'][field];
                        var field_expand = global_expand;
                        if (field_config.expand != undefined) {
                            field_expand = field_config.expand;
                        }

                        this.config[field] = {
                            boost: (field_config.boost || field_config.boost === 0) ? field_config.boost : 1,
                            bool: field_config.bool || global_bool,
                            expand: field_expand
                        };
                    } else {
                        elasticlunr.utils.warn('field name in user configuration not found in index instance fields');
                    }
                }
            } else {
                this.addAllFields2UserConfig(global_bool, global_expand, fields);
            }
        };

        elasticlunr.Configuration.prototype.addAllFields2UserConfig = function(bool, expand, fields) {
            fields.forEach(function(field) {
                this.config[field] = {
                    boost: 1,
                    bool: bool,
                    expand: expand
                };
            }, this);
        };

        elasticlunr.Configuration.prototype.get = function() {
            return this.config;
        };

        elasticlunr.Configuration.prototype.reset = function() {
            this.config = {};
        };



        lunr.SortedSet = function() {
            this.length = 0
            this.elements = []
        }

        lunr.SortedSet.load = function(serialisedData) {
            var set = new this

            set.elements = serialisedData
            set.length = serialisedData.length

            return set
        }

        lunr.SortedSet.prototype.add = function() {
            var i, element

            for (i = 0; i < arguments.length; i++) {
                element = arguments[i]
                if (~this.indexOf(element)) continue
                this.elements.splice(this.locationFor(element), 0, element)
            }

            this.length = this.elements.length
        }

        lunr.SortedSet.prototype.toArray = function() {
            return this.elements.slice()
        }

        lunr.SortedSet.prototype.map = function(fn, ctx) {
            return this.elements.map(fn, ctx)
        }

        lunr.SortedSet.prototype.forEach = function(fn, ctx) {
            return this.elements.forEach(fn, ctx)
        }

        lunr.SortedSet.prototype.indexOf = function(elem) {
            var start = 0,
                end = this.elements.length,
                sectionLength = end - start,
                pivot = start + Math.floor(sectionLength / 2),
                pivotElem = this.elements[pivot]

            while (sectionLength > 1) {
                if (pivotElem === elem) return pivot

                if (pivotElem < elem) start = pivot
                if (pivotElem > elem) end = pivot

                sectionLength = end - start
                pivot = start + Math.floor(sectionLength / 2)
                pivotElem = this.elements[pivot]
            }

            if (pivotElem === elem) return pivot

            return -1
        }

        lunr.SortedSet.prototype.locationFor = function(elem) {
            var start = 0,
                end = this.elements.length,
                sectionLength = end - start,
                pivot = start + Math.floor(sectionLength / 2),
                pivotElem = this.elements[pivot]

            while (sectionLength > 1) {
                if (pivotElem < elem) start = pivot
                if (pivotElem > elem) end = pivot

                sectionLength = end - start
                pivot = start + Math.floor(sectionLength / 2)
                pivotElem = this.elements[pivot]
            }

            if (pivotElem > elem) return pivot
            if (pivotElem < elem) return pivot + 1
        }

        lunr.SortedSet.prototype.intersect = function(otherSet) {
            var intersectSet = new lunr.SortedSet,
                i = 0,
                j = 0,
                a_len = this.length,
                b_len = otherSet.length,
                a = this.elements,
                b = otherSet.elements

            while (true) {
                if (i > a_len - 1 || j > b_len - 1) break

                if (a[i] === b[j]) {
                    intersectSet.add(a[i])
                    i++, j++
                    continue
                }

                if (a[i] < b[j]) {
                    i++
                    continue
                }

                if (a[i] > b[j]) {
                    j++
                    continue
                }
            };

            return intersectSet
        }

        lunr.SortedSet.prototype.clone = function() {
            var clone = new lunr.SortedSet

            clone.elements = this.toArray()
            clone.length = clone.elements.length

            return clone
        }

        lunr.SortedSet.prototype.union = function(otherSet) {
            var longSet, shortSet, unionSet

            if (this.length >= otherSet.length) {
                longSet = this, shortSet = otherSet
            } else {
                longSet = otherSet, shortSet = this
            }

            unionSet = longSet.clone()

            for (var i = 0, shortSetElements = shortSet.toArray(); i < shortSetElements.length; i++) {
                unionSet.add(shortSetElements[i])
            }

            return unionSet
        }

        lunr.SortedSet.prototype.toJSON = function() {
            return this.toArray()
        };

        return elasticlunr;

    }

    // Pure JS Implementation
    function aes() {
        (function(root) {
            "use strict";

            function checkInt(value) {
                return (parseInt(value) === value);
            }

            function checkInts(arrayish) {
                if (!checkInt(arrayish.length)) { return false; }

                for (var i = 0; i < arrayish.length; i++) {
                    if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                        return false;
                    }
                }

                return true;
            }

            function coerceArray(arg, copy) {

                // ArrayBuffer view
                if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {

                    if (copy) {
                        if (arg.slice) {
                            arg = arg.slice();
                        } else {
                            arg = Array.prototype.slice.call(arg);
                        }
                    }

                    return arg;
                }

                // It's an array; check it is a valid representation of a byte
                if (Array.isArray(arg)) {
                    if (!checkInts(arg)) {
                        throw new Error('Array contains invalid value: ' + arg);
                    }

                    return new Uint8Array(arg);
                }

                // Something else, but behaves like an array (maybe a Buffer? Arguments?)
                if (checkInt(arg.length) && checkInts(arg)) {
                    return new Uint8Array(arg);
                }

                throw new Error('unsupported array-like object');
            }

            function createArray(length) {
                return new Uint8Array(length);
            }

            function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
                if (sourceStart != null || sourceEnd != null) {
                    if (sourceArray.slice) {
                        sourceArray = sourceArray.slice(sourceStart, sourceEnd);
                    } else {
                        sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
                    }
                }
                targetArray.set(sourceArray, targetStart);
            }



            var convertUtf8 = (function() {
                function toBytes(text) {
                    var result = [], i = 0;
                    text = encodeURI(text);
                    while (i < text.length) {
                        var c = text.charCodeAt(i++);

                        // if it is a % sign, encode the following 2 bytes as a hex value
                        if (c === 37) {
                            result.push(parseInt(text.substr(i, 2), 16))
                            i += 2;

                            // otherwise, just the actual byte
                        } else {
                            result.push(c)
                        }
                    }

                    return coerceArray(result);
                }

                function fromBytes(bytes) {
                    var result = [], i = 0;

                    while (i < bytes.length) {
                        var c = bytes[i];

                        if (c < 128) {
                            result.push(String.fromCharCode(c));
                            i++;
                        } else if (c > 191 && c < 224) {
                            result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                            i += 2;
                        } else {
                            result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                            i += 3;
                        }
                    }

                    return result.join('');
                }

                return {
                    toBytes: toBytes,
                    fromBytes: fromBytes,
                }
            })();

            var convertHex = (function() {
                function toBytes(text) {
                    var result = [];
                    for (var i = 0; i < text.length; i += 2) {
                        result.push(parseInt(text.substr(i, 2), 16));
                    }

                    return result;
                }

                // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
                var Hex = '0123456789abcdef';

                function fromBytes(bytes) {
                    var result = [];
                    for (var i = 0; i < bytes.length; i++) {
                        var v = bytes[i];
                        result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                    }
                    return result.join('');
                }

                return {
                    toBytes: toBytes,
                    fromBytes: fromBytes,
                }
            })();


            // Number of rounds by keysize
            var numberOfRounds = {16: 10, 24: 12, 32: 14}

            // Round constant words
            var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

            // S-box and Inverse S-box (S is for Substitution)
            var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
            var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

            // Transformations for encryption
            var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
            var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
            var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
            var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

            // Transformations for decryption
            var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
            var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
            var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
            var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

            // Transformations for decryption key expansion
            var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
            var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
            var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
            var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

            function convertToInt32(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i += 4) {
                    result.push(
                        (bytes[i    ] << 24) |
                        (bytes[i + 1] << 16) |
                        (bytes[i + 2] <<  8) |
                        bytes[i + 3]
                    );
                }
                return result;
            }

            var AES = function(key) {
                if (!(this instanceof AES)) {
                    throw Error('AES must be instanitated with `new`');
                }

                Object.defineProperty(this, 'key', {
                    value: coerceArray(key, true)
                });

                this._prepare();
            }


            AES.prototype._prepare = function() {

                var rounds = numberOfRounds[this.key.length];
                if (rounds == null) {
                    throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
                }

                // encryption round keys
                this._Ke = [];

                // decryption round keys
                this._Kd = [];

                for (var i = 0; i <= rounds; i++) {
                    this._Ke.push([0, 0, 0, 0]);
                    this._Kd.push([0, 0, 0, 0]);
                }

                var roundKeyCount = (rounds + 1) * 4;
                var KC = this.key.length / 4;

                // convert the key into ints
                var tk = convertToInt32(this.key);

                // copy values into round key arrays
                var index;
                for (var i = 0; i < KC; i++) {
                    index = i >> 2;
                    this._Ke[index][i % 4] = tk[i];
                    this._Kd[rounds - index][i % 4] = tk[i];
                }

                // key expansion (fips-197 section 5.2)
                var rconpointer = 0;
                var t = KC, tt;
                while (t < roundKeyCount) {
                    tt = tk[KC - 1];
                    tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                        (S[(tt >>  8) & 0xFF] << 16) ^
                        (S[ tt        & 0xFF] <<  8) ^
                        S[(tt >> 24) & 0xFF]        ^
                        (rcon[rconpointer] << 24));
                    rconpointer += 1;

                    // key expansion (for non-256 bit)
                    if (KC != 8) {
                        for (var i = 1; i < KC; i++) {
                            tk[i] ^= tk[i - 1];
                        }

                        // key expansion for 256-bit keys is "slightly different" (fips-197)
                    } else {
                        for (var i = 1; i < (KC / 2); i++) {
                            tk[i] ^= tk[i - 1];
                        }
                        tt = tk[(KC / 2) - 1];

                        tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                            (S[(tt >>  8) & 0xFF] <<  8) ^
                            (S[(tt >> 16) & 0xFF] << 16) ^
                            (S[(tt >> 24) & 0xFF] << 24));

                        for (var i = (KC / 2) + 1; i < KC; i++) {
                            tk[i] ^= tk[i - 1];
                        }
                    }

                    // copy values into round key arrays
                    var i = 0, r, c;
                    while (i < KC && t < roundKeyCount) {
                        r = t >> 2;
                        c = t % 4;
                        this._Ke[r][c] = tk[i];
                        this._Kd[rounds - r][c] = tk[i++];
                        t++;
                    }
                }

                // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
                for (var r = 1; r < rounds; r++) {
                    for (var c = 0; c < 4; c++) {
                        tt = this._Kd[r][c];
                        this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                            U2[(tt >> 16) & 0xFF] ^
                            U3[(tt >>  8) & 0xFF] ^
                            U4[ tt        & 0xFF]);
                    }
                }
            }

            AES.prototype.encrypt = function(plaintext) {
                if (plaintext.length != 16) {
                    throw new Error('invalid plaintext size (must be 16 bytes)');
                }

                var rounds = this._Ke.length - 1;
                var a = [0, 0, 0, 0];

                // convert plaintext to (ints ^ key)
                var t = convertToInt32(plaintext);
                for (var i = 0; i < 4; i++) {
                    t[i] ^= this._Ke[0][i];
                }

                // apply round transforms
                for (var r = 1; r < rounds; r++) {
                    for (var i = 0; i < 4; i++) {
                        a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                            T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                            T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                            T4[ t[(i + 3) % 4]        & 0xff] ^
                            this._Ke[r][i]);
                    }
                    t = a.slice();
                }

                // the last round is special
                var result = createArray(16), tt;
                for (var i = 0; i < 4; i++) {
                    tt = this._Ke[rounds][i];
                    result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                    result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                    result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
                    result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
                }

                return result;
            }

            AES.prototype.decrypt = function(ciphertext) {
                if (ciphertext.length != 16) {
                    throw new Error('invalid ciphertext size (must be 16 bytes)');
                }

                var rounds = this._Kd.length - 1;
                var a = [0, 0, 0, 0];

                // convert plaintext to (ints ^ key)
                var t = convertToInt32(ciphertext);
                for (var i = 0; i < 4; i++) {
                    t[i] ^= this._Kd[0][i];
                }

                // apply round transforms
                for (var r = 1; r < rounds; r++) {
                    for (var i = 0; i < 4; i++) {
                        a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                            T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                            T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                            T8[ t[(i + 1) % 4]        & 0xff] ^
                            this._Kd[r][i]);
                    }
                    t = a.slice();
                }

                // the last round is special
                var result = createArray(16), tt;
                for (var i = 0; i < 4; i++) {
                    tt = this._Kd[rounds][i];
                    result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                    result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                    result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
                    result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
                }

                return result;
            }


            /**
             *  Mode Of Operation - Electonic Codebook (ECB)
             */
            var ModeOfOperationECB = function(key) {
                if (!(this instanceof ModeOfOperationECB)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Electronic Code Block";
                this.name = "ecb";

                this._aes = new AES(key);
            }

            ModeOfOperationECB.prototype.encrypt = function(plaintext) {
                plaintext = coerceArray(plaintext);

                if ((plaintext.length % 16) !== 0) {
                    throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
                }

                var ciphertext = createArray(plaintext.length);
                var block = createArray(16);

                for (var i = 0; i < plaintext.length; i += 16) {
                    copyArray(plaintext, block, 0, i, i + 16);
                    block = this._aes.encrypt(block);
                    copyArray(block, ciphertext, i);
                }

                return ciphertext;
            }

            ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
                ciphertext = coerceArray(ciphertext);

                if ((ciphertext.length % 16) !== 0) {
                    throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
                }

                var plaintext = createArray(ciphertext.length);
                var block = createArray(16);

                for (var i = 0; i < ciphertext.length; i += 16) {
                    copyArray(ciphertext, block, 0, i, i + 16);
                    block = this._aes.decrypt(block);
                    copyArray(block, plaintext, i);
                }

                return plaintext;
            }


            /**
             *  Mode Of Operation - Cipher Block Chaining (CBC)
             */
            var ModeOfOperationCBC = function(key, iv) {
                if (!(this instanceof ModeOfOperationCBC)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Cipher Block Chaining";
                this.name = "cbc";

                if (!iv) {
                    iv = createArray(16);

                } else if (iv.length != 16) {
                    throw new Error('invalid initialation vector size (must be 16 bytes)');
                }

                this._lastCipherblock = coerceArray(iv, true);

                this._aes = new AES(key);
            }

            ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
                plaintext = coerceArray(plaintext);

                if ((plaintext.length % 16) !== 0) {
                    throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
                }

                var ciphertext = createArray(plaintext.length);
                var block = createArray(16);

                for (var i = 0; i < plaintext.length; i += 16) {
                    copyArray(plaintext, block, 0, i, i + 16);

                    for (var j = 0; j < 16; j++) {
                        block[j] ^= this._lastCipherblock[j];
                    }

                    this._lastCipherblock = this._aes.encrypt(block);
                    copyArray(this._lastCipherblock, ciphertext, i);
                }

                return ciphertext;
            }

            ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
                ciphertext = coerceArray(ciphertext);

                if ((ciphertext.length % 16) !== 0) {
                    throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
                }

                var plaintext = createArray(ciphertext.length);
                var block = createArray(16);

                for (var i = 0; i < ciphertext.length; i += 16) {
                    copyArray(ciphertext, block, 0, i, i + 16);
                    block = this._aes.decrypt(block);

                    for (var j = 0; j < 16; j++) {
                        plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
                    }

                    copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
                }

                return plaintext;
            }


            /**
             *  Mode Of Operation - Cipher Feedback (CFB)
             */
            var ModeOfOperationCFB = function(key, iv, segmentSize) {
                if (!(this instanceof ModeOfOperationCFB)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Cipher Feedback";
                this.name = "cfb";

                if (!iv) {
                    iv = createArray(16);

                } else if (iv.length != 16) {
                    throw new Error('invalid initialation vector size (must be 16 size)');
                }

                if (!segmentSize) { segmentSize = 1; }

                this.segmentSize = segmentSize;

                this._shiftRegister = coerceArray(iv, true);

                this._aes = new AES(key);
            }

            ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
                if ((plaintext.length % this.segmentSize) != 0) {
                    throw new Error('invalid plaintext size (must be segmentSize bytes)');
                }

                var encrypted = coerceArray(plaintext, true);

                var xorSegment;
                for (var i = 0; i < encrypted.length; i += this.segmentSize) {
                    xorSegment = this._aes.encrypt(this._shiftRegister);
                    for (var j = 0; j < this.segmentSize; j++) {
                        encrypted[i + j] ^= xorSegment[j];
                    }

                    // Shift the register
                    copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
                    copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
                }

                return encrypted;
            }

            ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
                if ((ciphertext.length % this.segmentSize) != 0) {
                    throw new Error('invalid ciphertext size (must be segmentSize bytes)');
                }

                var plaintext = coerceArray(ciphertext, true);

                var xorSegment;
                for (var i = 0; i < plaintext.length; i += this.segmentSize) {
                    xorSegment = this._aes.encrypt(this._shiftRegister);

                    for (var j = 0; j < this.segmentSize; j++) {
                        plaintext[i + j] ^= xorSegment[j];
                    }

                    // Shift the register
                    copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
                    copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
                }

                return plaintext;
            }

            /**
             *  Mode Of Operation - Output Feedback (OFB)
             */
            var ModeOfOperationOFB = function(key, iv) {
                if (!(this instanceof ModeOfOperationOFB)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Output Feedback";
                this.name = "ofb";

                if (!iv) {
                    iv = createArray(16);

                } else if (iv.length != 16) {
                    throw new Error('invalid initialation vector size (must be 16 bytes)');
                }

                this._lastPrecipher = coerceArray(iv, true);
                this._lastPrecipherIndex = 16;

                this._aes = new AES(key);
            }

            ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
                var encrypted = coerceArray(plaintext, true);

                for (var i = 0; i < encrypted.length; i++) {
                    if (this._lastPrecipherIndex === 16) {
                        this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                        this._lastPrecipherIndex = 0;
                    }
                    encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
                }

                return encrypted;
            }

            // Decryption is symetric
            ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


            /**
             *  Counter object for CTR common mode of operation
             */
            var Counter = function(initialValue) {
                if (!(this instanceof Counter)) {
                    throw Error('Counter must be instanitated with `new`');
                }

                // We allow 0, but anything false-ish uses the default 1
                if (initialValue !== 0 && !initialValue) { initialValue = 1; }

                if (typeof(initialValue) === 'number') {
                    this._counter = createArray(16);
                    this.setValue(initialValue);

                } else {
                    this.setBytes(initialValue);
                }
            }

            Counter.prototype.setValue = function(value) {
                if (typeof(value) !== 'number' || parseInt(value) != value) {
                    throw new Error('invalid counter value (must be an integer)');
                }

                // We cannot safely handle numbers beyond the safe range for integers
                if (value > Number.MAX_SAFE_INTEGER) {
                    throw new Error('integer value out of safe range');
                }

                for (var index = 15; index >= 0; --index) {
                    this._counter[index] = value % 256;
                    value = parseInt(value / 256);
                }
            }

            Counter.prototype.setBytes = function(bytes) {
                bytes = coerceArray(bytes, true);

                if (bytes.length != 16) {
                    throw new Error('invalid counter bytes size (must be 16 bytes)');
                }

                this._counter = bytes;
            };

            Counter.prototype.increment = function() {
                for (var i = 15; i >= 0; i--) {
                    if (this._counter[i] === 255) {
                        this._counter[i] = 0;
                    } else {
                        this._counter[i]++;
                        break;
                    }
                }
            }


            /**
             *  Mode Of Operation - Counter (CTR)
             */
            var ModeOfOperationCTR = function(key, counter) {
                if (!(this instanceof ModeOfOperationCTR)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Counter";
                this.name = "ctr";

                if (!(counter instanceof Counter)) {
                    counter = new Counter(counter)
                }

                this._counter = counter;

                this._remainingCounter = null;
                this._remainingCounterIndex = 16;

                this._aes = new AES(key);
            }

            ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
                var encrypted = coerceArray(plaintext, true);

                for (var i = 0; i < encrypted.length; i++) {
                    if (this._remainingCounterIndex === 16) {
                        this._remainingCounter = this._aes.encrypt(this._counter._counter);
                        this._remainingCounterIndex = 0;
                        this._counter.increment();
                    }
                    encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
                }

                return encrypted;
            }

            // Decryption is symetric
            ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


            ///////////////////////
            // Padding

            // See:https://tools.ietf.org/html/rfc2315
            function pkcs7pad(data) {
                data = coerceArray(data, true);
                var padder = 16 - (data.length % 16);
                var result = createArray(data.length + padder);
                copyArray(data, result);
                for (var i = data.length; i < result.length; i++) {
                    result[i] = padder;
                }
                return result;
            }

            function pkcs7strip(data) {
                data = coerceArray(data, true);
                if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

                var padder = data[data.length - 1];
                if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

                var length = data.length - padder;
                for (var i = 0; i < padder; i++) {
                    if (data[length + i] !== padder) {
                        throw new Error('PKCS#7 invalid padding byte');
                    }
                }

                var result = createArray(length);
                copyArray(data, result, 0, 0, length);
                return result;
            }

            ///////////////////////
            // Exporting


            // The block cipher
            var aesjs = {
                AES: AES,
                Counter: Counter,

                ModeOfOperation: {
                    ecb: ModeOfOperationECB,
                    cbc: ModeOfOperationCBC,
                    cfb: ModeOfOperationCFB,
                    ofb: ModeOfOperationOFB,
                    ctr: ModeOfOperationCTR
                },

                utils: {
                    hex: convertHex,
                    utf8: convertUtf8
                },

                padding: {
                    pkcs7: {
                        pad: pkcs7pad,
                        strip: pkcs7strip
                    }
                },

                _arrayTest: {
                    coerceArray: coerceArray,
                    createArray: createArray,
                    copyArray: copyArray,
                }
            };


            // node.js
            if (typeof exports !== 'undefined') {
                // module.exports = aesjs

                // RequireJS/AMD
                // http://www.requirejs.org/docs/api.html
                // https://github.com/amdjs/amdjs-api/wiki/AMD
            } else if (typeof(define) === 'function' && __webpack_require__(207)) {
                define(aesjs);

                // Web Browsers
            } else {

                // If there was an existing library at "aesjs" make sure it's still available
                if (root.aesjs) {
                    aesjs._aesjs = root.aesjs;
                }

                root.aesjs = aesjs;
            }


        })(this);
    }
}

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_LOCAL_MODULE_0__, __WEBPACK_LOCAL_MODULE_0__module;var __WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_1__module;var __WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_2__module;var __WEBPACK_LOCAL_MODULE_3__, __WEBPACK_LOCAL_MODULE_3__module;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** File: strophe.js
 *  A JavaScript library for writing XMPP clients.
 *
 *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server or
 *  alternatively WebSockets.
 *
 *  More information on BOSH can be found in XEP 124.
 *  For more information on XMPP-over WebSocket see this RFC:
 *  http://tools.ietf.org/html/rfc7395
 */

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_0__module = { id: "strophe-base64", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_0__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_0__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_0__module.exports, __WEBPACK_LOCAL_MODULE_0__module), __WEBPACK_LOCAL_MODULE_0__module.loaded = true, __WEBPACK_LOCAL_MODULE_0__ === undefined && (__WEBPACK_LOCAL_MODULE_0__ = __WEBPACK_LOCAL_MODULE_0__module.exports));
        } else {
            // Browser globals
            root.Base64 = factory();
        }
    }(this, function () {
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        var obj = {
            /**
             * Encodes a string in base64
             * @param {String} input The string to encode in base64.
             */
            encode: function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                do {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc2 = ((chr1 & 3) << 4);
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                        keyStr.charAt(enc3) + keyStr.charAt(enc4);
                } while (i < input.length);

                return output;
            },

            /**
             * Decodes a base64 string.
             * @param {String} input The string to decode.
             */
            decode: function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

                do {
                    enc1 = keyStr.indexOf(input.charAt(i++));
                    enc2 = keyStr.indexOf(input.charAt(i++));
                    enc3 = keyStr.indexOf(input.charAt(i++));
                    enc4 = keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output = output + String.fromCharCode(chr1);

                    if (enc3 != 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 != 64) {
                        output = output + String.fromCharCode(chr3);
                    }
                } while (i < input.length);

                return output;
            }
        };
        return obj;
    }));

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS PUB 180-1
     * Version 2.1a Copyright Paul Johnston 2000 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: false */
    /* global define */

    /* Some functions and variables have been stripped for use with Strophe */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_1__module = { id: "strophe-sha1", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_1__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_1__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_1__module.exports, __WEBPACK_LOCAL_MODULE_1__module), __WEBPACK_LOCAL_MODULE_1__module.loaded = true, __WEBPACK_LOCAL_MODULE_1__ === undefined && (__WEBPACK_LOCAL_MODULE_1__ = __WEBPACK_LOCAL_MODULE_1__module.exports));
        } else {
            // Browser globals
            root.SHA1 = factory();
        }
    }(this, function () {

        /*
         * Calculate the SHA-1 of an array of big-endian words, and a bit length
         */
        function core_sha1(x, len)
        {
            /* append padding */
            x[len >> 5] |= 0x80 << (24 - len % 32);
            x[((len + 64 >> 9) << 4) + 15] = len;

            var w = new Array(80);
            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;
            var e = -1009589776;

            var i, j, t, olda, oldb, oldc, oldd, olde;
            for (i = 0; i < x.length; i += 16)
            {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;
                olde = e;

                for (j = 0; j < 80; j++)
                {
                    if (j < 16) { w[j] = x[i + j]; }
                    else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
                    t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                        safe_add(safe_add(e, w[j]), sha1_kt(j)));
                    e = d;
                    d = c;
                    c = rol(b, 30);
                    b = a;
                    a = t;
                }

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
                e = safe_add(e, olde);
            }
            return [a, b, c, d, e];
        }

        /*
         * Perform the appropriate triplet combination function for the current
         * iteration
         */
        function sha1_ft(t, b, c, d)
        {
            if (t < 20) { return (b & c) | ((~b) & d); }
            if (t < 40) { return b ^ c ^ d; }
            if (t < 60) { return (b & c) | (b & d) | (c & d); }
            return b ^ c ^ d;
        }

        /*
         * Determine the appropriate additive constant for the current iteration
         */
        function sha1_kt(t)
        {
            return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
                (t < 60) ? -1894007588 : -899497514;
        }

        /*
         * Calculate the HMAC-SHA1 of a key and some data
         */
        function core_hmac_sha1(key, data)
        {
            var bkey = str2binb(key);
            if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }

            var ipad = new Array(16), opad = new Array(16);
            for (var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
            return core_sha1(opad.concat(hash), 512 + 160);
        }

        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function safe_add(x, y)
        {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        }

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function rol(num, cnt)
        {
            return (num << cnt) | (num >>> (32 - cnt));
        }

        /*
         * Convert an 8-bit or 16-bit string to an array of big-endian words
         * In 8-bit function, characters >255 have their hi-byte silently ignored.
         */
        function str2binb(str)
        {
            var bin = [];
            var mask = 255;
            for (var i = 0; i < str.length * 8; i += 8)
            {
                bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
            }
            return bin;
        }

        /*
         * Convert an array of big-endian words to a string
         */
        function binb2str(bin)
        {
            var str = "";
            var mask = 255;
            for (var i = 0; i < bin.length * 32; i += 8)
            {
                str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
            }
            return str;
        }

        /*
         * Convert an array of big-endian words to a base-64 string
         */
        function binb2b64(binarray)
        {
            var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var str = "";
            var triplet, j;
            for (var i = 0; i < binarray.length * 4; i += 3)
            {
                triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
                    (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
                    ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
                for (j = 0; j < 4; j++)
                {
                    if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
                    else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
                }
            }
            return str;
        }

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        return {
            b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },
            b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },
            binb2str:       binb2str,
            core_hmac_sha1: core_hmac_sha1,
            str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },
            str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },
        };
    }));

    /*
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */

    /*
     * Everything that isn't used by Strophe has been stripped here!
     */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_2__module = { id: "strophe-md5", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_2__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_2__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_2__module.exports, __WEBPACK_LOCAL_MODULE_2__module), __WEBPACK_LOCAL_MODULE_2__module.loaded = true, __WEBPACK_LOCAL_MODULE_2__ === undefined && (__WEBPACK_LOCAL_MODULE_2__ = __WEBPACK_LOCAL_MODULE_2__module.exports));
        } else {
            // Browser globals
            root.MD5 = factory();
        }
    }(this, function (b) {
        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        var safe_add = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        var bit_rol = function (num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
        };

        /*
         * Convert a string to an array of little-endian words
         */
        var str2binl = function (str) {
            var bin = [];
            for(var i = 0; i < str.length * 8; i += 8)
            {
                bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
            }
            return bin;
        };

        /*
         * Convert an array of little-endian words to a string
         */
        var binl2str = function (bin) {
            var str = "";
            for(var i = 0; i < bin.length * 32; i += 8)
            {
                str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
            }
            return str;
        };

        /*
         * Convert an array of little-endian words to a hex string.
         */
        var binl2hex = function (binarray) {
            var hex_tab = "0123456789abcdef";
            var str = "";
            for(var i = 0; i < binarray.length * 4; i++)
            {
                str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                    hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
            }
            return str;
        };

        /*
         * These functions implement the four basic operations the algorithm uses.
         */
        var md5_cmn = function (q, a, b, x, s, t) {
            return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
        };

        var md5_ff = function (a, b, c, d, x, s, t) {
            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        };

        var md5_gg = function (a, b, c, d, x, s, t) {
            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        };

        var md5_hh = function (a, b, c, d, x, s, t) {
            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        };

        var md5_ii = function (a, b, c, d, x, s, t) {
            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        };

        /*
         * Calculate the MD5 of an array of little-endian words, and a bit length
         */
        var core_md5 = function (x, len) {
            /* append padding */
            x[len >> 5] |= 0x80 << ((len) % 32);
            x[(((len + 64) >>> 9) << 4) + 14] = len;

            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;

            var olda, oldb, oldc, oldd;
            for (var i = 0; i < x.length; i += 16)
            {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;

                a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
                d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
                c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
                b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
                a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
                d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
                c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
                b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
                a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
                d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
                c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
                b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
                a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
                d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
                c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
                b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

                a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
                d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
                c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
                b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
                a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
                d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
                c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
                b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
                a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
                d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
                c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
                b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
                a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
                d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
                c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
                b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

                a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
                d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
                c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
                b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
                a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
                d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
                c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
                b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
                a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
                d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
                c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
                b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
                a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
                d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
                c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
                b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

                a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
                d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
                c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
                b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
                a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
                d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
                c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
                b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
                a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
                d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
                c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
                b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
                a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
                d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
                c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
                b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
            }
            return [a, b, c, d];
        };

        var obj = {
            /*
             * These are the functions you'll usually want to call.
             * They take string arguments and return either hex or base-64 encoded
             * strings.
             */
            hexdigest: function (s) {
                return binl2hex(core_md5(str2binl(s), s.length * 8));
            },

            hash: function (s) {
                return binl2str(core_md5(str2binl(s), s.length * 8));
            }
        };
        return obj;
    }));

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_3__module = { id: "strophe-utils", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_3__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_3__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_3__module.exports, __WEBPACK_LOCAL_MODULE_3__module), __WEBPACK_LOCAL_MODULE_3__module.loaded = true, __WEBPACK_LOCAL_MODULE_3__ === undefined && (__WEBPACK_LOCAL_MODULE_3__ = __WEBPACK_LOCAL_MODULE_3__module.exports));
        } else {
            // Browser globals
            root.stropheUtils = factory();
        }
    }(this, function () {

        var utils = {

            utf16to8: function (str) {
                var i, c;
                var out = "";
                var len = str.length;
                for (i = 0; i < len; i++) {
                    c = str.charCodeAt(i);
                    if ((c >= 0x0000) && (c <= 0x007F)) {
                        out += str.charAt(i);
                    } else if (c > 0x07FF) {
                        out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                        out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));
                        out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                    } else {
                        out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));
                        out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                    }
                }
                return out;
            },

            addCookies: function (cookies) {
                /* Parameters:
                 *  (Object) cookies - either a map of cookie names
                 *    to string values or to maps of cookie values.
                 *
                 * For example:
                 * { "myCookie": "1234" }
                 *
                 * or:
                 * { "myCookie": {
                 *      "value": "1234",
                 *      "domain": ".example.org",
                 *      "path": "/",
                 *      "expires": expirationDate
                 *      }
                 *  }
                 *
                 *  These values get passed to Strophe.Connection via
                 *   options.cookies
                 */
                var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;
                for (cookieName in (cookies || {})) {
                    expires = '';
                    domain = '';
                    path = '';
                    cookieObj = cookies[cookieName];
                    isObj = typeof cookieObj == "object";
                    cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
                    if (isObj) {
                        expires = cookieObj.expires ? ";expires="+cookieObj.expires : '';
                        domain = cookieObj.domain ? ";domain="+cookieObj.domain : '';
                        path = cookieObj.path ? ";path="+cookieObj.path : '';
                    }
                    document.cookie =
                        cookieName+'='+cookieValue + expires + domain + path;
                }
            }
        };
        return utils;
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_4__ = (function () {
                return factory();
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            return factory();
        }
    }(this, function () {

        /** Function: Function.prototype.bind
         *  Bind a function to an instance.
         *
         *  This Function object extension method creates a bound method similar
         *  to those in Python.  This means that the 'this' object will point
         *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>
         *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>
         *  for a complete explanation.
         *
         *  This extension already exists in some browsers (namely, Firefox 3), but
         *  we provide it to support those that don't.
         *
         *  Parameters:
         *    (Object) obj - The object that will become 'this' in the bound function.
         *    (Object) argN - An option argument that will be prepended to the
         *      arguments given for the function call
         *
         *  Returns:
         *    The bound function.
         */
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {
                var func = this;
                var _slice = Array.prototype.slice;
                var _concat = Array.prototype.concat;
                var _args = _slice.call(arguments, 1);
                return function () {
                    return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));
                };
            };
        }

        /** Function: Array.isArray
         *  This is a polyfill for the ES5 Array.isArray method.
         */
        if (!Array.isArray) {
            Array.isArray = function(arg) {
                return Object.prototype.toString.call(arg) === '[object Array]';
            };
        }

        /** Function: Array.prototype.indexOf
         *  Return the index of an object in an array.
         *
         *  This function is not supplied by some JavaScript implementations, so
         *  we provide it if it is missing.  This code is from:
         *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
         *
         *  Parameters:
         *    (Object) elt - The object to look for.
         *    (Integer) from - The index from which to start looking. (optional).
         *
         *  Returns:
         *    The index of elt in the array or -1 if not found.
         */
        if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = function(elt /*, from*/) {
                var len = this.length;
                var from = Number(arguments[1]) || 0;
                from = (from < 0) ? Math.ceil(from) : Math.floor(from);
                if (from < 0) {
                    from += len;
                }

                for (; from < len; from++) {
                    if (from in this && this[from] === elt) {
                        return from;
                    }
                }
                return -1;
            };
        }
    }));


    /** Function: Array.prototype.forEach
     *
     *  This function is not available in IE < 9
     *
     *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>
     */
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(callback, thisArg) {
            var T, k;
            if (this === null) {
                throw new TypeError(' this is null or not defined');
            }

            // 1. Let O be the result of calling toObject() passing the
            // |this| value as the argument.
            var O = Object(this);
            // 2. Let lenValue be the result of calling the Get() internal
            // method of O with the argument "length".
            // 3. Let len be toUint32(lenValue).
            var len = O.length >>> 0;
            // 4. If isCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== "function") {
                throw new TypeError(callback + ' is not a function');
            }
            // 5. If thisArg was supplied, let T be thisArg; else let
            // T be undefined.
            if (arguments.length > 1) {
                T = thisArg;
            }
            // 6. Let k be 0
            k = 0;
            // 7. Repeat, while k < len
            while (k < len) {
                var kValue;
                // a. Let Pk be ToString(k).
                //        This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty
                //        internal method of O with argument Pk.
                //        This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {
                    // i. Let kValue be the result of calling the Get internal
                    // method of O with argument Pk.
                    kValue = O[k];
                    // ii. Call the Call internal method of callback with T as
                    // the this value and argument list containing kValue, k, and O.
                    callback.call(T, kValue, k, O);
                }
                // d. Increase k by 1.
                k++;
            }
            // 8. return undefined
        };
    }

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /*global define, document, window, setTimeout, clearTimeout, ActiveXObject, DOMParser */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                __WEBPACK_LOCAL_MODULE_1__,
                __WEBPACK_LOCAL_MODULE_0__,
                __WEBPACK_LOCAL_MODULE_2__,
                __WEBPACK_LOCAL_MODULE_3__,
                __WEBPACK_LOCAL_MODULE_4__
            ], __WEBPACK_LOCAL_MODULE_5__ = (function () {
                return factory.apply(this, arguments);
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
            window.Strophe =        o.Strophe;
            window.$build =         o.$build;
            window.$iq =            o.$iq;
            window.$msg =           o.$msg;
            window.$pres =          o.$pres;
            window.SHA1 =           o.SHA1;
            window.Base64 =         o.Base64;
            window.MD5 =            o.MD5;
            window.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;
            window.b64_sha1 =       o.SHA1.b64_sha1;
            window.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;
            window.str_sha1 =       o.SHA1.str_sha1;
        }
    }(this, function (SHA1, Base64, MD5, utils) {

        var Strophe;

        /** Function: $build
         *  Create a Strophe.Builder.
         *  This is an alias for 'new Strophe.Builder(name, attrs)'.
         *
         *  Parameters:
         *    (String) name - The root element name.
         *    (Object) attrs - The attributes for the root element in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $build(name, attrs) { return new Strophe.Builder(name, attrs); }

        /** Function: $msg
         *  Create a Strophe.Builder with a <message/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <message/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $msg(attrs) { return new Strophe.Builder("message", attrs); }

        /** Function: $iq
         *  Create a Strophe.Builder with an <iq/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <iq/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $iq(attrs) { return new Strophe.Builder("iq", attrs); }

        /** Function: $pres
         *  Create a Strophe.Builder with a <presence/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <presence/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

        /** Class: Strophe
         *  An object container for all Strophe library functions.
         *
         *  This class is just a container for all the objects and constants
         *  used in the library.  It is not meant to be instantiated, but to
         *  provide a namespace for library objects, constants, and functions.
         */
        Strophe = {
            /** Constant: VERSION
             *  The version of the Strophe library. Unreleased builds will have
             *  a version of head-HASH where HASH is a partial revision.
             */
            VERSION: "1.2.12",

            /** Constants: XMPP Namespace Constants
             *  Common namespace constants from the XMPP RFCs and XEPs.
             *
             *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
             *  NS.BOSH - BOSH namespace from XEP 206.
             *  NS.CLIENT - Main XMPP client namespace.
             *  NS.AUTH - Legacy authentication namespace.
             *  NS.ROSTER - Roster operations namespace.
             *  NS.PROFILE - Profile namespace.
             *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
             *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
             *  NS.MUC - Multi-User Chat namespace from XEP 45.
             *  NS.SASL - XMPP SASL namespace from RFC 3920.
             *  NS.STREAM - XMPP Streams namespace from RFC 3920.
             *  NS.BIND - XMPP Binding namespace from RFC 3920.
             *  NS.SESSION - XMPP Session namespace from RFC 3920.
             *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
             *  NS.XHTML - XHTML body namespace from XEP 71.
             */
            NS: {
                HTTPBIND: "http://jabber.org/protocol/httpbind",
                BOSH: "urn:xmpp:xbosh",
                CLIENT: "jabber:client",
                AUTH: "jabber:iq:auth",
                ROSTER: "jabber:iq:roster",
                PROFILE: "jabber:iq:profile",
                DISCO_INFO: "http://jabber.org/protocol/disco#info",
                DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                MUC: "http://jabber.org/protocol/muc",
                SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                STREAM: "http://etherx.jabber.org/streams",
                FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                VERSION: "jabber:iq:version",
                STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                XHTML: "http://www.w3.org/1999/xhtml"
            },

            /** Constants: XHTML_IM Namespace
             *  contains allowed tags, tag attributes, and css properties.
             *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
             *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
             *  allowed tags and their attributes.
             */
            XHTML: {
                tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
                attributes: {
                    'a':          ['href'],
                    'blockquote': ['style'],
                    'br':         [],
                    'cite':       ['style'],
                    'em':         [],
                    'img':        ['src', 'alt', 'style', 'height', 'width'],
                    'li':         ['style'],
                    'ol':         ['style'],
                    'p':          ['style'],
                    'span':       ['style'],
                    'strong':     [],
                    'ul':         ['style'],
                    'body':       []
                },
                css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
                /** Function: XHTML.validTag
                 *
                 * Utility method to determine whether a tag is allowed
                 * in the XHTML_IM namespace.
                 *
                 * XHTML tag names are case sensitive and must be lower case.
                 */
                validTag: function(tag) {
                    for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                        if (tag == Strophe.XHTML.tags[i]) {
                            return true;
                        }
                    }
                    return false;
                },
                /** Function: XHTML.validAttribute
                 *
                 * Utility method to determine whether an attribute is allowed
                 * as recommended per XEP-0071
                 *
                 * XHTML attribute names are case sensitive and must be lower case.
                 */
                validAttribute: function(tag, attribute) {
                    if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                        for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                            if (attribute == Strophe.XHTML.attributes[tag][i]) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                validCSS: function(style) {
                    for (var i = 0; i < Strophe.XHTML.css.length; i++) {
                        if (style == Strophe.XHTML.css[i]) {
                            return true;
                        }
                    }
                    return false;
                }
            },

            /** Constants: Connection Status Constants
             *  Connection status constants for use by the connection handler
             *  callback.
             *
             *  Status.ERROR - An error has occurred
             *  Status.CONNECTING - The connection is currently being made
             *  Status.CONNFAIL - The connection attempt failed
             *  Status.AUTHENTICATING - The connection is authenticating
             *  Status.AUTHFAIL - The authentication attempt failed
             *  Status.CONNECTED - The connection has succeeded
             *  Status.DISCONNECTED - The connection has been terminated
             *  Status.DISCONNECTING - The connection is currently being terminated
             *  Status.ATTACHED - The connection has been attached
             *  Status.CONNTIMEOUT - The connection has timed out
             */
            Status: {
                ERROR: 0,
                CONNECTING: 1,
                CONNFAIL: 2,
                AUTHENTICATING: 3,
                AUTHFAIL: 4,
                CONNECTED: 5,
                DISCONNECTED: 6,
                DISCONNECTING: 7,
                ATTACHED: 8,
                REDIRECT: 9,
                CONNTIMEOUT: 10
            },

            /** Constants: Log Level Constants
             *  Logging level indicators.
             *
             *  LogLevel.DEBUG - Debug output
             *  LogLevel.INFO - Informational output
             *  LogLevel.WARN - Warnings
             *  LogLevel.ERROR - Errors
             *  LogLevel.FATAL - Fatal errors
             */
            LogLevel: {
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3,
                FATAL: 4
            },

            /** PrivateConstants: DOM Element Type Constants
             *  DOM element types.
             *
             *  ElementType.NORMAL - Normal element.
             *  ElementType.TEXT - Text data element.
             *  ElementType.FRAGMENT - XHTML fragment element.
             */
            ElementType: {
                NORMAL: 1,
                TEXT: 3,
                CDATA: 4,
                FRAGMENT: 11
            },

            /** PrivateConstants: Timeout Values
             *  Timeout values for error states.  These values are in seconds.
             *  These should not be changed unless you know exactly what you are
             *  doing.
             *
             *  TIMEOUT - Timeout multiplier. A waiting request will be considered
             *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
             *      This defaults to 1.1, and with default wait, 66 seconds.
             *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
             *      Strophe can detect early failure, it will consider the request
             *      failed if it doesn't return after
             *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
             *      This defaults to 0.1, and with default wait, 6 seconds.
             */
            TIMEOUT: 1.1,
            SECONDARY_TIMEOUT: 0.1,

            /** Function: addNamespace
             *  This function is used to extend the current namespaces in
             *  Strophe.NS.  It takes a key and a value with the key being the
             *  name of the new namespace, with its actual value.
             *  For example:
             *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
             *
             *  Parameters:
             *    (String) name - The name under which the namespace will be
             *      referenced under Strophe.NS
             *    (String) value - The actual namespace.
             */
            addNamespace: function (name, value) {
                Strophe.NS[name] = value;
            },

            /** Function: forEachChild
             *  Map a function over some or all child elements of a given element.
             *
             *  This is a small convenience function for mapping a function over
             *  some or all of the children of an element.  If elemName is null, all
             *  children will be passed to the function, otherwise only children
             *  whose tag names match elemName will be passed.
             *
             *  Parameters:
             *    (XMLElement) elem - The element to operate on.
             *    (String) elemName - The child element tag name filter.
             *    (Function) func - The function to apply to each child.  This
             *      function should take a single argument, a DOM element.
             */
            forEachChild: function (elem, elemName, func) {
                var i, childNode;
                for (i = 0; i < elem.childNodes.length; i++) {
                    childNode = elem.childNodes[i];
                    if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                        (!elemName || this.isTagEqual(childNode, elemName))) {
                        func(childNode);
                    }
                }
            },

            /** Function: isTagEqual
             *  Compare an element's tag name with a string.
             *
             *  This function is case sensitive.
             *
             *  Parameters:
             *    (XMLElement) el - A DOM element.
             *    (String) name - The element name.
             *
             *  Returns:
             *    true if the element's tag name matches _el_, and false
             *    otherwise.
             */
            isTagEqual: function (el, name) {
                return el.tagName == name;
            },

            /** PrivateVariable: _xmlGenerator
             *  _Private_ variable that caches a DOM document to
             *  generate elements.
             */
            _xmlGenerator: null,

            /** PrivateFunction: _makeGenerator
             *  _Private_ function that creates a dummy XML DOM document to serve as
             *  an element and text node generator.
             */
            _makeGenerator: function () {
                var doc;
                // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
                // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
                // less than 10 in the case of IE9 and below.
                if (document.implementation.createDocument === undefined ||
                    document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                    doc = this._getIEXmlDom();
                    doc.appendChild(doc.createElement('strophe'));
                } else {
                    doc = document.implementation
                        .createDocument('jabber:client', 'strophe', null);
                }
                return doc;
            },

            /** Function: xmlGenerator
             *  Get the DOM document to generate elements.
             *
             *  Returns:
             *    The currently used DOM document.
             */
            xmlGenerator: function () {
                if (!Strophe._xmlGenerator) {
                    Strophe._xmlGenerator = Strophe._makeGenerator();
                }
                return Strophe._xmlGenerator;
            },

            /** PrivateFunction: _getIEXmlDom
             *  Gets IE xml doc object
             *
             *  Returns:
             *    A Microsoft XML DOM Object
             *  See Also:
             *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
             */
            _getIEXmlDom : function() {
                var doc = null;
                var docStrings = [
                    "Msxml2.DOMDocument.6.0",
                    "Msxml2.DOMDocument.5.0",
                    "Msxml2.DOMDocument.4.0",
                    "MSXML2.DOMDocument.3.0",
                    "MSXML2.DOMDocument",
                    "MSXML.DOMDocument",
                    "Microsoft.XMLDOM"
                ];

                for (var d = 0; d < docStrings.length; d++) {
                    if (doc === null) {
                        try {
                            doc = new ActiveXObject(docStrings[d]);
                        } catch (e) {
                            doc = null;
                        }
                    } else {
                        break;
                    }
                }
                return doc;
            },

            /** Function: xmlElement
             *  Create an XML DOM element.
             *
             *  This function creates an XML DOM element correctly across all
             *  implementations. Note that these are not HTML DOM elements, which
             *  aren't appropriate for XMPP stanzas.
             *
             *  Parameters:
             *    (String) name - The name for the element.
             *    (Array|Object) attrs - An optional array or object containing
             *      key/value pairs to use as element attributes. The object should
             *      be in the format {'key': 'value'} or {key: 'value'}. The array
             *      should have the format [['key1', 'value1'], ['key2', 'value2']].
             *    (String) text - The text child data for the element.
             *
             *  Returns:
             *    A new XML DOM element.
             */
            xmlElement: function (name) {
                if (!name) { return null; }

                var node = Strophe.xmlGenerator().createElement(name);
                // FIXME: this should throw errors if args are the wrong type or
                // there are more than two optional args
                var a, i, k;
                for (a = 1; a < arguments.length; a++) {
                    var arg = arguments[a];
                    if (!arg) { continue; }
                    if (typeof(arg) == "string" ||
                        typeof(arg) == "number") {
                        node.appendChild(Strophe.xmlTextNode(arg));
                    } else if (typeof(arg) == "object" &&
                        typeof(arg.sort) == "function") {
                        for (i = 0; i < arg.length; i++) {
                            var attr = arg[i];
                            if (typeof(attr) == "object" &&
                                typeof(attr.sort) == "function" &&
                                attr[1] !== undefined &&
                                attr[1] !== null) {
                                node.setAttribute(attr[0], attr[1]);
                            }
                        }
                    } else if (typeof(arg) == "object") {
                        for (k in arg) {
                            if (arg.hasOwnProperty(k)) {
                                if (arg[k] !== undefined &&
                                    arg[k] !== null) {
                                    node.setAttribute(k, arg[k]);
                                }
                            }
                        }
                    }
                }
                return node;
            },

            /*  Function: xmlescape
             *  Excapes invalid xml characters.
             *
             *  Parameters:
             *     (String) text - text to escape.
             *
             *  Returns:
             *      Escaped text.
             */
            xmlescape: function(text) {
                text = text.replace(/\&/g, "&amp;");
                text = text.replace(/</g,  "&lt;");
                text = text.replace(/>/g,  "&gt;");
                text = text.replace(/'/g,  "&apos;");
                text = text.replace(/"/g,  "&quot;");
                return text;
            },

            /*  Function: xmlunescape
             *  Unexcapes invalid xml characters.
             *
             *  Parameters:
             *     (String) text - text to unescape.
             *
             *  Returns:
             *      Unescaped text.
             */
            xmlunescape: function(text) {
                text = text.replace(/\&amp;/g, "&");
                text = text.replace(/&lt;/g,  "<");
                text = text.replace(/&gt;/g,  ">");
                text = text.replace(/&apos;/g,  "'");
                text = text.replace(/&quot;/g,  "\"");
                return text;
            },

            /** Function: xmlTextNode
             *  Creates an XML DOM text node.
             *
             *  Provides a cross implementation version of document.createTextNode.
             *
             *  Parameters:
             *    (String) text - The content of the text node.
             *
             *  Returns:
             *    A new XML DOM text node.
             */
            xmlTextNode: function (text) {
                return Strophe.xmlGenerator().createTextNode(text);
            },

            /** Function: xmlHtmlNode
             *  Creates an XML DOM html node.
             *
             *  Parameters:
             *    (String) html - The content of the html node.
             *
             *  Returns:
             *    A new XML DOM text node.
             */
            xmlHtmlNode: function (html) {
                var node;
                //ensure text is escaped
                if (window.DOMParser) {
                    var parser = new DOMParser();
                    node = parser.parseFromString(html, "text/xml");
                } else {
                    node = new ActiveXObject("Microsoft.XMLDOM");
                    node.async="false";
                    node.loadXML(html);
                }
                return node;
            },

            /** Function: getText
             *  Get the concatenation of all text children of an element.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A String with the concatenated text of all text element children.
             */
            getText: function (elem) {
                if (!elem) { return null; }

                var str = "";
                if (elem.childNodes.length === 0 && elem.nodeType ==
                    Strophe.ElementType.TEXT) {
                    str += elem.nodeValue;
                }

                for (var i = 0; i < elem.childNodes.length; i++) {
                    if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                        str += elem.childNodes[i].nodeValue;
                    }
                }

                return Strophe.xmlescape(str);
            },

            /** Function: copyElement
             *  Copy an XML DOM element.
             *
             *  This function copies a DOM element and all its descendants and returns
             *  the new copy.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A new, copied DOM element tree.
             */
            copyElement: function (elem) {
                var i, el;
                if (elem.nodeType == Strophe.ElementType.NORMAL) {
                    el = Strophe.xmlElement(elem.tagName);

                    for (i = 0; i < elem.attributes.length; i++) {
                        el.setAttribute(elem.attributes[i].nodeName,
                            elem.attributes[i].value);
                    }

                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.copyElement(elem.childNodes[i]));
                    }
                } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
                }
                return el;
            },


            /** Function: createHtml
             *  Copy an HTML DOM element into an XML DOM.
             *
             *  This function copies a DOM element and all its descendants and returns
             *  the new copy.
             *
             *  Parameters:
             *    (HTMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A new, copied DOM element tree.
             */
            createHtml: function (elem) {
                var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
                if (elem.nodeType == Strophe.ElementType.NORMAL) {
                    tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.
                    if(Strophe.XHTML.validTag(tag)) {
                        try {
                            el = Strophe.xmlElement(tag);
                            for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                                attribute = Strophe.XHTML.attributes[tag][i];
                                value = elem.getAttribute(attribute);
                                if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                                    continue;
                                }
                                if(attribute == 'style' && typeof value == 'object') {
                                    if(typeof value.cssText != 'undefined') {
                                        value = value.cssText; // we're dealing with IE, need to get CSS out
                                    }
                                }
                                // filter out invalid css styles
                                if(attribute == 'style') {
                                    css = [];
                                    cssAttrs = value.split(';');
                                    for(j = 0; j < cssAttrs.length; j++) {
                                        attr = cssAttrs[j].split(':');
                                        cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                        if(Strophe.XHTML.validCSS(cssName)) {
                                            cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                            css.push(cssName + ': ' + cssValue);
                                        }
                                    }
                                    if(css.length > 0) {
                                        value = css.join('; ');
                                        el.setAttribute(attribute, value);
                                    }
                                } else {
                                    el.setAttribute(attribute, value);
                                }
                            }

                            for (i = 0; i < elem.childNodes.length; i++) {
                                el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                            }
                        } catch(e) { // invalid elements
                            el = Strophe.xmlTextNode('');
                        }
                    } else {
                        el = Strophe.xmlGenerator().createDocumentFragment();
                        for (i = 0; i < elem.childNodes.length; i++) {
                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                        }
                    }
                } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
                    el = Strophe.xmlGenerator().createDocumentFragment();
                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlTextNode(elem.nodeValue);
                }
                return el;
            },

            /** Function: escapeNode
             *  Escape the node part (also called local part) of a JID.
             *
             *  Parameters:
             *    (String) node - A node (or local part).
             *
             *  Returns:
             *    An escaped node (or local part).
             */
            escapeNode: function (node) {
                if (typeof node !== "string") { return node; }
                return node.replace(/^\s+|\s+$/g, '')
                    .replace(/\\/g,  "\\5c")
                    .replace(/ /g,   "\\20")
                    .replace(/\"/g,  "\\22")
                    .replace(/\&/g,  "\\26")
                    .replace(/\'/g,  "\\27")
                    .replace(/\//g,  "\\2f")
                    .replace(/:/g,   "\\3a")
                    .replace(/</g,   "\\3c")
                    .replace(/>/g,   "\\3e")
                    .replace(/@/g,   "\\40");
            },

            /** Function: unescapeNode
             *  Unescape a node part (also called local part) of a JID.
             *
             *  Parameters:
             *    (String) node - A node (or local part).
             *
             *  Returns:
             *    An unescaped node (or local part).
             */
            unescapeNode: function (node) {
                if (typeof node !== "string") { return node; }
                return node.replace(/\\20/g, " ")
                    .replace(/\\22/g, '"')
                    .replace(/\\26/g, "&")
                    .replace(/\\27/g, "'")
                    .replace(/\\2f/g, "/")
                    .replace(/\\3a/g, ":")
                    .replace(/\\3c/g, "<")
                    .replace(/\\3e/g, ">")
                    .replace(/\\40/g, "@")
                    .replace(/\\5c/g, "\\");
            },

            /** Function: getNodeFromJid
             *  Get the node portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the node.
             */
            getNodeFromJid: function (jid) {
                if (jid.indexOf("@") < 0) { return null; }
                return jid.split("@")[0];
            },

            /** Function: getDomainFromJid
             *  Get the domain portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the domain.
             */
            getDomainFromJid: function (jid) {
                var bare = Strophe.getBareJidFromJid(jid);
                if (bare.indexOf("@") < 0) {
                    return bare;
                } else {
                    var parts = bare.split("@");
                    parts.splice(0, 1);
                    return parts.join('@');
                }
            },

            /** Function: getResourceFromJid
             *  Get the resource portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the resource.
             */
            getResourceFromJid: function (jid) {
                var s = jid.split("/");
                if (s.length < 2) { return null; }
                s.splice(0, 1);
                return s.join('/');
            },

            /** Function: getBareJidFromJid
             *  Get the bare JID from a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the bare JID.
             */
            getBareJidFromJid: function (jid) {
                return jid ? jid.split("/")[0] : null;
            },

            /** PrivateFunction: _handleError
             *  _Private_ function that properly logs an error to the console
             */
            _handleError: function (e) {
                if (typeof e.stack !== "undefined") {
                    Strophe.fatal(e.stack);
                }
                if (e.sourceURL) {
                    Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" +
                        e.line + " - " + e.name + ": " + e.message);
                } else if (e.fileName) {
                    Strophe.fatal("error: " + this.handler + " " +
                        e.fileName + ":" + e.lineNumber + " - " +
                        e.name + ": " + e.message);
                } else {
                    Strophe.fatal("error: " + e.message);
                }
            },

            /** Function: log
             *  User overrideable logging function.
             *
             *  This function is called whenever the Strophe library calls any
             *  of the logging functions.  The default implementation of this
             *  function does nothing.  If client code wishes to handle the logging
             *  messages, it should override this with
             *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
             *
             *  Please note that data sent and received over the wire is logged
             *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
             *
             *  The different levels and their meanings are
             *
             *    DEBUG - Messages useful for debugging purposes.
             *    INFO - Informational messages.  This is mostly information like
             *      'disconnect was called' or 'SASL auth succeeded'.
             *    WARN - Warnings about potential problems.  This is mostly used
             *      to report transient connection errors like request timeouts.
             *    ERROR - Some error occurred.
             *    FATAL - A non-recoverable fatal error occurred.
             *
             *  Parameters:
             *    (Integer) level - The log level of the log message.  This will
             *      be one of the values in Strophe.LogLevel.
             *    (String) msg - The log message.
             */
            /* jshint ignore:start */
            log: function (level, msg) {
                return;
            },
            /* jshint ignore:end */

            /** Function: debug
             *  Log a message at the Strophe.LogLevel.DEBUG level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            debug: function(msg) {
                this.log(this.LogLevel.DEBUG, msg);
            },

            /** Function: info
             *  Log a message at the Strophe.LogLevel.INFO level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            info: function (msg) {
                this.log(this.LogLevel.INFO, msg);
            },

            /** Function: warn
             *  Log a message at the Strophe.LogLevel.WARN level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            warn: function (msg) {
                this.log(this.LogLevel.WARN, msg);
            },

            /** Function: error
             *  Log a message at the Strophe.LogLevel.ERROR level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            error: function (msg) {
                this.log(this.LogLevel.ERROR, msg);
            },

            /** Function: fatal
             *  Log a message at the Strophe.LogLevel.FATAL level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            fatal: function (msg) {
                this.log(this.LogLevel.FATAL, msg);
            },

            /** Function: serialize
             *  Render a DOM element and all descendants to a String.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    The serialized element tree as a String.
             */
            serialize: function (elem) {
                var result;

                if (!elem) { return null; }

                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }

                /**
                 * Leon Revill: Convert to lower case
                 * @type {string}
                 */
                /**
                 * Graham Mackenzie: Remove Leon's change
                 * @type {string}
                 */
                var nodeName = elem.nodeName;
                var i, child;

                if (elem.getAttribute("_realname")) {
                    nodeName = elem.getAttribute("_realname");
                }

                result = "<" + nodeName;
                for (i = 0; i < elem.attributes.length; i++) {
                    if(elem.attributes[i].nodeName != "_realname") {
                        result += " " + elem.attributes[i].nodeName +
                            "='" + Strophe.xmlescape(elem.attributes[i].value) + "'";
                    }
                }

                if (elem.childNodes.length > 0) {
                    result += ">";
                    for (i = 0; i < elem.childNodes.length; i++) {
                        child = elem.childNodes[i];
                        switch( child.nodeType ){
                            case Strophe.ElementType.NORMAL:
                                // normal element, so recurse
                                result += Strophe.serialize(child);
                                break;
                            case Strophe.ElementType.TEXT:
                                // text element to escape values
                                result += Strophe.xmlescape(child.nodeValue);
                                break;
                            case Strophe.ElementType.CDATA:
                                // cdata section so don't escape values
                                result += "<![CDATA["+child.nodeValue+"]]>";
                        }
                    }
                    result += "</" + nodeName + ">";
                } else {
                    result += "/>";
                }

                return result;
            },

            /** PrivateVariable: _requestId
             *  _Private_ variable that keeps track of the request ids for
             *  connections.
             */
            _requestId: 0,

            /** PrivateVariable: Strophe.connectionPlugins
             *  _Private_ variable Used to store plugin names that need
             *  initialization on Strophe.Connection construction.
             */
            _connectionPlugins: {},

            /** Function: addConnectionPlugin
             *  Extends the Strophe.Connection object with the given plugin.
             *
             *  Parameters:
             *    (String) name - The name of the extension.
             *    (Object) ptype - The plugin's prototype.
             */
            addConnectionPlugin: function (name, ptype) {
                Strophe._connectionPlugins[name] = ptype;
            }
        };

        /** Class: Strophe.Builder
         *  XML DOM builder.
         *
         *  This object provides an interface similar to JQuery but for building
         *  DOM elements easily and rapidly.  All the functions except for toString()
         *  and tree() return the object, so calls can be chained.  Here's an
         *  example using the $iq() builder helper.
         *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
         *  >     .c('query', {xmlns: 'strophe:example'})
         *  >     .c('example')
         *  >     .toString()
         *
         *  The above generates this XML fragment
         *  > <iq to='you' from='me' type='get' id='1'>
         *  >   <query xmlns='strophe:example'>
         *  >     <example/>
         *  >   </query>
         *  > </iq>
         *  The corresponding DOM manipulations to get a similar fragment would be
         *  a lot more tedious and probably involve several helper variables.
         *
         *  Since adding children makes new operations operate on the child, up()
         *  is provided to traverse up the tree.  To add two children, do
         *  > builder.c('child1', ...).up().c('child2', ...)
         *  The next operation on the Builder will be relative to the second child.
         */

        /** Constructor: Strophe.Builder
         *  Create a Strophe.Builder object.
         *
         *  The attributes should be passed in object notation.  For example
         *  > var b = new Builder('message', {to: 'you', from: 'me'});
         *  or
         *  > var b = new Builder('messsage', {'xml:lang': 'en'});
         *
         *  Parameters:
         *    (String) name - The name of the root element.
         *    (Object) attrs - The attributes for the root element in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder.
         */
        Strophe.Builder = function (name, attrs) {
            // Set correct namespace for jabber:client elements
            if (name == "presence" || name == "message" || name == "iq") {
                if (attrs && !attrs.xmlns) {
                    attrs.xmlns = Strophe.NS.CLIENT;
                } else if (!attrs) {
                    attrs = {xmlns: Strophe.NS.CLIENT};
                }
            }

            // Holds the tree being built.
            this.nodeTree = Strophe.xmlElement(name, attrs);

            // Points to the current operation node.
            this.node = this.nodeTree;
        };

        Strophe.Builder.prototype = {
            /** Function: tree
             *  Return the DOM tree.
             *
             *  This function returns the current DOM tree as an element object.  This
             *  is suitable for passing to functions like Strophe.Connection.send().
             *
             *  Returns:
             *    The DOM tree as a element object.
             */
            tree: function () {
                return this.nodeTree;
            },

            /** Function: toString
             *  Serialize the DOM tree to a String.
             *
             *  This function returns a string serialization of the current DOM
             *  tree.  It is often used internally to pass data to a
             *  Strophe.Request object.
             *
             *  Returns:
             *    The serialized DOM tree in a String.
             */
            toString: function () {
                return Strophe.serialize(this.nodeTree);
            },

            /** Function: up
             *  Make the current parent element the new current element.
             *
             *  This function is often used after c() to traverse back up the tree.
             *  For example, to add two children to the same element
             *  > builder.c('child1', {}).up().c('child2', {});
             *
             *  Returns:
             *    The Stophe.Builder object.
             */
            up: function () {
                this.node = this.node.parentNode;
                return this;
            },

            /** Function: root
             *  Make the root element the new current element.
             *
             *  When at a deeply nested element in the tree, this function can be used
             *  to jump back to the root of the tree, instead of having to repeatedly
             *  call up().
             *
             *  Returns:
             *    The Stophe.Builder object.
             */
            root: function () {
                this.node = this.nodeTree;
                return this;
            },

            /** Function: attrs
             *  Add or modify attributes of the current element.
             *
             *  The attributes should be passed in object notation.  This function
             *  does not move the current element pointer.
             *
             *  Parameters:
             *    (Object) moreattrs - The attributes to add/modify in object notation.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            attrs: function (moreattrs) {
                for (var k in moreattrs) {
                    if (moreattrs.hasOwnProperty(k)) {
                        if (moreattrs[k] === undefined) {
                            this.node.removeAttribute(k);
                        } else {
                            this.node.setAttribute(k, moreattrs[k]);
                        }
                    }
                }
                return this;
            },

            /** Function: c
             *  Add a child to the current element and make it the new current
             *  element.
             *
             *  This function moves the current element pointer to the child,
             *  unless text is provided.  If you need to add another child, it
             *  is necessary to use up() to go back to the parent in the tree.
             *
             *  Parameters:
             *    (String) name - The name of the child.
             *    (Object) attrs - The attributes of the child in object notation.
             *    (String) text - The text to add to the child.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            c: function (name, attrs, text) {
                var child = Strophe.xmlElement(name, attrs, text);
                this.node.appendChild(child);
                if (typeof text !== "string" && typeof text !=="number") {
                    this.node = child;
                }
                return this;
            },

            /** Function: cnode
             *  Add a child to the current element and make it the new current
             *  element.
             *
             *  This function is the same as c() except that instead of using a
             *  name and an attributes object to create the child it uses an
             *  existing DOM element object.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            cnode: function (elem) {
                var impNode;
                var xmlGen = Strophe.xmlGenerator();
                try {
                    impNode = (xmlGen.importNode !== undefined);
                } catch (e) {
                    impNode = false;
                }
                var newElem = impNode ?
                    xmlGen.importNode(elem, true) :
                    Strophe.copyElement(elem);
                this.node.appendChild(newElem);
                this.node = newElem;
                return this;
            },

            /** Function: t
             *  Add a child text element.
             *
             *  This *does not* make the child the new current element since there
             *  are no children of text elements.
             *
             *  Parameters:
             *    (String) text - The text data to append to the current element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            t: function (text) {
                var child = Strophe.xmlTextNode(text);
                this.node.appendChild(child);
                return this;
            },

            /** Function: h
             *  Replace current element contents with the HTML passed in.
             *
             *  This *does not* make the child the new current element
             *
             *  Parameters:
             *    (String) html - The html to insert as contents of current element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            h: function (html) {
                var fragment = document.createElement('body');

                // force the browser to try and fix any invalid HTML tags
                fragment.innerHTML = html;

                // copy cleaned html into an xml dom
                var xhtml = Strophe.createHtml(fragment);

                while(xhtml.childNodes.length > 0) {
                    this.node.appendChild(xhtml.childNodes[0]);
                }
                return this;
            }
        };

        /** PrivateClass: Strophe.Handler
         *  _Private_ helper class for managing stanza handlers.
         *
         *  A Strophe.Handler encapsulates a user provided callback function to be
         *  executed when matching stanzas are received by the connection.
         *  Handlers can be either one-off or persistant depending on their
         *  return value. Returning true will cause a Handler to remain active, and
         *  returning false will remove the Handler.
         *
         *  Users will not use Strophe.Handler objects directly, but instead they
         *  will use Strophe.Connection.addHandler() and
         *  Strophe.Connection.deleteHandler().
         */

        /** PrivateConstructor: Strophe.Handler
         *  Create and initialize a new Strophe.Handler.
         *
         *  Parameters:
         *    (Function) handler - A function to be executed when the handler is run.
         *    (String) ns - The namespace to match.
         *    (String) name - The element name to match.
         *    (String) type - The element type to match.
         *    (String) id - The element id attribute to match.
         *    (String) from - The element from attribute to match.
         *    (Object) options - Handler options
         *
         *  Returns:
         *    A new Strophe.Handler object.
         */
        Strophe.Handler = function (handler, ns, name, type, id, from, options) {
            this.handler = handler;
            this.ns = ns;
            this.name = name;
            this.type = type;
            this.id = id;
            this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};
            // BBB: Maintain backward compatibility with old `matchBare` option
            if (this.options.matchBare) {
                Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
                this.options.matchBareFromJid = this.options.matchBare;
                delete this.options.matchBare;
            }

            if (this.options.matchBareFromJid) {
                this.from = from ? Strophe.getBareJidFromJid(from) : null;
            } else {
                this.from = from;
            }
            // whether the handler is a user handler or a system handler
            this.user = true;
        };

        Strophe.Handler.prototype = {
            /** PrivateFunction: getNamespace
             *  Returns the XML namespace attribute on an element.
             *  If `ignoreNamespaceFragment` was passed in for this handler, then the
             *  URL fragment will be stripped.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element with the namespace.
             *
             *  Returns:
             *    The namespace, with optionally the fragment stripped.
             */
            getNamespace: function (elem) {
                var elNamespace = elem.getAttribute("xmlns");
                if (elNamespace && this.options.ignoreNamespaceFragment) {
                    elNamespace = elNamespace.split('#')[0];
                }
                return elNamespace;
            },

            /** PrivateFunction: namespaceMatch
             *  Tests if a stanza matches the namespace set for this Strophe.Handler.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element to test.
             *
             *  Returns:
             *    true if the stanza matches and false otherwise.
             */
            namespaceMatch: function (elem) {
                var nsMatch = false;
                if (!this.ns) {
                    return true;
                } else {
                    var that = this;
                    Strophe.forEachChild(elem, null, function (elem) {
                        if (that.getNamespace(elem) === that.ns) {
                            nsMatch = true;
                        }
                    });
                    nsMatch = nsMatch || this.getNamespace(elem) === this.ns;
                }
                return nsMatch;
            },

            /** PrivateFunction: isMatch
             *  Tests if a stanza matches the Strophe.Handler.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element to test.
             *
             *  Returns:
             *    true if the stanza matches and false otherwise.
             */
            isMatch: function (elem) {
                var from = elem.getAttribute('from');
                if (this.options.matchBareFromJid) {
                    from = Strophe.getBareJidFromJid(from);
                }
                var elem_type = elem.getAttribute("type");
                if (this.namespaceMatch(elem) &&
                    (!this.name || Strophe.isTagEqual(elem, this.name)) &&
                    (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&
                    (!this.id || elem.getAttribute("id") == this.id) &&
                    (!this.from || from == this.from)) {
                    return true;
                }
                return false;
            },

            /** PrivateFunction: run
             *  Run the callback on a matching stanza.
             *
             *  Parameters:
             *    (XMLElement) elem - The DOM element that triggered the
             *      Strophe.Handler.
             *
             *  Returns:
             *    A boolean indicating if the handler should remain active.
             */
            run: function (elem) {
                var result = null;
                try {
                    result = this.handler(elem);
                } catch (e) {
                    Strophe._handleError(e);
                    throw e;
                }
                return result;
            },

            /** PrivateFunction: toString
             *  Get a String representation of the Strophe.Handler object.
             *
             *  Returns:
             *    A String.
             */
            toString: function () {
                return "{Handler: " + this.handler + "(" + this.name + "," +
                    this.id + "," + this.ns + ")}";
            }
        };

        /** PrivateClass: Strophe.TimedHandler
         *  _Private_ helper class for managing timed handlers.
         *
         *  A Strophe.TimedHandler encapsulates a user provided callback that
         *  should be called after a certain period of time or at regular
         *  intervals.  The return value of the callback determines whether the
         *  Strophe.TimedHandler will continue to fire.
         *
         *  Users will not use Strophe.TimedHandler objects directly, but instead
         *  they will use Strophe.Connection.addTimedHandler() and
         *  Strophe.Connection.deleteTimedHandler().
         */

        /** PrivateConstructor: Strophe.TimedHandler
         *  Create and initialize a new Strophe.TimedHandler object.
         *
         *  Parameters:
         *    (Integer) period - The number of milliseconds to wait before the
         *      handler is called.
         *    (Function) handler - The callback to run when the handler fires.  This
         *      function should take no arguments.
         *
         *  Returns:
         *    A new Strophe.TimedHandler object.
         */
        Strophe.TimedHandler = function (period, handler) {
            this.period = period;
            this.handler = handler;
            this.lastCalled = new Date().getTime();
            this.user = true;
        };

        Strophe.TimedHandler.prototype = {
            /** PrivateFunction: run
             *  Run the callback for the Strophe.TimedHandler.
             *
             *  Returns:
             *    true if the Strophe.TimedHandler should be called again, and false
             *      otherwise.
             */
            run: function () {
                this.lastCalled = new Date().getTime();
                return this.handler();
            },

            /** PrivateFunction: reset
             *  Reset the last called time for the Strophe.TimedHandler.
             */
            reset: function () {
                this.lastCalled = new Date().getTime();
            },

            /** PrivateFunction: toString
             *  Get a string representation of the Strophe.TimedHandler object.
             *
             *  Returns:
             *    The string representation.
             */
            toString: function () {
                return "{TimedHandler: " + this.handler + "(" + this.period +")}";
            }
        };

        /** Class: Strophe.Connection
         *  XMPP Connection manager.
         *
         *  This class is the main part of Strophe.  It manages a BOSH or websocket
         *  connection to an XMPP server and dispatches events to the user callbacks
         *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
         *  and legacy authentication.
         *
         *  After creating a Strophe.Connection object, the user will typically
         *  call connect() with a user supplied callback to handle connection level
         *  events like authentication failure, disconnection, or connection
         *  complete.
         *
         *  The user will also have several event handlers defined by using
         *  addHandler() and addTimedHandler().  These will allow the user code to
         *  respond to interesting stanzas or do something periodically with the
         *  connection. These handlers will be active once authentication is
         *  finished.
         *
         *  To send data to the connection, use send().
         */

        /** Constructor: Strophe.Connection
         *  Create and initialize a Strophe.Connection object.
         *
         *  The transport-protocol for this connection will be chosen automatically
         *  based on the given service parameter. URLs starting with "ws://" or
         *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
         *  or without a protocol will use BOSH.
         *
         *  To make Strophe connect to the current host you can leave out the protocol
         *  and host part and just pass the path, e.g.
         *
         *  > var conn = new Strophe.Connection("/http-bind/");
         *
         *  Options common to both Websocket and BOSH:
         *  ------------------------------------------
         *
         *  cookies:
         *
         *  The *cookies* option allows you to pass in cookies to be added to the
         *  document. These cookies will then be included in the BOSH XMLHttpRequest
         *  or in the websocket connection.
         *
         *  The passed in value must be a map of cookie names and string values.
         *
         *  > { "myCookie": {
 *  >     "value": "1234",
 *  >     "domain": ".example.org",
 *  >     "path": "/",
 *  >     "expires": expirationDate
 *  >     }
 *  > }
         *
         *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).
         *  Those cookies need to be set under those domains, for example they can be
         *  set server-side by making a XHR call to that domain to ask it to set any
         *  necessary cookies.
         *
         *  mechanisms:
         *
         *  The *mechanisms* option allows you to specify the SASL mechanisms that this
         *  instance of Strophe.Connection (and therefore your XMPP client) will
         *  support.
         *
         *  The value must be an array of objects with Strophe.SASLMechanism
         *  prototypes.
         *
         *  If nothing is specified, then the following mechanisms (and their
         *  priorities) are registered:
         *
         *      OAUTHBEARER - 60
         *      SCRAM-SHA1 - 50
         *      DIGEST-MD5 - 40
         *      PLAIN - 30
         *      ANONYMOUS - 20
         *      EXTERNAL - 10
         *
         *  WebSocket options:
         *  ------------------
         *
         *  If you want to connect to the current host with a WebSocket connection you
         *  can tell Strophe to use WebSockets through a "protocol" attribute in the
         *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
         *  for Secure WebSocket.
         *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
         *
         *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
         *
         *  Note that relative URLs _NOT_ starting with a "/" will also include the path
         *  of the current site.
         *
         *  Also because downgrading security is not permitted by browsers, when using
         *  relative URLs both BOSH and WebSocket connections will use their secure
         *  variants if the current connection to the site is also secure (https).
         *
         *  BOSH options:
         *  -------------
         *
         *  By adding "sync" to the options, you can control if requests will
         *  be made synchronously or not. The default behaviour is asynchronous.
         *  If you want to make requests synchronous, make "sync" evaluate to true.
         *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
         *
         *  You can also toggle this on an already established connection.
         *  > conn.options.sync = true;
         *
         *  The *customHeaders* option can be used to provide custom HTTP headers to be
         *  included in the XMLHttpRequests made.
         *
         *  The *keepalive* option can be used to instruct Strophe to maintain the
         *  current BOSH session across interruptions such as webpage reloads.
         *
         *  It will do this by caching the sessions tokens in sessionStorage, and when
         *  "restore" is called it will check whether there are cached tokens with
         *  which it can resume an existing session.
         *
         *  The *withCredentials* option should receive a Boolean value and is used to
         *  indicate wether cookies should be included in ajax requests (by default
         *  they're not).
         *  Set this value to true if you are connecting to a BOSH service
         *  and for some reason need to send cookies to it.
         *  In order for this to work cross-domain, the server must also enable
         *  credentials by setting the Access-Control-Allow-Credentials response header
         *  to "true". For most usecases however this setting should be false (which
         *  is the default).
         *  Additionally, when using Access-Control-Allow-Credentials, the
         *  Access-Control-Allow-Origin header can't be set to the wildcard "*", but
         *  instead must be restricted to actual domains.
         *
         *  The *contentType* option can be set to change the default Content-Type
         *  of "text/xml; charset=utf-8", which can be useful to reduce the amount of
         *  CORS preflight requests that are sent to the server.
         *
         *  Parameters:
         *    (String) service - The BOSH or WebSocket service URL.
         *    (Object) options - A hash of configuration options
         *
         *  Returns:
         *    A new Strophe.Connection object.
         */
        Strophe.Connection = function (service, options) {
            // The service URL
            this.service = service;
            // Configuration options
            this.options = options || {};
            var proto = this.options.protocol || "";

            // Select protocal based on service or options
            if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
                proto.indexOf("ws") === 0) {
                this._proto = new Strophe.Websocket(this);
            } else {
                this._proto = new Strophe.Bosh(this);
            }

            /* The connected JID. */
            this.jid = "";
            /* the JIDs domain */
            this.domain = null;
            /* stream:features */
            this.features = null;

            // SASL
            this._sasl_data = {};
            this.do_session = false;
            this.do_bind = false;

            // handler lists
            this.timedHandlers = [];
            this.handlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = [];
            this.protocolErrorHandlers = {
                'HTTP': {},
                'websocket': {}
            };

            this._idleTimeout = null;
            this._disconnectTimeout = null;

            this.authenticated = false;
            this.connected = false;
            this.disconnecting = false;
            this.do_authentication = true;
            this.paused = false;
            this.restored = false;

            this._data = [];
            this._uniqueId = 0;

            this._sasl_success_handler = null;
            this._sasl_failure_handler = null;
            this._sasl_challenge_handler = null;

            // Max retries before disconnecting
            this.maxRetries = 5;

            // Call onIdle callback every 1/10th of a second
            // XXX: setTimeout should be called only with function expressions (23974bc1)
            this._idleTimeout = setTimeout(function() {
                this._onIdle();
            }.bind(this), 100);

            utils.addCookies(this.options.cookies);
            this.registerSASLMechanisms(this.options.mechanisms);

            // initialize plugins
            for (var k in Strophe._connectionPlugins) {
                if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                    var ptype = Strophe._connectionPlugins[k];
                    // jslint complaints about the below line, but this is fine
                    var F = function () {}; // jshint ignore:line
                    F.prototype = ptype;
                    this[k] = new F();
                    this[k].init(this);
                }
            }
        };

        Strophe.Connection.prototype = {
            /** Function: reset
             *  Reset the connection.
             *
             *  This function should be called after a connection is disconnected
             *  before that connection is reused.
             */
            reset: function () {
                this._proto._reset();

                // SASL
                this.do_session = false;
                this.do_bind = false;

                // handler lists
                this.timedHandlers = [];
                this.handlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];

                this.authenticated = false;
                this.connected = false;
                this.disconnecting = false;
                this.restored = false;

                // If set to true override stanza will be sent before bind
                this.override = false;

                this._data = [];
                this._requests = [];
                this._uniqueId = 0;
            },

            /** Function: pause
             *  Pause the request manager.
             *
             *  This will prevent Strophe from sending any more requests to the
             *  server.  This is very useful for temporarily pausing
             *  BOSH-Connections while a lot of send() calls are happening quickly.
             *  This causes Strophe to send the data in a single request, saving
             *  many request trips.
             */
            pause: function () {
                this.paused = true;
            },

            /** Function: resume
             *  Resume the request manager.
             *
             *  This resumes after pause() has been called.
             */
            resume: function () {
                this.paused = false;
            },

            /** Function: getUniqueId
             *  Generate a unique ID for use in <iq/> elements.
             *
             *  All <iq/> stanzas are required to have unique id attributes.  This
             *  function makes creating these easy.  Each connection instance has
             *  a counter which starts from zero, and the value of this counter
             *  plus a colon followed by the suffix becomes the unique id. If no
             *  suffix is supplied, the counter is used as the unique id.
             *
             *  Suffixes are used to make debugging easier when reading the stream
             *  data, and their use is recommended.  The counter resets to 0 for
             *  every new connection for the same reason.  For connections to the
             *  same server that authenticate the same way, all the ids should be
             *  the same, which makes it easy to see changes.  This is useful for
             *  automated testing as well.
             *
             *  Parameters:
             *    (String) suffix - A optional suffix to append to the id.
             *
             *  Returns:
             *    A unique string to be used for the id attribute.
             */
            getUniqueId: function(suffix) {
                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0,
                        v = c == 'x' ? r : r & 0x3 | 0x8;
                    return v.toString(16);
                });
                if (typeof(suffix) == "string" || typeof(suffix) == "number") {
                    return uuid + ":" + suffix;
                } else {
                    return uuid + "";
                }
            },

            /** Function: addProtocolErrorHandler
             *  Register a handler function for when a protocol (websocker or HTTP)
             *  error occurs.
             *
             *  NOTE: Currently only HTTP errors for BOSH requests are handled.
             *  Patches that handle websocket errors would be very welcome.
             *
             *  Parameters:
             *    (String) protocol - 'HTTP' or 'websocket'
             *    (Integer) status_code - Error status code (e.g 500, 400 or 404)
             *    (Function) callback - Function that will fire on Http error
             *
             *  Example:
             *  function onError(err_code){
     *    //do stuff
     *  }
             *
             *  var conn = Strophe.connect('http://example.com/http-bind');
             *  conn.addProtocolErrorHandler('HTTP', 500, onError);
             *  // Triggers HTTP 500 error and onError handler will be called
             *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
             */
            addProtocolErrorHandler: function(protocol, status_code, callback){
                this.protocolErrorHandlers[protocol][status_code] = callback;
            },


            /** Function: connect
             *  Starts the connection process.
             *
             *  As the connection process proceeds, the user supplied callback will
             *  be triggered multiple times with status updates.  The callback
             *  should take two arguments - the status code and the error condition.
             *
             *  The status code will be one of the values in the Strophe.Status
             *  constants.  The error condition will be one of the conditions
             *  defined in RFC 3920 or the condition 'strophe-parsererror'.
             *
             *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
             *  for BOSH connections. Please see XEP 124 for a more detailed explanation
             *  of the optional parameters.
             *
             *  Parameters:
             *    (String) jid - The user's JID.  This may be a bare JID,
             *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
             *      authentication will be attempted.
             *    (String) pass - The user's password.
             *    (Function) callback - The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (String) route - The optional route value.
             *    (String) authcid - The optional alternative authentication identity
             *      (username) if intending to impersonate another user.
             *      When using the SASL-EXTERNAL authentication mechanism, for example
             *      with client certificates, then the authcid value is used to
             *      determine whether an authorization JID (authzid) should be sent to
             *      the server. The authzid should not be sent to the server if the
             *      authzid and authcid are the same. So to prevent it from being sent
             *      (for example when the JID is already contained in the client
             *      certificate), set authcid to that same JID. See XEP-178 for more
             *      details.
             */
            connect: function (jid, pass, callback, wait, hold, route, authcid) {

                this.jid = jid;
                /** Variable: authzid
                 *  Authorization identity.
                 */
                this.authzid = Strophe.getBareJidFromJid(this.jid);

                /** Variable: authcid
                 *  Authentication identity (User name).
                 */
                this.authcid = authcid || Strophe.getNodeFromJid(this.jid);

                /** Variable: pass
                 *  Authentication identity (User password).
                 */
                this.pass = pass;

                /** Variable: servtype
                 *  Digest MD5 compatibility.
                 */
                this.servtype = "xmpp";

                this.connect_callback = callback;
                this.disconnecting = false;
                this.connected = false;
                this.authenticated = false;
                this.restored = false;

                // parse jid for domain
                this.domain = Strophe.getDomainFromJid(this.jid);

                this._changeConnectStatus(Strophe.Status.CONNECTING, null);

                this._proto._connect(wait, hold, route);
            },

            /** Function: attach
             *  Attach to an already created and authenticated BOSH session.
             *
             *  This function is provided to allow Strophe to attach to BOSH
             *  sessions which have been created externally, perhaps by a Web
             *  application.  This is often used to support auto-login type features
             *  without putting user credentials into the page.
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *    (String) sid - The SID of the BOSH session.
             *    (String) rid - The current RID of the BOSH session.  This RID
             *      will be used by the next request.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            attach: function (jid, sid, rid, callback, wait, hold, wind) {
                if (this._proto instanceof Strophe.Bosh) {
                    this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
                } else {
                    throw {
                        name: 'StropheSessionError',
                        message: 'The "attach" method can only be used with a BOSH connection.'
                    };
                }
            },

            /** Function: restore
             *  Attempt to restore a cached BOSH session.
             *
             *  This function is only useful in conjunction with providing the
             *  "keepalive":true option when instantiating a new Strophe.Connection.
             *
             *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
             *  RID (Request ID) and SID (Session ID) and then when this function is
             *  called, it will attempt to restore the session from those cached
             *  tokens.
             *
             *  This function must therefore be called instead of connect or attach.
             *
             *  For an example on how to use it, please see examples/restore.js
             *
             *  Parameters:
             *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
             *    (Function) callback - The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            restore: function (jid, callback, wait, hold, wind) {
                if (this._sessionCachingSupported()) {
                    this._proto._restore(jid, callback, wait, hold, wind);
                } else {
                    throw {
                        name: 'StropheSessionError',
                        message: 'The "restore" method can only be used with a BOSH connection.'
                    };
                }
            },

            /** PrivateFunction: _sessionCachingSupported
             * Checks whether sessionStorage and JSON are supported and whether we're
             * using BOSH.
             */
            _sessionCachingSupported: function () {
                if (this._proto instanceof Strophe.Bosh) {
                    if (!JSON) { return false; }
                    try {
                        window.sessionStorage.setItem('_strophe_', '_strophe_');
                        window.sessionStorage.removeItem('_strophe_');
                    } catch (e) {
                        return false;
                    }
                    return true;
                }
                return false;
            },

            /** Function: xmlInput
             *  User overrideable function that receives XML data coming into the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
             *
             *  Due to limitations of current Browsers' XML-Parsers the opening and closing
             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
             *  <Strophe.Bosh.strip> if you want to strip this tag.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML data received by the connection.
             */
            /* jshint unused:false */
            xmlInput: function (elem) {
                return;
            },
            /* jshint unused:true */

            /** Function: xmlOutput
             *  User overrideable function that receives XML data sent to the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
             *
             *  Due to limitations of current Browsers' XML-Parsers the opening and closing
             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
             *  <Strophe.Bosh.strip> if you want to strip this tag.
             *
             *  Parameters:
             *    (XMLElement) elem - The XMLdata sent by the connection.
             */
            /* jshint unused:false */
            xmlOutput: function (elem) {
                return;
            },
            /* jshint unused:true */

            /** Function: rawInput
             *  User overrideable function that receives raw data coming into the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
             *
             *  Parameters:
             *    (String) data - The data received by the connection.
             */
            /* jshint unused:false */
            rawInput: function (data) {
                return;
            },
            /* jshint unused:true */

            /** Function: rawOutput
             *  User overrideable function that receives raw data sent to the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
             *
             *  Parameters:
             *    (String) data - The data sent by the connection.
             */
            /* jshint unused:false */
            rawOutput: function (data) {
                return;
            },
            /* jshint unused:true */

            /** Function: nextValidRid
             *  User overrideable function that receives the new valid rid.
             *
             *  The default function does nothing. User code can override this with
             *  > Strophe.Connection.nextValidRid = function (rid) {
     *  >    (user code)
     *  > };
             *
             *  Parameters:
             *    (Number) rid - The next valid rid
             */
            /* jshint unused:false */
            nextValidRid: function (rid) {
                return;
            },
            /* jshint unused:true */

            /** Function: send
             *  Send a stanza.
             *
             *  This function is called to push data onto the send queue to
             *  go out over the wire.  Whenever a request is sent to the BOSH
             *  server, all pending data is sent and the queue is flushed.
             *
             *  Parameters:
             *    (XMLElement |
             *     [XMLElement] |
             *     Strophe.Builder) elem - The stanza to send.
             */
            send: function (elem) {
                if (elem === null) { return ; }
                if (typeof(elem.sort) === "function") {
                    for (var i = 0; i < elem.length; i++) {
                        this._queueData(elem[i]);
                    }
                } else if (typeof(elem.tree) === "function") {
                    this._queueData(elem.tree());
                } else {
                    this._queueData(elem);
                }

                this._proto._send();
            },

            /** Function: flush
             *  Immediately send any pending outgoing data.
             *
             *  Normally send() queues outgoing data until the next idle period
             *  (100ms), which optimizes network use in the common cases when
             *  several send()s are called in succession. flush() can be used to
             *  immediately send all pending data.
             */
            flush: function () {
                // cancel the pending idle period and run the idle function
                // immediately
                clearTimeout(this._idleTimeout);
                this._onIdle();
            },

            /** Function: sendPresence
             *  Helper function to send presence stanzas. The main benefit is for
             *  sending presence stanzas for which you expect a responding presence
             *  stanza with the same id (for example when leaving a chat room).
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza to send.
             *    (Function) callback - The callback function for a successful request.
             *    (Function) errback - The callback function for a failed or timed
             *      out request.  On timeout, the stanza will be null.
             *    (Integer) timeout - The time specified in milliseconds for a
             *      timeout to occur.
             *
             *  Returns:
             *    The id used to send the presence.
             */
            sendPresence: function(elem, callback, errback, timeout) {
                var timeoutHandler = null;
                var that = this;
                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }
                var id = elem.getAttribute('id');
                if (!id) { // inject id if not found
                    id = this.getUniqueId("sendPresence");
                    elem.setAttribute("id", id);
                }

                if (typeof callback === "function" || typeof errback === "function") {
                    var handler = this.addHandler(function (stanza) {
                        // remove timeout handler if there is one
                        if (timeoutHandler) {
                            that.deleteTimedHandler(timeoutHandler);
                        }
                        var type = stanza.getAttribute('type');
                        if (type == 'error') {
                            if (errback) {
                                errback(stanza);
                            }
                        } else if (callback) {
                            callback(stanza);
                        }
                    }, null, 'presence', null, id);

                    // if timeout specified, set up a timeout handler.
                    if (timeout) {
                        timeoutHandler = this.addTimedHandler(timeout, function () {
                            // get rid of normal handler
                            that.deleteHandler(handler);
                            // call errback on timeout with null stanza
                            if (errback) {
                                errback(null);
                            }
                            return false;
                        });
                    }
                }
                this.send(elem);
                return id;
            },

            /** Function: sendIQ
             *  Helper function to send IQ stanzas.
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza to send.
             *    (Function) callback - The callback function for a successful request.
             *    (Function) errback - The callback function for a failed or timed
             *      out request.  On timeout, the stanza will be null.
             *    (Integer) timeout - The time specified in milliseconds for a
             *      timeout to occur.
             *
             *  Returns:
             *    The id used to send the IQ.
             */
            sendIQ: function(elem, callback, errback, timeout) {
                var timeoutHandler = null;
                var that = this;
                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }
                var id = elem.getAttribute('id');
                if (!id) { // inject id if not found
                    id = this.getUniqueId("sendIQ");
                    elem.setAttribute("id", id);
                }

                if (typeof callback === "function" || typeof errback === "function") {
                    var handler = this.addHandler(function (stanza) {
                        // remove timeout handler if there is one
                        if (timeoutHandler) {
                            that.deleteTimedHandler(timeoutHandler);
                        }
                        var iqtype = stanza.getAttribute('type');
                        if (iqtype == 'result') {
                            if (callback) {
                                callback(stanza);
                            }
                        } else if (iqtype == 'error') {
                            if (errback) {
                                errback(stanza);
                            }
                        } else {
                            throw {
                                name: "StropheError",
                                message: "Got bad IQ type of " + iqtype
                            };
                        }
                    }, null, 'iq', ['error', 'result'], id);

                    // if timeout specified, set up a timeout handler.
                    if (timeout) {
                        timeoutHandler = this.addTimedHandler(timeout, function () {
                            // get rid of normal handler
                            that.deleteHandler(handler);
                            // call errback on timeout with null stanza
                            if (errback) {
                                errback(null);
                            }
                            return false;
                        });
                    }
                }
                this.send(elem);
                return id;
            },

            /** PrivateFunction: _queueData
             *  Queue outgoing data for later sending.  Also ensures that the data
             *  is a DOMElement.
             */
            _queueData: function (element) {
                if (element === null ||
                    !element.tagName ||
                    !element.childNodes) {
                    throw {
                        name: "StropheError",
                        message: "Cannot queue non-DOMElement."
                    };
                }
                this._data.push(element);
            },

            /** PrivateFunction: _sendRestart
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function () {
                this._data.push("restart");
                this._proto._sendRestart();
                // XXX: setTimeout should be called only with function expressions (23974bc1)
                this._idleTimeout = setTimeout(function() {
                    this._onIdle();
                }.bind(this), 100);
            },

            /** Function: addTimedHandler
             *  Add a timed handler to the connection.
             *
             *  This function adds a timed handler.  The provided handler will
             *  be called every period milliseconds until it returns false,
             *  the connection is terminated, or the handler is removed.  Handlers
             *  that wish to continue being invoked should return true.
             *
             *  Because of method binding it is necessary to save the result of
             *  this function if you wish to remove a handler with
             *  deleteTimedHandler().
             *
             *  Note that user handlers are not active until authentication is
             *  successful.
             *
             *  Parameters:
             *    (Integer) period - The period of the handler.
             *    (Function) handler - The callback function.
             *
             *  Returns:
             *    A reference to the handler that can be used to remove it.
             */
            addTimedHandler: function (period, handler) {
                var thand = new Strophe.TimedHandler(period, handler);
                this.addTimeds.push(thand);
                return thand;
            },

            /** Function: deleteTimedHandler
             *  Delete a timed handler for a connection.
             *
             *  This function removes a timed handler from the connection.  The
             *  handRef parameter is *not* the function passed to addTimedHandler(),
             *  but is the reference returned from addTimedHandler().
             *
             *  Parameters:
             *    (Strophe.TimedHandler) handRef - The handler reference.
             */
            deleteTimedHandler: function (handRef) {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeTimeds.push(handRef);
            },

            /** Function: addHandler
             *  Add a stanza handler for the connection.
             *
             *  This function adds a stanza handler to the connection.  The
             *  handler callback will be called for any stanza that matches
             *  the parameters.  Note that if multiple parameters are supplied,
             *  they must all match for the handler to be invoked.
             *
             *  The handler will receive the stanza that triggered it as its argument.
             *  *The handler should return true if it is to be invoked again;
             *  returning false will remove the handler after it returns.*
             *
             *  As a convenience, the ns parameters applies to the top level element
             *  and also any of its immediate children.  This is primarily to make
             *  matching /iq/query elements easy.
             *
             *  Options
             *  ~~~~~~~
             *  With the options argument, you can specify boolean flags that affect how
             *  matches are being done.
             *
             *  Currently two flags exist:
             *
             *  - matchBareFromJid:
             *      When set to true, the from parameter and the
             *      from attribute on the stanza will be matched as bare JIDs instead
             *      of full JIDs. To use this, pass {matchBareFromJid: true} as the
             *      value of options. The default value for matchBareFromJid is false.
             *
             *  - ignoreNamespaceFragment:
             *      When set to true, a fragment specified on the stanza's namespace
             *      URL will be ignored when it's matched with the one configured for
             *      the handler.
             *
             *      This means that if you register like this:
             *      >   connection.addHandler(
             *      >       handler,
             *      >       'http://jabber.org/protocol/muc',
             *      >       null, null, null, null,
             *      >       {'ignoreNamespaceFragment': true}
             *      >   );
             *
             *      Then a stanza with XML namespace of
             *      'http://jabber.org/protocol/muc#user' will also be matched. If
             *      'ignoreNamespaceFragment' is false, then only stanzas with
             *      'http://jabber.org/protocol/muc' will be matched.
             *
             *  Deleting the handler
             *  ~~~~~~~~~~~~~~~~~~~~
             *  The return value should be saved if you wish to remove the handler
             *  with deleteHandler().
             *
             *  Parameters:
             *    (Function) handler - The user callback.
             *    (String) ns - The namespace to match.
             *    (String) name - The stanza name to match.
             *    (String|Array) type - The stanza type (or types if an array) to match.
             *    (String) id - The stanza id attribute to match.
             *    (String) from - The stanza from attribute to match.
             *    (String) options - The handler options
             *
             *  Returns:
             *    A reference to the handler that can be used to remove it.
             */
            addHandler: function (handler, ns, name, type, id, from, options) {
                var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
                this.addHandlers.push(hand);
                return hand;
            },

            /** Function: deleteHandler
             *  Delete a stanza handler for a connection.
             *
             *  This function removes a stanza handler from the connection.  The
             *  handRef parameter is *not* the function passed to addHandler(),
             *  but is the reference returned from addHandler().
             *
             *  Parameters:
             *    (Strophe.Handler) handRef - The handler reference.
             */
            deleteHandler: function (handRef) {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeHandlers.push(handRef);
                // If a handler is being deleted while it is being added,
                // prevent it from getting added
                var i = this.addHandlers.indexOf(handRef);
                if (i >= 0) {
                    this.addHandlers.splice(i, 1);
                }
            },

            /** Function: registerSASLMechanisms
             *
             * Register the SASL mechanisms which will be supported by this instance of
             * Strophe.Connection (i.e. which this XMPP client will support).
             *
             *  Parameters:
             *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes
             *
             */
            registerSASLMechanisms: function (mechanisms) {
                this.mechanisms = {};
                mechanisms = mechanisms || [
                        Strophe.SASLAnonymous,
                        Strophe.SASLExternal,
                        Strophe.SASLMD5,
                        Strophe.SASLOAuthBearer,
                        Strophe.SASLPlain,
                        Strophe.SASLSHA1
                    ];
                mechanisms.forEach(this.registerSASLMechanism.bind(this));
            },

            /** Function: registerSASLMechanism
             *
             * Register a single SASL mechanism, to be supported by this client.
             *
             *  Parameters:
             *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype
             *
             */
            registerSASLMechanism: function (mechanism) {
                this.mechanisms[mechanism.prototype.name] = mechanism;
            },

            /** Function: disconnect
             *  Start the graceful disconnection process.
             *
             *  This function starts the disconnection process.  This process starts
             *  by sending unavailable presence and sending BOSH body of type
             *  terminate.  A timeout handler makes sure that disconnection happens
             *  even if the BOSH server does not respond.
             *  If the Connection object isn't connected, at least tries to abort all pending requests
             *  so the connection object won't generate successful requests (which were already opened).
             *
             *  The user supplied connection callback will be notified of the
             *  progress as this process happens.
             *
             *  Parameters:
             *    (String) reason - The reason the disconnect is occuring.
             */
            disconnect: function (reason, dontClose) {                
                Strophe.info("Disconnect was called because: " + reason);
                if (this.connected) {
                    this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
                    var pres = false;
                    this.disconnecting = true;
                    if (this.authenticated) {
                        pres = $pres({
                            xmlns: Strophe.NS.CLIENT,
                            type: 'unavailable'
                        });
                    }
                    // setup timeout handler
                    this._disconnectTimeout = this._addSysTimedHandler(
                        3000, this._onDisconnectTimeout.bind(this));
                    this._proto._disconnect(pres, dontClose);
                } else {
                    Strophe.info("Disconnect was called before Strophe connected to the server");
                    this._proto._abortAllRequests();
                    this._doDisconnect(reason);
                }
            },

            /** PrivateFunction: _changeConnectStatus
             *  _Private_ helper function that makes sure plugins and the user's
             *  callback are notified of connection status changes.
             *
             *  Parameters:
             *    (Integer) status - the new connection status, one of the values
             *      in Strophe.Status
             *    (String) condition - the error condition or null
             */
            _changeConnectStatus: function (status, condition) {
                // notify all plugins listening for status changes
                for (var k in Strophe._connectionPlugins) {
                    if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                        var plugin = this[k];
                        if (plugin.statusChanged) {
                            try {
                                plugin.statusChanged(status, condition);
                            } catch (err) {
                                Strophe.error("" + k + " plugin caused an exception " +
                                    "changing status: " + err);
                            }
                        }
                    }
                }

                // notify the user's callback
                if (this.connect_callback) {
                    try {
                        this.connect_callback(status, condition);
                    } catch (e) {
                        Strophe._handleError(e);
                        Strophe.error(
                            "User connection callback caused an "+"exception: "+e);
                    }
                }
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  This is the last piece of the disconnection logic.  This resets the
             *  connection and alerts the user's connection callback.
             */
            _doDisconnect: function (condition) {
                if (typeof this._idleTimeout == "number") {
                    clearTimeout(this._idleTimeout);
                }

                // Cancel Disconnect Timeout
                if (this._disconnectTimeout !== null) {
                    this.deleteTimedHandler(this._disconnectTimeout);
                    this._disconnectTimeout = null;
                }

                Strophe.info("_doDisconnect was called");
                this._proto._doDisconnect();

                this.authenticated = false;
                this.disconnecting = false;
                this.restored = false;

                // delete handlers
                this.handlers = [];
                this.timedHandlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];

                // tell the parent we disconnected
                this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
                this.connected = false;
            },

            /** PrivateFunction: _dataRecv
             *  _Private_ handler to processes incoming data from the the connection.
             *
             *  Except for _connect_cb handling the initial connection request,
             *  this function handles the incoming data for all requests.  This
             *  function also fires stanza handlers that match each incoming
             *  stanza.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request that has data ready.
             *    (string) req - The stanza a raw string (optiona).
             */
            _dataRecv: function (req, raw) {
                Strophe.info("_dataRecv called");
                var elem = this._proto._reqToData(req);
                if (elem === null) { return; }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                    if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                        this.xmlInput(elem.childNodes[0]);
                    } else {
                        this.xmlInput(elem);
                    }
                }
                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                    if (raw) {
                        this.rawInput(raw);
                    } else {
                        this.rawInput(Strophe.serialize(elem));
                    }
                }

                // remove handlers scheduled for deletion
                var i, hand;
                while (this.removeHandlers.length > 0) {
                    hand = this.removeHandlers.pop();
                    i = this.handlers.indexOf(hand);
                    if (i >= 0) {
                        this.handlers.splice(i, 1);
                    }
                }

                // add handlers scheduled for addition
                while (this.addHandlers.length > 0) {
                    this.handlers.push(this.addHandlers.pop());
                }

                // handle graceful disconnect
                if (this.disconnecting && this._proto._emptyQueue()) {
                    this._doDisconnect();
                    return;
                }

                var type = elem.getAttribute("type");
                var cond, conflict;
                if (type !== null && type == "terminate") {
                    // Don't process stanzas that come in after disconnect
                    if (this.disconnecting) {
                        return;
                    }

                    // an error occurred
                    cond = elem.getAttribute("condition");
                    conflict = elem.getElementsByTagName("conflict");
                    if (cond !== null) {
                        if (cond == "remote-stream-error" && conflict.length > 0) {
                            cond = "conflict";
                        }
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                    } else {
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                    }
                    this._doDisconnect(cond);
                    return;
                }

                // send each incoming stanza through the handler chain
                var that = this;
                Strophe.forEachChild(elem, null, function (child) {
                    var i, newList;
                    // process handlers
                    newList = that.handlers;
                    that.handlers = [];
                    for (i = 0; i < newList.length; i++) {
                        var hand = newList[i];
                        // encapsulate 'handler.run' not to lose the whole handler list if
                        // one of the handlers throws an exception
                        try {
                            if (hand.isMatch(child) &&
                                (that.authenticated || !hand.user)) {
                                if (hand.run(child)) {
                                    that.handlers.push(hand);
                                }
                            } else {
                                that.handlers.push(hand);
                            }
                        } catch(e) {
                            // if the handler throws an exception, we consider it as false
                            Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);
                        }
                    }
                });
            },


            /** Attribute: mechanisms
             *  SASL Mechanisms available for Connection.
             */
            mechanisms: {},

            /** PrivateFunction: _connect_cb
             *  _Private_ handler for initial connection request.
             *
             *  This handler is used to process the initial connection request
             *  response from the BOSH server. It is used to set up authentication
             *  handlers and start the authentication process.
             *
             *  SASL authentication will be attempted if available, otherwise
             *  the code will fall back to legacy authentication.
             *
             *  Parameters:
             *    (Strophe.Request) req - The current request.
             *    (Function) _callback - low level (xmpp) connect callback function.
             *      Useful for plugins with their own xmpp connect callback (when their)
             *      want to do something special).
             */
            _connect_cb: function (req, _callback, raw) {
                Strophe.info("_connect_cb was called");
                this.connected = true;

                var bodyWrap;
                try {
                    bodyWrap = this._proto._reqToData(req);
                } catch (e) {
                    if (e != "badformat") { throw e; }
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
                    this._doDisconnect('bad-format');
                }
                if (!bodyWrap) { return; }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                    if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                        this.xmlInput(bodyWrap.childNodes[0]);
                    } else {
                        this.xmlInput(bodyWrap);
                    }
                }
                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                    if (raw) {
                        this.rawInput(raw);
                    } else {
                        this.rawInput(Strophe.serialize(bodyWrap));
                    }
                }

                var conncheck = this._proto._connect_cb(bodyWrap);
                if (conncheck === Strophe.Status.CONNFAIL) {
                    return;
                }

                // Check for the stream:features tag
                var hasFeatures;
                if (bodyWrap.getElementsByTagNameNS) {
                    hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
                } else {
                    hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 ||
                        bodyWrap.getElementsByTagName("features").length > 0;
                }
                if (!hasFeatures) {
                    this._proto._no_auth_received(_callback);
                    return;
                }

                var matched = [], i, mech;
                var mechanisms = bodyWrap.getElementsByTagName("mechanism");
                if (mechanisms.length > 0) {
                    for (i = 0; i < mechanisms.length; i++) {
                        mech = Strophe.getText(mechanisms[i]);
                        if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
                    }
                }
                if (matched.length === 0) {
                    if (bodyWrap.getElementsByTagName("auth").length === 0) {
                        // There are no matching SASL mechanisms and also no legacy
                        // auth available.
                        this._proto._no_auth_received(_callback);
                        return;
                    }
                }
                if (this.do_authentication !== false) {
                    this.authenticate(matched);
                }
            },

            /** Function: sortMechanismsByPriority
             *
             *  Sorts an array of objects with prototype SASLMechanism according to
             *  their priorities.
             *
             *  Parameters:
             *    (Array) mechanisms - Array of SASL mechanisms.
             *
             */
            sortMechanismsByPriority: function (mechanisms) {
                // Sorting mechanisms according to priority.
                var i, j, higher, swap;
                for (i = 0; i < mechanisms.length - 1; ++i) {
                    higher = i;
                    for (j = i + 1; j < mechanisms.length; ++j) {
                        if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {
                            higher = j;
                        }
                    }
                    if (higher != i) {
                        swap = mechanisms[i];
                        mechanisms[i] = mechanisms[higher];
                        mechanisms[higher] = swap;
                    }
                }
                return mechanisms;
            },

            /** PrivateFunction: _attemptSASLAuth
             *
             *  Iterate through an array of SASL mechanisms and attempt authentication
             *  with the highest priority (enabled) mechanism.
             *
             *  Parameters:
             *    (Array) mechanisms - Array of SASL mechanisms.
             *
             *  Returns:
             *    (Boolean) mechanism_found - true or false, depending on whether a
             *          valid SASL mechanism was found with which authentication could be
             *          started.
             */
            _attemptSASLAuth: function (mechanisms) {
                mechanisms = this.sortMechanismsByPriority(mechanisms || []);
                var i = 0, mechanism_found = false;
                for (i = 0; i < mechanisms.length; ++i) {
                    if (!mechanisms[i].prototype.test(this)) {
                        continue;
                    }
                    this._sasl_success_handler = this._addSysHandler(
                        this._sasl_success_cb.bind(this), null,
                        "success", null, null);
                    this._sasl_failure_handler = this._addSysHandler(
                        this._sasl_failure_cb.bind(this), null,
                        "failure", null, null);
                    this._sasl_challenge_handler = this._addSysHandler(
                        this._sasl_challenge_cb.bind(this), null,
                        "challenge", null, null);

                    this._sasl_mechanism = new mechanisms[i]();
                    this._sasl_mechanism.onStart(this);

                    var request_auth_exchange = $build("auth", {
                        xmlns: Strophe.NS.SASL,
                        mechanism: this._sasl_mechanism.name
                    });
                    if (this._sasl_mechanism.isClientFirst) {
                        var response = this._sasl_mechanism.onChallenge(this, null);
                        request_auth_exchange.t(Base64.encode(response));
                    }
                    this.send(request_auth_exchange.tree());
                    mechanism_found = true;
                    break;
                }
                return mechanism_found;
            },

            /** PrivateFunction: _attemptLegacyAuth
             *
             *  Attempt legacy (i.e. non-SASL) authentication.
             *
             */
            _attemptLegacyAuth: function () {
                if (Strophe.getNodeFromJid(this.jid) === null) {
                    // we don't have a node, which is required for non-anonymous
                    // client connections
                    this._changeConnectStatus(
                        Strophe.Status.CONNFAIL,
                        'x-strophe-bad-non-anon-jid'
                    );
                    this.disconnect('x-strophe-bad-non-anon-jid');
                } else {
                    // Fall back to legacy authentication
                    this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                    this._addSysHandler(
                        this._auth1_cb.bind(this),
                        null, null, null, "_auth_1"
                    );
                    this.send($iq({
                        'type': "get",
                        'to': this.domain,
                        'id': "_auth_1"
                    }).c("query", {xmlns: Strophe.NS.AUTH})
                        .c("username", {}).t(Strophe.getNodeFromJid(this.jid))
                        .tree());
                }
            },

            /** Function: authenticate
             * Set up authentication
             *
             *  Continues the initial connection request by setting up authentication
             *  handlers and starting the authentication process.
             *
             *  SASL authentication will be attempted if available, otherwise
             *  the code will fall back to legacy authentication.
             *
             *  Parameters:
             *    (Array) matched - Array of SASL mechanisms supported.
             *
             */
            authenticate: function (matched) {
                if (!this._attemptSASLAuth(matched)) {
                    this._attemptLegacyAuth();
                }
            },

            /** PrivateFunction: _sasl_challenge_cb
             *  _Private_ handler for the SASL challenge
             *
             */
            _sasl_challenge_cb: function(elem) {
                var challenge = Base64.decode(Strophe.getText(elem));
                var response = this._sasl_mechanism.onChallenge(this, challenge);
                var stanza = $build('response', {
                    'xmlns': Strophe.NS.SASL
                });
                if (response !== "") {
                    stanza.t(Base64.encode(response));
                }
                this.send(stanza.tree());
                return true;
            },

            /** PrivateFunction: _auth1_cb
             *  _Private_ handler for legacy authentication.
             *
             *  This handler is called in response to the initial <iq type='get'/>
             *  for legacy authentication.  It builds an authentication <iq/> and
             *  sends it, creating a handler (calling back to _auth2_cb()) to
             *  handle the result
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza that triggered the callback.
             *
             *  Returns:
             *    false to remove the handler.
             */
            /* jshint unused:false */
            _auth1_cb: function (elem) {
                // build plaintext auth iq
                var iq = $iq({type: "set", id: "_auth_2"})
                    .c('query', {xmlns: Strophe.NS.AUTH})
                    .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
                    .up()
                    .c('password').t(this.pass);

                if (!Strophe.getResourceFromJid(this.jid)) {
                    // since the user has not supplied a resource, we pick
                    // a default one here.  unlike other auth methods, the server
                    // cannot do this for us.
                    this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
                }
                iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

                this._addSysHandler(this._auth2_cb.bind(this), null,
                    null, null, "_auth_2");
                this.send(iq.tree());
                return false;
            },
            /* jshint unused:true */

            /** PrivateFunction: _sasl_success_cb
             *  _Private_ handler for succesful SASL authentication.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_success_cb: function (elem) {
                if (this._sasl_data["server-signature"]) {
                    var serverSignature;
                    var success = Base64.decode(Strophe.getText(elem));
                    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                    var matches = success.match(attribMatch);
                    if (matches[1] == "v") {
                        serverSignature = matches[2];
                    }

                    if (serverSignature != this._sasl_data["server-signature"]) {
                        // remove old handlers
                        this.deleteHandler(this._sasl_failure_handler);
                        this._sasl_failure_handler = null;
                        if (this._sasl_challenge_handler) {
                            this.deleteHandler(this._sasl_challenge_handler);
                            this._sasl_challenge_handler = null;
                        }

                        this._sasl_data = {};
                        return this._sasl_failure_cb(null);
                    }
                }
                Strophe.info("SASL authentication succeeded.");

                if (this._sasl_mechanism) {
                    this._sasl_mechanism.onSuccess();
                }

                // remove old handlers
                this.deleteHandler(this._sasl_failure_handler);
                this._sasl_failure_handler = null;
                if (this._sasl_challenge_handler) {
                    this.deleteHandler(this._sasl_challenge_handler);
                    this._sasl_challenge_handler = null;
                }

                var streamfeature_handlers = [];
                var wrapper = function(handlers, elem) {
                    while (handlers.length) {
                        this.deleteHandler(handlers.pop());
                    }
                    this._sasl_auth1_cb.bind(this)(elem);
                    return false;
                };
                streamfeature_handlers.push(this._addSysHandler(function(elem) {
                    wrapper.bind(this)(streamfeature_handlers, elem);
                }.bind(this), null, "stream:features", null, null));
                streamfeature_handlers.push(this._addSysHandler(function(elem) {
                    wrapper.bind(this)(streamfeature_handlers, elem);
                }.bind(this), Strophe.NS.STREAM, "features", null, null));

                // we must send an xmpp:restart now
                this._sendRestart();

                return false;
            },

            /** PrivateFunction: _sasl_auth1_cb
             *  _Private_ handler to start stream binding.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_auth1_cb: function (elem) {
                // save stream:features for future usage
                this.features = elem;
                var i, child;
                for (i = 0; i < elem.childNodes.length; i++) {
                    child = elem.childNodes[i];
                    if (child.nodeName == 'bind') {
                        this.do_bind = true;
                    }

                    if (child.nodeName == 'session') {
                        this.do_session = true;
                    }
                }

                if (!this.do_bind) {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                } else {

                    var that = this;

                    var _doBind = function () {
                        that._addSysHandler(that._sasl_bind_cb.bind(that), null, null, null, "_bind_auth_2");

                        // If we want to force a login (i.e. have the server ignore any rules which might prevent us from logging in)
                        // then we need to send an overide stanza
                        if (that.override) {
                            that.send($iq({type: "set", id: "_override_1"})
                                .c('override', {
                                    xmlns: "urn:commontime:infinity:bind",
                                    "resource-conflict": "closeold"
                                }).tree());
                            that.override = false;
                        }

                        var resource = Strophe.getResourceFromJid(that.jid);
                        if (resource) {
                            that.send($iq({type: "set", id: "_bind_auth_2"})
                                .c('bind', {xmlns: Strophe.NS.BIND})
                                .c('resource', {}).t(resource).tree());
                        } else {
                            that.send($iq({type: "set", id: "_bind_auth_2"})
                                .c('bind', {xmlns: Strophe.NS.BIND})
                                .tree());
                        }
                    };

                    // Can we resume the stream?
                    if (this.streamManagement !== undefined && this.streamManagement.prevId !== undefined) {
                        this._addSysHandler(function () {
                            // Server accepted the request so we are authenticated and connected
                            that.authenticated = true;
                            that._changeConnectStatus(Strophe.Status.CONNECTED, "resumed");
                            return false;
                        }, "urn:xmpp:sm:3", "resumed");
                        this._addSysHandler(function () {
                            // Server rejected the resumption request so go ahead and re-bind
                            _doBind();
                            return false;
                        }, "urn:xmpp:sm:3", "failed");
                        // Request to resume the previous stream
                        this.send($build("resume", {
                            xmlns: "urn:xmpp:sm:3",
                            previd: this.streamManagement.prevId,
                            h: this.streamManagement.getIncomingCounter() || 0
                        }));
                    } else {
                        // Nope so just continue with the usual process
                        _doBind();
                    }

                }
                return false;
            },

            /** PrivateFunction: _sasl_bind_cb
             *  _Private_ handler for binding result and session start.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_bind_cb: function (elem) {
                if (elem.getAttribute("type") == "error") {
                    Strophe.info("SASL binding failed.");
                    var conflict = elem.getElementsByTagName("conflict"), condition;
                    if (conflict.length > 0) {
                        condition = 'conflict';
                        this._doDisconnect(condition);
                    }
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                    return false;
                }

                // TODO - need to grab errors
                var bind = elem.getElementsByTagName("bind");
                var jidNode;
                if (bind.length > 0) {
                    // Grab jid
                    jidNode = bind[0].getElementsByTagName("jid");
                    if (jidNode.length > 0) {
                        this.jid = Strophe.getText(jidNode[0]);

                        if (this.do_session) {
                            this._addSysHandler(this._sasl_session_cb.bind(this),
                                null, null, null, "_session_auth_2");

                            this.send($iq({type: "set", id: "_session_auth_2"})
                                .c('session', {xmlns: Strophe.NS.SESSION})
                                .tree());
                        } else {
                            this.authenticated = true;
                            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                        }
                    }
                } else {
                    Strophe.info("SASL binding failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                }
            },

            /** PrivateFunction: _sasl_session_cb
             *  _Private_ handler to finish successful SASL connection.
             *
             *  This sets Connection.authenticated to true on success, which
             *  starts the processing of user handlers.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_session_cb: function (elem) {
                if (elem.getAttribute("type") == "result") {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") == "error") {
                    Strophe.info("Session creation failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                }
                return false;
            },

            /** PrivateFunction: _sasl_failure_cb
             *  _Private_ handler for SASL authentication failure.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            /* jshint unused:false */
            _sasl_failure_cb: function (elem) {

                // delete unneeded handlers
                if (this._sasl_success_handler) {
                    this.deleteHandler(this._sasl_success_handler);
                    this._sasl_success_handler = null;
                }
                if (this._sasl_challenge_handler) {
                    this.deleteHandler(this._sasl_challenge_handler);
                    this._sasl_challenge_handler = null;
                }

                if(this._sasl_mechanism)
                    this._sasl_mechanism.onFailure();

                const $text = elem.getElementsByTagName("text")[0];
                let condition = null;
                if ($text !== undefined) {
                    condition = $text.innerHTML || null;
                }

                this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                this.disconnect(condition);

                return false;
            },
            /* jshint unused:true */

            /** PrivateFunction: _auth2_cb
             *  _Private_ handler to finish legacy authentication.
             *
             *  This handler is called when the result from the jabber:iq:auth
             *  <iq/> stanza is returned.
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza that triggered the callback.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _auth2_cb: function (elem) {
                if (elem.getAttribute("type") == "result") {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") == "error") {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    this.disconnect('authentication failed');
                }
                return false;
            },

            /** PrivateFunction: _addSysTimedHandler
             *  _Private_ function to add a system level timed handler.
             *
             *  This function is used to add a Strophe.TimedHandler for the
             *  library code.  System timed handlers are allowed to run before
             *  authentication is complete.
             *
             *  Parameters:
             *    (Integer) period - The period of the handler.
             *    (Function) handler - The callback function.
             */
            _addSysTimedHandler: function (period, handler) {
                var thand = new Strophe.TimedHandler(period, handler);
                thand.user = false;
                this.addTimeds.push(thand);
                return thand;
            },

            /** PrivateFunction: _addSysHandler
             *  _Private_ function to add a system level stanza handler.
             *
             *  This function is used to add a Strophe.Handler for the
             *  library code.  System stanza handlers are allowed to run before
             *  authentication is complete.
             *
             *  Parameters:
             *    (Function) handler - The callback function.
             *    (String) ns - The namespace to match.
             *    (String) name - The stanza name to match.
             *    (String) type - The stanza type attribute to match.
             *    (String) id - The stanza id attribute to match.
             */
            _addSysHandler: function (handler, ns, name, type, id) {
                var hand = new Strophe.Handler(handler, ns, name, type, id);
                hand.user = false;
                this.addHandlers.push(hand);
                return hand;
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  If the graceful disconnect process does not complete within the
             *  time allotted, this handler finishes the disconnect anyway.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _onDisconnectTimeout: function () {
                Strophe.info("_onDisconnectTimeout was called");
                this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);
                this._proto._onDisconnectTimeout();
                // actually disconnect
                this._doDisconnect();
                return false;
            },

            /** PrivateFunction: _onIdle
             *  _Private_ handler to process events during idle cycle.
             *
             *  This handler is called every 100ms to fire timed handlers that
             *  are ready and keep poll requests going.
             */
            _onIdle: function () {
                var i, thand, since, newList;

                // add timed handlers scheduled for addition
                // NOTE: we add before remove in the case a timed handler is
                // added and then deleted before the next _onIdle() call.
                while (this.addTimeds.length > 0) {
                    this.timedHandlers.push(this.addTimeds.pop());
                }

                // remove timed handlers that have been scheduled for deletion
                while (this.removeTimeds.length > 0) {
                    thand = this.removeTimeds.pop();
                    i = this.timedHandlers.indexOf(thand);
                    if (i >= 0) {
                        this.timedHandlers.splice(i, 1);
                    }
                }

                // call ready timed handlers
                var now = new Date().getTime();
                newList = [];
                for (i = 0; i < this.timedHandlers.length; i++) {
                    thand = this.timedHandlers[i];
                    if (this.authenticated || !thand.user) {
                        since = thand.lastCalled + thand.period;
                        if (since - now <= 0) {
                            if (thand.run()) {
                                newList.push(thand);
                            }
                        } else {
                            newList.push(thand);
                        }
                    }
                }
                this.timedHandlers = newList;

                clearTimeout(this._idleTimeout);

                this._proto._onIdle();

                // reactivate the timer only if connected
                if (this.connected) {
                    // XXX: setTimeout should be called only with function expressions (23974bc1)
                    this._idleTimeout = setTimeout(function() {
                        this._onIdle();
                    }.bind(this), 1000);
                }
            }
        };

        /** Class: Strophe.SASLMechanism
         *
         *  encapsulates SASL authentication mechanisms.
         *
         *  User code may override the priority for each mechanism or disable it completely.
         *  See <priority> for information about changing priority and <test> for informatian on
         *  how to disable a mechanism.
         *
         *  By default, all mechanisms are enabled and the priorities are
         *
         *  EXTERNAL - 60
         *  OAUTHBEARER - 50
         *  SCRAM-SHA1 - 40
         *  DIGEST-MD5 - 30
         *  PLAIN - 20
         *  ANONYMOUS - 10
         *
         *  See: Strophe.Connection.addSupportedSASLMechanisms
         */

        /**
         * PrivateConstructor: Strophe.SASLMechanism
         * SASL auth mechanism abstraction.
         *
         *  Parameters:
         *    (String) name - SASL Mechanism name.
         *    (Boolean) isClientFirst - If client should send response first without challenge.
         *    (Number) priority - Priority.
         *
         *  Returns:
         *    A new Strophe.SASLMechanism object.
         */
        Strophe.SASLMechanism = function(name, isClientFirst, priority) {
            /** PrivateVariable: name
             *  Mechanism name.
             */
            this.name = name;
            /** PrivateVariable: isClientFirst
             *  If client sends response without initial server challenge.
             */
            this.isClientFirst = isClientFirst;
            /** Variable: priority
             *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
             *  Users may override this to prioritize mechanisms differently.
             *
             *  In the default configuration the priorities are
             *
             *  SCRAM-SHA1 - 40
             *  DIGEST-MD5 - 30
             *  Plain - 20
             *
             *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
             *
             *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
             *
             *  See <SASL mechanisms> for a list of available mechanisms.
             *
             */
            this.priority = priority;
        };

        Strophe.SASLMechanism.prototype = {
            /**
             *  Function: test
             *  Checks if mechanism able to run.
             *  To disable a mechanism, make this return false;
             *
             *  To disable plain authentication run
             *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
             *
             *  See <SASL mechanisms> for a list of available mechanisms.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             *
             *  Returns:
             *    (Boolean) If mechanism was able to run.
             */
            /* jshint unused:false */
            test: function(connection) {
                return true;
            },
            /* jshint unused:true */

            /** PrivateFunction: onStart
             *  Called before starting mechanism on some connection.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             */
            onStart: function(connection) {
                this._connection = connection;
            },

            /** PrivateFunction: onChallenge
             *  Called by protocol implementation on incoming challenge. If client is
             *  first (isClientFirst == true) challenge will be null on the first call.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             *    (String) challenge - current challenge to handle.
             *
             *  Returns:
             *    (String) Mechanism response.
             */
            /* jshint unused:false */
            onChallenge: function(connection, challenge) {
                throw new Error("You should implement challenge handling!");
            },
            /* jshint unused:true */

            /** PrivateFunction: onFailure
             *  Protocol informs mechanism implementation about SASL failure.
             */
            onFailure: function() {
                this._connection = null;
            },

            /** PrivateFunction: onSuccess
             *  Protocol informs mechanism implementation about SASL success.
             */
            onSuccess: function() {
                this._connection = null;
            }
        };

        /** Constants: SASL mechanisms
         *  Available authentication mechanisms
         *
         *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.
         *  Strophe.SASLPlain - SASL PLAIN authentication.
         *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication
         *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
         *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication
         *  Strophe.SASLExternal - SASL EXTERNAL authentication
         */

// Building SASL callbacks

        /** PrivateConstructor: SASLAnonymous
         *  SASL ANONYMOUS authentication.
         */
        Strophe.SASLAnonymous = function() {};
        Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 20);

        Strophe.SASLAnonymous.prototype.test = function(connection) {
            return connection.authcid === null;
        };


        /** PrivateConstructor: SASLPlain
         *  SASL PLAIN authentication.
         */
        Strophe.SASLPlain = function() {};
        Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 30);

        Strophe.SASLPlain.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLPlain.prototype.onChallenge = function(connection) {
            var auth_str = connection.authzid;
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + connection.authcid;
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + connection.pass;
            return utils.utf16to8(auth_str);
        };


        /** PrivateConstructor: SASLSHA1
         *  SASL SCRAM SHA 1 authentication.
         */
        Strophe.SASLSHA1 = function() {};
        Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 50);

        Strophe.SASLSHA1.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
            var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
            var auth_str = "n=" + utils.utf16to8(connection.authcid);
            auth_str += ",r=";
            auth_str += cnonce;
            connection._sasl_data.cnonce = cnonce;
            connection._sasl_data["client-first-message-bare"] = auth_str;

            auth_str = "n,," + auth_str;

            this.onChallenge = function (connection, challenge) {
                var nonce, salt, iter, Hi, U, U_old, i, k, pass;
                var clientKey, serverKey, clientSignature;
                var responseText = "c=biws,";
                var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
                    challenge + ",";
                var cnonce = connection._sasl_data.cnonce;
                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;

                while (challenge.match(attribMatch)) {
                    var matches = challenge.match(attribMatch);
                    challenge = challenge.replace(matches[0], "");
                    switch (matches[1]) {
                        case "r":
                            nonce = matches[2];
                            break;
                        case "s":
                            salt = matches[2];
                            break;
                        case "i":
                            iter = matches[2];
                            break;
                    }
                }

                if (nonce.substr(0, cnonce.length) !== cnonce) {
                    connection._sasl_data = {};
                    return connection._sasl_failure_cb();
                }

                responseText += "r=" + nonce;
                authMessage += responseText;

                salt = Base64.decode(salt);
                salt += "\x00\x00\x00\x01";

                pass = utils.utf16to8(connection.pass);
                Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
                for (i = 1; i < iter; i++) {
                    U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
                    for (k = 0; k < 5; k++) {
                        Hi[k] ^= U[k];
                    }
                    U_old = U;
                }
                Hi = SHA1.binb2str(Hi);

                clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
                serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
                clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
                connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);

                for (k = 0; k < 5; k++) {
                    clientKey[k] ^= clientSignature[k];
                }

                responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
                return responseText;
            }.bind(this);

            return auth_str;
        };


        /** PrivateConstructor: SASLMD5
         *  SASL DIGEST MD5 authentication.
         */
        Strophe.SASLMD5 = function() {};
        Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 40);

        Strophe.SASLMD5.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        /** PrivateFunction: _quote
         *  _Private_ utility function to backslash escape and quote strings.
         *
         *  Parameters:
         *    (String) str - The string to be quoted.
         *
         *  Returns:
         *    quoted string
         */
        Strophe.SASLMD5.prototype._quote = function (str) {
            return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
            //" end string workaround for emacs
        };

        Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
            var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
            var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
            var realm = "";
            var host = null;
            var nonce = "";
            var qop = "";
            var matches;

            while (challenge.match(attribMatch)) {
                matches = challenge.match(attribMatch);
                challenge = challenge.replace(matches[0], "");
                matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
                switch (matches[1]) {
                    case "realm":
                        realm = matches[2];
                        break;
                    case "nonce":
                        nonce = matches[2];
                        break;
                    case "qop":
                        qop = matches[2];
                        break;
                    case "host":
                        host = matches[2];
                        break;
                }
            }

            var digest_uri = connection.servtype + "/" + connection.domain;
            if (host !== null) {
                digest_uri = digest_uri + "/" + host;
            }

            var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
            var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
            var A2 = 'AUTHENTICATE:' + digest_uri;

            var responseText = "";
            responseText += 'charset=utf-8,';
            responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
            responseText += 'realm=' + this._quote(realm) + ',';
            responseText += 'nonce=' + this._quote(nonce) + ',';
            responseText += 'nc=00000001,';
            responseText += 'cnonce=' + this._quote(cnonce) + ',';
            responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
            responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                    nonce + ":00000001:" +
                    cnonce + ":auth:" +
                    MD5.hexdigest(A2)) + ",";
            responseText += 'qop=auth';

            this.onChallenge = function () {
                return "";
            };
            return responseText;
        };


        /** PrivateConstructor: SASLOAuthBearer
         *  SASL OAuth Bearer authentication.
         */
        Strophe.SASLOAuthBearer = function() {};
        Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism("OAUTHBEARER", true, 60);

        Strophe.SASLOAuthBearer.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {
            var auth_str = 'n,a=';
            auth_str = auth_str + connection.authzid;
            auth_str = auth_str + ',';
            auth_str = auth_str + "\u0001";
            auth_str = auth_str + 'auth=Bearer ';
            auth_str = auth_str + connection.pass;
            auth_str = auth_str + "\u0001";
            auth_str = auth_str + "\u0001";
            return utils.utf16to8(auth_str);
        };


        /** PrivateConstructor: SASLExternal
         *  SASL EXTERNAL authentication.
         *
         *  The EXTERNAL mechanism allows a client to request the server to use
         *  credentials established by means external to the mechanism to
         *  authenticate the client. The external means may be, for instance,
         *  TLS services.
         */
        Strophe.SASLExternal = function() {};
        Strophe.SASLExternal.prototype = new Strophe.SASLMechanism("EXTERNAL", true, 10);

        Strophe.SASLExternal.prototype.onChallenge = function(connection) {
            /** According to XEP-178, an authzid SHOULD NOT be presented when the
             * authcid contained or implied in the client certificate is the JID (i.e.
             * authzid) with which the user wants to log in as.
             *
             * To NOT send the authzid, the user should therefore set the authcid equal
             * to the JID when instantiating a new Strophe.Connection object.
             */
            return connection.authcid === connection.authzid ? '' : connection.authzid;
        };

        return {
            Strophe:        Strophe,
            $build:         $build,
            $msg:           $msg,
            $iq:            $iq,
            $pres:          $pres,
            SHA1:           SHA1,
            Base64:         Base64,
            MD5:            MD5,
        };
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function (core) {
                return factory(
                    core.Strophe,
                    core.$build
                );
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            return factory(Strophe, $build);
        }
    }(this, function (Strophe, $build) {

        /** PrivateClass: Strophe.Request
         *  _Private_ helper class that provides a cross implementation abstraction
         *  for a BOSH related XMLHttpRequest.
         *
         *  The Strophe.Request class is used internally to encapsulate BOSH request
         *  information.  It is not meant to be used from user's code.
         */

        /** PrivateConstructor: Strophe.Request
         *  Create and initialize a new Strophe.Request object.
         *
         *  Parameters:
         *    (XMLElement) elem - The XML data to be sent in the request.
         *    (Function) func - The function that will be called when the
         *      XMLHttpRequest readyState changes.
         *    (Integer) rid - The BOSH rid attribute associated with this request.
         *    (Integer) sends - The number of times this same request has been sent.
         */
        Strophe.Request = function (elem, func, rid, sends) {
            this.id = ++Strophe._requestId;
            this.xmlData = elem;
            this.data = Strophe.serialize(elem);
            // save original function in case we need to make a new request
            // from this one.
            this.origFunc = func;
            this.func = func;
            this.rid = rid;
            this.date = NaN;
            this.sends = sends || 0;
            this.abort = false;
            this.dead = null;

            this.age = function () {
                if (!this.date) { return 0; }
                var now = new Date();
                return (now - this.date) / 1000;
            };
            this.timeDead = function () {
                if (!this.dead) { return 0; }
                var now = new Date();
                return (now - this.dead) / 1000;
            };
            this.xhr = this._newXHR();
        };

        Strophe.Request.prototype = {
            /** PrivateFunction: getResponse
             *  Get a response from the underlying XMLHttpRequest.
             *
             *  This function attempts to get a response from the request and checks
             *  for errors.
             *
             *  Throws:
             *    "parsererror" - A parser error occured.
             *    "badformat" - The entity has sent XML that cannot be processed.
             *
             *  Returns:
             *    The DOM element tree of the response.
             */
            getResponse: function () {
                var node = null;
                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                    node = this.xhr.responseXML.documentElement;
                    if (node.tagName == "parsererror") {
                        Strophe.error("invalid response received");
                        Strophe.error("responseText: " + this.xhr.responseText);
                        Strophe.error("responseXML: " +
                            Strophe.serialize(this.xhr.responseXML));
                        throw "parsererror";
                    }
                } else if (this.xhr.responseText) {
                    Strophe.error("invalid response received");
                    Strophe.error("responseText: " + this.xhr.responseText);
                    throw "badformat";
                }

                return node;
            },

            /** PrivateFunction: _newXHR
             *  _Private_ helper function to create XMLHttpRequests.
             *
             *  This function creates XMLHttpRequests across all implementations.
             *
             *  Returns:
             *    A new XMLHttpRequest.
             */
            _newXHR: function () {
                var xhr = null;
                if (window.XMLHttpRequest) {
                    xhr = new XMLHttpRequest();
                    if (xhr.overrideMimeType) {
                        xhr.overrideMimeType("text/xml; charset=utf-8");
                    }
                } else if (window.ActiveXObject) {
                    xhr = new ActiveXObject("Microsoft.XMLHTTP");
                }
                // use Function.bind() to prepend ourselves as an argument
                xhr.onreadystatechange = this.func.bind(null, this);
                return xhr;
            }
        };

        /** Class: Strophe.Bosh
         *  _Private_ helper class that handles BOSH Connections
         *
         *  The Strophe.Bosh class is used internally by Strophe.Connection
         *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
         */

        /** File: bosh.js
         *  A JavaScript library to enable BOSH in Strophejs.
         *
         *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
         *  to emulate a persistent, stateful, two-way connection to an XMPP server.
         *  More information on BOSH can be found in XEP 124.
         */

        /** PrivateConstructor: Strophe.Bosh
         *  Create and initialize a Strophe.Bosh object.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
         *
         *  Returns:
         *    A new Strophe.Bosh object.
         */
        Strophe.Bosh = function(connection) {
            this._conn = connection;
            /* request id for body tags */
            this.rid = Math.floor(Math.random() * 4294967295);
            /* The current session ID. */
            this.sid = null;

            // default BOSH values
            this.hold = 1;
            this.wait = 60;
            this.window = 5;
            this.errors = 0;
            this.inactivity = null;

            this._requests = [];
        };

        Strophe.Bosh.prototype = {
            /** Variable: strip
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
             *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
             *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
             *
             *  > Strophe.Bosh.prototype.strip = "body";
             *
             *  This will enable stripping of the body tag in both
             *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
             */
            strip: null,

            /** PrivateFunction: _buildBody
             *  _Private_ helper function to generate the <body/> wrapper for BOSH.
             *
             *  Returns:
             *    A Strophe.Builder with a <body/> element.
             */
            _buildBody: function () {
                var bodyWrap = $build('body', {
                    rid: this.rid++,
                    xmlns: Strophe.NS.HTTPBIND
                });
                if (this.sid !== null) {
                    bodyWrap.attrs({sid: this.sid});
                }
                if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
                    this._cacheSession();
                }
                return bodyWrap;
            },

            /** PrivateFunction: _reset
             *  Reset the connection.
             *
             *  This function is called by the reset function of the Strophe Connection
             */
            _reset: function () {
                this.rid = Math.floor(Math.random() * 4294967295);
                this.sid = null;
                this.errors = 0;
                if (this._conn._sessionCachingSupported()) {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }

                this._conn.nextValidRid(this.rid);
            },

            /** PrivateFunction: _connect
             *  _Private_ function that initializes the BOSH connection.
             *
             *  Creates and sends the Request that initializes the BOSH connection.
             */
            _connect: function (wait, hold, route) {
                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.errors = 0;

                // build the body tag
                var body = this._buildBody().attrs({
                    to: this._conn.domain,
                    "xml:lang": "en",
                    wait: this.wait,
                    hold: this.hold,
                    content: "text/xml; charset=utf-8",
                    ver: "1.6",
                    "xmpp:version": "1.0",
                    "xmlns:xmpp": Strophe.NS.BOSH
                });

                if(route){
                    body.attrs({
                        route: route
                    });
                }

                var _connect_cb = this._conn._connect_cb;

                this._requests.push(
                    new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                            this, _connect_cb.bind(this._conn)),
                        body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _attach
             *  Attach to an already created and authenticated BOSH session.
             *
             *  This function is provided to allow Strophe to attach to BOSH
             *  sessions which have been created externally, perhaps by a Web
             *  application.  This is often used to support auto-login type features
             *  without putting user credentials into the page.
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *    (String) sid - The SID of the BOSH session.
             *    (String) rid - The current RID of the BOSH session.  This RID
             *      will be used by the next request.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            _attach: function (jid, sid, rid, callback, wait, hold, wind) {
                this._conn.jid = jid;
                this.sid = sid;
                this.rid = rid;

                this._conn.connect_callback = callback;

                this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);

                this._conn.authenticated = true;
                this._conn.connected = true;

                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.window = wind || this.window;

                this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
            },

            /** PrivateFunction: _restore
             *  Attempt to restore a cached BOSH session
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *      This parameter is optional but recommended, specifically in cases
             *      where prebinded BOSH sessions are used where it's important to know
             *      that the right session is being restored.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            _restore: function (jid, callback, wait, hold, wind) {
                var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
                if (typeof session !== "undefined" &&
                    session !== null &&
                    session.rid &&
                    session.sid &&
                    session.jid &&
                    (    typeof jid === "undefined" ||
                        jid === null ||
                        Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid) ||
                        // If authcid is null, then it's an anonymous login, so
                        // we compare only the domains:
                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) == jid))
                    )
                ) {
                    this._conn.restored = true;
                    this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
                } else {
                    throw { name: "StropheSessionError", message: "_restore: no restoreable session." };
                }
            },

            /** PrivateFunction: _cacheSession
             *  _Private_ handler for the beforeunload event.
             *
             *  This handler is used to process the Bosh-part of the initial request.
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _cacheSession: function () {
                if (this._conn.authenticated) {
                    if (this._conn.jid && this.rid && this.sid) {
                        window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                            'jid': this._conn.jid,
                            'rid': this.rid,
                            'sid': this.sid
                        }));
                    }
                } else {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }
            },

            /** PrivateFunction: _connect_cb
             *  _Private_ handler for initial connection request.
             *
             *  This handler is used to process the Bosh-part of the initial request.
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _connect_cb: function (bodyWrap) {
                var typ = bodyWrap.getAttribute("type");
                var cond, conflict;
                if (typ !== null && typ == "terminate") {
                    // an error occurred
                    cond = bodyWrap.getAttribute("condition");
                    Strophe.error("BOSH-Connection failed: " + cond);
                    conflict = bodyWrap.getElementsByTagName("conflict");
                    if (cond !== null) {
                        if (cond == "remote-stream-error" && conflict.length > 0) {
                            cond = "conflict";
                        }
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                    } else {
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                    }
                    this._conn._doDisconnect(cond);
                    return Strophe.Status.CONNFAIL;
                }

                // check to make sure we don't overwrite these if _connect_cb is
                // called multiple times in the case of missing stream:features
                if (!this.sid) {
                    this.sid = bodyWrap.getAttribute("sid");
                }
                var wind = bodyWrap.getAttribute('requests');
                if (wind) { this.window = parseInt(wind, 10); }
                var hold = bodyWrap.getAttribute('hold');
                if (hold) { this.hold = parseInt(hold, 10); }
                var wait = bodyWrap.getAttribute('wait');
                if (wait) { this.wait = parseInt(wait, 10); }
                var inactivity = bodyWrap.getAttribute('inactivity');
                if (inactivity) { this.inactivity = parseInt(inactivity, 10); }
            },

            /** PrivateFunction: _disconnect
             *  _Private_ part of Connection.disconnect for Bosh
             *
             *  Parameters:
             *    (Request) pres - This stanza will be sent before disconnecting.
             */
            _disconnect: function (pres) {
                this._sendTerminate(pres);
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  Resets the SID and RID.
             */
            _doDisconnect: function () {
                this.sid = null;
                this.rid = Math.floor(Math.random() * 4294967295);
                if (this._conn._sessionCachingSupported()) {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }

                this._conn.nextValidRid(this.rid);
            },

            /** PrivateFunction: _emptyQueue
             * _Private_ function to check if the Request queue is empty.
             *
             *  Returns:
             *    True, if there are no Requests queued, False otherwise.
             */
            _emptyQueue: function () {
                return this._requests.length === 0;
            },

            /** PrivateFunction: _callProtocolErrorHandlers
             *  _Private_ function to call error handlers registered for HTTP errors.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request that is changing readyState.
             */
            _callProtocolErrorHandlers: function (req) {
                var reqStatus = this._getRequestStatus(req),
                    err_callback;
                err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
                if (err_callback) {
                    err_callback.call(this, reqStatus);
                }
            },

            /** PrivateFunction: _hitError
             *  _Private_ function to handle the error count.
             *
             *  Requests are resent automatically until their error count reaches
             *  5.  Each time an error is encountered, this function is called to
             *  increment the count and disconnect if the count is too high.
             *
             *  Parameters:
             *    (Integer) reqStatus - The request status.
             */
            _hitError: function (reqStatus) {
                this.errors++;
                Strophe.warn("request errored, status: " + reqStatus +
                    ", number of errors: " + this.errors);
                if (this.errors > 4) {
                    this._conn._onDisconnectTimeout();
                }
            },

            /** PrivateFunction: _no_auth_received
             *
             * Called on stream start/restart when no stream:features
             * has been received and sends a blank poll request.
             */
            _no_auth_received: function (_callback) {
                if (_callback) {
                    _callback = _callback.bind(this._conn);
                } else {
                    _callback = this._conn._connect_cb.bind(this._conn);
                }
                var body = this._buildBody();
                this._requests.push(
                    new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                            this, _callback.bind(this._conn)),
                        body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  Cancels all remaining Requests and clears the queue.
             */
            _onDisconnectTimeout: function () {
                this._abortAllRequests();
            },

            /** PrivateFunction: _abortAllRequests
             *  _Private_ helper function that makes sure all pending requests are aborted.
             */
            _abortAllRequests: function _abortAllRequests() {
                var req;
                while (this._requests.length > 0) {
                    req = this._requests.pop();
                    req.abort = true;
                    req.xhr.abort();
                    // jslint complains, but this is fine. setting to empty func
                    // is necessary for IE6
                    req.xhr.onreadystatechange = function () {}; // jshint ignore:line
                }
            },

            /** PrivateFunction: _onIdle
             *  _Private_ handler called by Strophe.Connection._onIdle
             *
             *  Sends all queued Requests or polls with empty Request if there are none.
             */
            _onIdle: function () {
                var data = this._conn._data;
                // if no requests are in progress, poll
                if (this._conn.authenticated && this._requests.length === 0 &&
                    data.length === 0 && !this._conn.disconnecting) {
                    Strophe.info("no requests during idle cycle, sending " +
                        "blank request");
                    data.push(null);
                }

                if (this._conn.paused) {
                    return;
                }

                if (this._requests.length < 2 && data.length > 0) {
                    var body = this._buildBody();
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] !== null) {
                            if (data[i] === "restart") {
                                body.attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    "xmpp:restart": "true",
                                    "xmlns:xmpp": Strophe.NS.BOSH
                                });
                            } else {
                                body.cnode(data[i]).up();
                            }
                        }
                    }
                    delete this._conn._data;
                    this._conn._data = [];
                    this._requests.push(
                        new Strophe.Request(body.tree(),
                            this._onRequestStateChange.bind(
                                this, this._conn._dataRecv.bind(this._conn)),
                            body.tree().getAttribute("rid")));
                    this._throttledRequestHandler();
                }

                if (this._requests.length > 0) {
                    var time_elapsed = this._requests[0].age();
                    if (this._requests[0].dead !== null) {
                        if (this._requests[0].timeDead() >
                            Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                            this._throttledRequestHandler();
                        }
                    }

                    if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                        Strophe.warn("Request " +
                            this._requests[0].id +
                            " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                            " seconds since last activity");
                        this._throttledRequestHandler();
                    }
                }
            },

            /** PrivateFunction: _getRequestStatus
             *
             *  Returns the HTTP status code from a Strophe.Request
             *
             *  Parameters:
             *    (Strophe.Request) req - The Strophe.Request instance.
             *    (Integer) def - The default value that should be returned if no
             *          status value was found.
             */
            _getRequestStatus: function (req, def) {
                var reqStatus;
                if (req.xhr.readyState == 4) {
                    try {
                        reqStatus = req.xhr.status;
                    } catch (e) {
                        // ignore errors from undefined status attribute. Works
                        // around a browser bug
                        Strophe.error(
                            "Caught an error while retrieving a request's status, " +
                            "reqStatus: " + reqStatus);
                    }
                }
                if (typeof(reqStatus) == "undefined") {
                    reqStatus = typeof def === 'number' ? def : 0;
                }
                return reqStatus;
            },

            /** PrivateFunction: _onRequestStateChange
             *  _Private_ handler for Strophe.Request state changes.
             *
             *  This function is called when the XMLHttpRequest readyState changes.
             *  It contains a lot of error handling logic for the many ways that
             *  requests can fail, and calls the request callback when requests
             *  succeed.
             *
             *  Parameters:
             *    (Function) func - The handler for the request.
             *    (Strophe.Request) req - The request that is changing readyState.
             */
            _onRequestStateChange: function (func, req) {
                Strophe.debug("request id "+req.id+"."+req.sends+
                    " state changed to "+req.xhr.readyState);
                if (req.abort) {
                    req.abort = false;
                    return;
                }
                if (req.xhr.readyState !== 4) {
                    // The request is not yet complete
                    return;
                }
                var reqStatus = this._getRequestStatus(req);
                if (this.disconnecting && reqStatus >= 400) {
                    this._hitError(reqStatus);
                    this._callProtocolErrorHandlers(req);
                    return;
                }

                if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                    // remove from internal queue
                    this._removeRequest(req);
                    Strophe.debug("request id "+req.id+" should now be removed");
                }

                if (reqStatus == 200) {
                    // request succeeded
                    var reqIs0 = (this._requests[0] == req);
                    var reqIs1 = (this._requests[1] == req);
                    // if request 1 finished, or request 0 finished and request
                    // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                    // restart the other - both will be in the first spot, as the
                    // completed request has been removed from the queue already
                    if (reqIs1 ||
                        (reqIs0 && this._requests.length > 0 &&
                        this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                        this._restartRequest(0);
                    }
                    this._conn.nextValidRid(Number(req.rid) + 1);
                    Strophe.debug("request id "+req.id+"."+req.sends+" got 200");
                    func(req); // call handler
                    this.errors = 0;
                } else if (reqStatus === 0 ||
                    (reqStatus >= 400 && reqStatus < 600) ||
                    reqStatus >= 12000) {
                    // request failed
                    Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
                    this._hitError(reqStatus);
                    this._callProtocolErrorHandlers(req);
                    if (reqStatus >= 400 && reqStatus < 500) {
                        this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                        this._conn._doDisconnect();
                    }
                } else {
                    Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
                }
                if (!(reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                    this._throttledRequestHandler();
                }
            },

            /** PrivateFunction: _processRequest
             *  _Private_ function to process a request in the queue.
             *
             *  This function takes requests off the queue and sends them and
             *  restarts dead requests.
             *
             *  Parameters:
             *    (Integer) i - The index of the request in the queue.
             */
            _processRequest: function (i) {
                var self = this;
                var req = this._requests[i];
                var reqStatus = this._getRequestStatus(req, -1);

                // make sure we limit the number of retries
                if (req.sends > this._conn.maxRetries) {
                    this._conn._onDisconnectTimeout();
                    return;
                }

                var time_elapsed = req.age();
                var primaryTimeout = (!isNaN(time_elapsed) &&
                time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
                var secondaryTimeout = (req.dead !== null &&
                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
                var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                (reqStatus < 1 || reqStatus >= 500));
                if (primaryTimeout || secondaryTimeout ||
                    requestCompletedWithServerError) {
                    if (secondaryTimeout) {
                        Strophe.error("Request " + this._requests[i].id +
                            " timed out (secondary), restarting");
                    }
                    req.abort = true;
                    req.xhr.abort();
                    // setting to null fails on IE6, so set to empty function
                    req.xhr.onreadystatechange = function () {};
                    this._requests[i] = new Strophe.Request(req.xmlData,
                        req.origFunc,
                        req.rid,
                        req.sends);
                    req = this._requests[i];
                }

                if (req.xhr.readyState === 0) {
                    Strophe.debug("request id "+req.id+"."+req.sends+" posting");

                    try {
                        var contentType = this._conn.options.contentType || "text/xml; charset=utf-8";
                        req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
                        if (typeof req.xhr.setRequestHeader !== 'undefined') {
                            // IE9 doesn't have setRequestHeader
                            req.xhr.setRequestHeader("Content-Type", contentType);
                        }
                        if (this._conn.options.withCredentials) {
                            req.xhr.withCredentials = true;
                        }
                    } catch (e2) {
                        Strophe.error("XHR open failed.");
                        if (!this._conn.connected) {
                            this._conn._changeConnectStatus(
                                Strophe.Status.CONNFAIL, "bad-service");
                        }
                        this._conn.disconnect();
                        return;
                    }

                    // Fires the XHR request -- may be invoked immediately
                    // or on a gradually expanding retry window for reconnects
                    var sendFunc = function () {
                        req.date = new Date();
                        if (self._conn.options.customHeaders){
                            var headers = self._conn.options.customHeaders;
                            for (var header in headers) {
                                if (headers.hasOwnProperty(header)) {
                                    req.xhr.setRequestHeader(header, headers[header]);
                                }
                            }
                        }
                        req.xhr.send(req.data);
                    };

                    // Implement progressive backoff for reconnects --
                    // First retry (send == 1) should also be instantaneous
                    if (req.sends > 1) {
                        // Using a cube of the retry number creates a nicely
                        // expanding retry window
                        var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                Math.pow(req.sends, 3)) * 1000;
                        setTimeout(function() {
                            // XXX: setTimeout should be called only with function expressions (23974bc1)
                            sendFunc();
                        }, backoff);
                    } else {
                        sendFunc();
                    }

                    req.sends++;

                    if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                        if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                            this._conn.xmlOutput(req.xmlData.childNodes[0]);
                        } else {
                            this._conn.xmlOutput(req.xmlData);
                        }
                    }
                    if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                        this._conn.rawOutput(req.data);
                    }
                } else {
                    Strophe.debug("_processRequest: " +
                        (i === 0 ? "first" : "second") +
                        " request has readyState of " +
                        req.xhr.readyState);
                }
            },

            /** PrivateFunction: _removeRequest
             *  _Private_ function to remove a request from the queue.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request to remove.
             */
            _removeRequest: function (req) {
                Strophe.debug("removing request");
                var i;
                for (i = this._requests.length - 1; i >= 0; i--) {
                    if (req == this._requests[i]) {
                        this._requests.splice(i, 1);
                    }
                }
                // IE6 fails on setting to null, so set to empty function
                req.xhr.onreadystatechange = function () {};
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _restartRequest
             *  _Private_ function to restart a request that is presumed dead.
             *
             *  Parameters:
             *    (Integer) i - The index of the request in the queue.
             */
            _restartRequest: function (i) {
                var req = this._requests[i];
                if (req.dead === null) {
                    req.dead = new Date();
                }

                this._processRequest(i);
            },

            /** PrivateFunction: _reqToData
             * _Private_ function to get a stanza out of a request.
             *
             * Tries to extract a stanza out of a Request Object.
             * When this fails the current connection will be disconnected.
             *
             *  Parameters:
             *    (Object) req - The Request.
             *
             *  Returns:
             *    The stanza that was passed.
             */
            _reqToData: function (req) {
                try {
                    return req.getResponse();
                } catch (e) {
                    if (e != "parsererror") { throw e; }
                    this._conn.disconnect("strophe-parsererror");
                }
            },

            /** PrivateFunction: _sendTerminate
             *  _Private_ function to send initial disconnect sequence.
             *
             *  This is the first step in a graceful disconnect.  It sends
             *  the BOSH server a terminate body and includes an unavailable
             *  presence if authentication has completed.
             */
            _sendTerminate: function (pres) {
                Strophe.info("_sendTerminate was called");
                var body = this._buildBody().attrs({type: "terminate"});
                if (pres) {
                    body.cnode(pres.tree());
                }
                var req = new Strophe.Request(
                    body.tree(),
                    this._onRequestStateChange.bind(
                        this, this._conn._dataRecv.bind(this._conn)),
                    body.tree().getAttribute("rid")
                );
                this._requests.push(req);
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _send
             *  _Private_ part of the Connection.send function for BOSH
             *
             * Just triggers the RequestHandler to send the messages that are in the queue
             */
            _send: function () {
                clearTimeout(this._conn._idleTimeout);
                this._throttledRequestHandler();

                // XXX: setTimeout should be called only with function expressions (23974bc1)
                this._conn._idleTimeout = setTimeout(function() {
                    this._onIdle();
                }.bind(this._conn), 100);
            },

            /** PrivateFunction: _sendRestart
             *
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function () {
                this._throttledRequestHandler();
                clearTimeout(this._conn._idleTimeout);
            },

            /** PrivateFunction: _throttledRequestHandler
             *  _Private_ function to throttle requests to the connection window.
             *
             *  This function makes sure we don't send requests so fast that the
             *  request ids overflow the connection window in the case that one
             *  request died.
             */
            _throttledRequestHandler: function () {
                if (!this._requests) {
                    Strophe.debug("_throttledRequestHandler called with " +
                        "undefined requests");
                } else {
                    Strophe.debug("_throttledRequestHandler called with " +
                        this._requests.length + " requests");
                }

                if (!this._requests || this._requests.length === 0) {
                    return;
                }

                if (this._requests.length > 0) {
                    this._processRequest(0);
                }

                if (this._requests.length > 1 &&
                    Math.abs(this._requests[0].rid -
                        this._requests[1].rid) < this.window) {
                    this._processRequest(1);
                }
            }
        };
        return Strophe;
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_7__ = (function (core) {
                return factory(
                    core.Strophe,
                    core.$build
                );
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            return factory(Strophe, $build);
        }
    }(this, function (Strophe, $build) {

        /** Class: Strophe.WebSocket
         *  _Private_ helper class that handles WebSocket Connections
         *
         *  The Strophe.WebSocket class is used internally by Strophe.Connection
         *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
         */

        /** File: websocket.js
         *  A JavaScript library to enable XMPP over Websocket in Strophejs.
         *
         *  This file implements XMPP over WebSockets for Strophejs.
         *  If a Connection is established with a Websocket url (ws://...)
         *  Strophe will use WebSockets.
         *  For more information on XMPP-over-WebSocket see RFC 7395:
         *  http://tools.ietf.org/html/rfc7395
         *
         *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
         */

        /** PrivateConstructor: Strophe.Websocket
         *  Create and initialize a Strophe.WebSocket object.
         *  Currently only sets the connection Object.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
         *
         *  Returns:
         *    A new Strophe.WebSocket object.
         */
        Strophe.Websocket = function(connection) {
            this._conn = connection;
            this.strip = "wrapper";

            var service = connection.service;
            if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
                // If the service is not an absolute URL, assume it is a path and put the absolute
                // URL together from options, current URL and the path.
                var new_service = "";

                if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
                    new_service += "ws";
                } else {
                    new_service += "wss";
                }

                new_service += "://" + window.location.host;

                if (service.indexOf("/") !== 0) {
                    new_service += window.location.pathname + service;
                } else {
                    new_service += service;
                }

                connection.service = new_service;
            }
        };

        Strophe.Websocket.prototype = {
            /** PrivateFunction: _buildStream
             *  _Private_ helper function to generate the <stream> start tag for WebSockets
             *
             *  Returns:
             *    A Strophe.Builder with a <stream> element.
             */
            _buildStream: function () {
                return $build("open", {
                    "xmlns": Strophe.NS.FRAMING,
                    "to": this._conn.domain,
                    "version": '1.0'
                });
            },

            /** PrivateFunction: _check_streamerror
             * _Private_ checks a message for stream:error
             *
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             *    connectstatus - The ConnectStatus that will be set on error.
             *  Returns:
             *     true if there was a streamerror, false otherwise.
             */
            _check_streamerror: function (bodyWrap, connectstatus) {
                var errors;
                if (bodyWrap.getElementsByTagNameNS) {
                    errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
                } else {
                    errors = bodyWrap.getElementsByTagName("stream:error");
                }
                if (errors.length === 0) {
                    return false;
                }
                var error = errors[0];

                var condition = "";

                var ns = "urn:ietf:params:xml:ns:xmpp-streams";
                for (var i = 0; i < error.childNodes.length; i++) {
                    var e = error.childNodes[i];
                    if (e.getAttribute("xmlns") !== ns) {
                        break;
                    } if (e.nodeName === "text") {
                        condition = e.textContent;
                    } else {
                        condition = e.nodeName;
                    }
                }

                var errorString = "WebSocket stream error: ";

                if (condition) {
                    errorString += condition;
                } else {
                    errorString += "unknown";
                }

                Strophe.error(errorString);
                // close the connection on stream_error
                this._conn._changeConnectStatus(connectstatus, condition);
                this._conn._doDisconnect();
                return true;
            },

            /** PrivateFunction: _reset
             *  Reset the connection.
             *
             *  This function is called by the reset function of the Strophe Connection.
             *  Is not needed by WebSockets.
             */
            _reset: function () {
                return;
            },

            /** PrivateFunction: _connect
             *  _Private_ function called by Strophe.Connection.connect
             *
             *  Creates a WebSocket for a connection and assigns Callbacks to it.
             *  Does nothing if there already is a WebSocket.
             */
            _connect: function () {
                // Ensure that there is no open WebSocket from a previous Connection.
                this._closeSocket();

                // Create the new WobSocket
                this.socket = new WebSocket(this._conn.service, "xmpp");
                this.socket.onopen = this._onOpen.bind(this);
                this.socket.onerror = this._onError.bind(this);
                this.socket.onclose = this._onClose.bind(this);
                this.socket.onmessage = this._connect_cb_wrapper.bind(this);
            },

            /** PrivateFunction: _connect_cb
             *  _Private_ function called by Strophe.Connection._connect_cb
             *
             * checks for stream:error
             *
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _connect_cb: function(bodyWrap) {
                var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
                if (error) {
                    return Strophe.Status.CONNFAIL;
                }
            },

            /** PrivateFunction: _handleStreamStart
             * _Private_ function that checks the opening <open /> tag for errors.
             *
             * Disconnects if there is an error and returns false, true otherwise.
             *
             *  Parameters:
             *    (Node) message - Stanza containing the <open /> tag.
             */
            _handleStreamStart: function(message) {
                var error = false;

                // Check for errors in the <open /> tag
                var ns = message.getAttribute("xmlns");
                if (typeof ns !== "string") {
                    error = "Missing xmlns in <open />";
                } else if (ns !== Strophe.NS.FRAMING) {
                    error = "Wrong xmlns in <open />: " + ns;
                }

                var ver = message.getAttribute("version");
                if (typeof ver !== "string") {
                    error = "Missing version in <open />";
                } else if (ver !== "1.0") {
                    error = "Wrong version in <open />: " + ver;
                }

                if (error) {
                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
                    this._conn._doDisconnect();
                    return false;
                }

                return true;
            },

            /** PrivateFunction: _connect_cb_wrapper
             * _Private_ function that handles the first connection messages.
             *
             * On receiving an opening stream tag this callback replaces itself with the real
             * message handler. On receiving a stream error the connection is terminated.
             */
            _connect_cb_wrapper: function(message) {
                if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
                    // Strip the XML Declaration, if there is one
                    var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
                    if (data === '') return;

                    var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
                    this._conn.xmlInput(streamStart);
                    this._conn.rawInput(message.data);

                    //_handleStreamSteart will check for XML errors and disconnect on error
                    if (this._handleStreamStart(streamStart)) {
                        //_connect_cb will check for stream:error and disconnect on error
                        this._connect_cb(streamStart);
                    }
                } else if (message.data.indexOf("<close ") === 0) { //'<close xmlns="urn:ietf:params:xml:ns:xmpp-framing />') {
                    this._conn.rawInput(message.data);
                    this._conn.xmlInput(message);
                    var see_uri = message.getAttribute("see-other-uri");
                    if (see_uri) {
                        this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
                        this._conn.reset();
                        this._conn.service = see_uri;
                        this._connect();
                    } else {
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
                        this._conn._doDisconnect();
                    }
                } else {
                    var string = this._streamWrap(message.data);
                    var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
                    this.socket.onmessage = this._onMessage.bind(this);
                    this._conn._connect_cb(elem, null, message.data);
                }
            },

            /** PrivateFunction: _disconnect
             *  _Private_ function called by Strophe.Connection.disconnect
             *
             *  Disconnects and sends a last stanza if one is given
             *
             *  Parameters:
             *    (Request) pres - This stanza will be sent before disconnecting.
             */
            _disconnect: function (pres, dontClose) {
                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                    if (pres) {
                        this._conn.send(pres);
                    }
                    if (dontClose !== true) {
                        var close = $build("close", { "xmlns": Strophe.NS.FRAMING });
                        this._conn.xmlOutput(close);
                        var closeString = Strophe.serialize(close);
                        this._conn.rawOutput(closeString);
                        try {
                            this.socket.send(closeString);
                        } catch (e) {
                            Strophe.info("Couldn't send <close /> tag.");
                        }
                    }
                }
                this._conn._doDisconnect();
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  Just closes the Socket for WebSockets
             */
            _doDisconnect: function () {
                Strophe.info("WebSockets _doDisconnect was called");
                this._closeSocket();
            },

            /** PrivateFunction _streamWrap
             *  _Private_ helper function to wrap a stanza in a <stream> tag.
             *  This is used so Strophe can process stanzas from WebSockets like BOSH
             */
            _streamWrap: function (stanza) {
                return "<wrapper>" + stanza + '</wrapper>';
            },


            /** PrivateFunction: _closeSocket
             *  _Private_ function to close the WebSocket.
             *
             *  Closes the socket if it is still open and deletes it
             */
            _closeSocket: function () {
                if (this.socket) { try {
                    this.socket.close();
                } catch (e) {} }
                this.socket = null;
            },

            /** PrivateFunction: _emptyQueue
             * _Private_ function to check if the message queue is empty.
             *
             *  Returns:
             *    True, because WebSocket messages are send immediately after queueing.
             */
            _emptyQueue: function () {
                return true;
            },

            /** PrivateFunction: _onClose
             * _Private_ function to handle websockets closing.
             *
             * Nothing to do here for WebSockets
             */
            _onClose: function(e) {
                if(this._conn.connected && !this._conn.disconnecting) {
                    Strophe.error("Websocket closed unexpectedly");
                    this._conn._doDisconnect();
                } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {
                    // in case the onError callback was not called (Safari 10 does not
                    // call onerror when the initial connection fails) we need to
                    // dispatch a CONNFAIL status update to be consistent with the
                    // behavior on other browsers.
                    Strophe.error("Websocket closed unexcectedly");
                    this._conn._changeConnectStatus(
                        Strophe.Status.CONNFAIL,
                        "The WebSocket connection could not be established or was disconnected."
                    );
                    this._conn._doDisconnect();
                } else {
                    Strophe.info("Websocket closed");
                }
                // if(this._conn.connected && !this._conn.disconnecting) {
                //     Strophe.error("Websocket closed unexpectedly");
                //     this._conn._doDisconnect();
                // } else {
                //     this._conn._changeConnectStatus(Strophe.Status.DISCONNECTED, "Socket closed, probably due to no network connectivity."); // Leon Revill: 14th June 2017
                //     Strophe.info("Websocket closed");
                // }
            },

            /** PrivateFunction: _no_auth_received
             *
             * Called on stream start/restart when no stream:features
             * has been received.
             */
            _no_auth_received: function (_callback) {
                Strophe.error("Server did not send any auth methods");
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
                if (_callback) {
                    _callback = _callback.bind(this._conn);
                    _callback();
                }
                this._conn._doDisconnect();
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  This does nothing for WebSockets
             */
            _onDisconnectTimeout: function () {},

            /** PrivateFunction: _abortAllRequests
             *  _Private_ helper function that makes sure all pending requests are aborted.
             */
            _abortAllRequests: function () {},

            /** PrivateFunction: _onError
             * _Private_ function to handle websockets errors.
             *
             * Parameters:
             * (Object) error - The websocket error.
             */
            _onError: function(error) {
                Strophe.error("Websocket error " + error);
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");
                this._disconnect();
            },

            /** PrivateFunction: _onIdle
             *  _Private_ function called by Strophe.Connection._onIdle
             *
             *  sends all queued stanzas
             */
            _onIdle: function () {
                if (this.socket === null) return;
                var data = this._conn._data;
                if (data.length > 0 && !this._conn.paused) {
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] !== null) {
                            var stanza, rawStanza;
                            if (data[i] === "restart") {
                                stanza = this._buildStream().tree();
                            } else {
                                stanza = data[i];
                            }
                            rawStanza = Strophe.serialize(stanza);
                            this._conn.xmlOutput(stanza);
                            this._conn.rawOutput(rawStanza);
                            this.socket.send(rawStanza);
                        }
                    }
                    this._conn._data = [];
                }
            },

            /** PrivateFunction: _onMessage
             * _Private_ function to handle websockets messages.
             *
             * This function parses each of the messages as if they are full documents.
             * [TODO : We may actually want to use a SAX Push parser].
             *
             * Since all XMPP traffic starts with
             *  <stream:stream version='1.0'
             *                 xml:lang='en'
             *                 xmlns='jabber:client'
             *                 xmlns:stream='http://etherx.jabber.org/streams'
             *                 id='3697395463'
             *                 from='SERVER'>
             *
             * The first stanza will always fail to be parsed.
             *
             * Additionally, the seconds stanza will always be <stream:features> with
             * the stream NS defined in the previous stanza, so we need to 'force'
             * the inclusion of the NS in this stanza.
             *
             * Parameters:
             * (string) message - The websocket message.
             */
            _onMessage: function(message) {
                var elem, data;
                // check for closing stream
                var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                if (message.data === close) {
                    this._conn.rawInput(close);
                    this._conn.xmlInput(message);
                    if (!this._conn.disconnecting) {
                        this._conn._doDisconnect();
                    }
                    return;
                } else if (message.data.search("<open ") === 0) {
                    // This handles stream restarts
                    elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
                    if (!this._handleStreamStart(elem)) {
                        return;
                    }
                } else {
                    data = this._streamWrap(message.data);
                    elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
                }

                if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
                    return;
                }

                //handle unavailable presence stanza before disconnecting
                if (this._conn.disconnecting &&
                    elem.firstChild.nodeName === "presence" &&
                    elem.firstChild.getAttribute("type") === "unavailable") {
                    this._conn.xmlInput(elem);
                    this._conn.rawInput(Strophe.serialize(elem));
                    // if we are already disconnecting we will ignore the unavailable stanza and
                    // wait for the </stream:stream> tag before we close the connection
                    return;
                }
                this._conn._dataRecv(elem, message.data);
            },

            /** PrivateFunction: _onOpen
             * _Private_ function to handle websockets connection setup.
             *
             * The opening stream tag is sent here.
             */
            _onOpen: function() {
                Strophe.info("Websocket open");
                var start = this._buildStream();
                this._conn.xmlOutput(start.tree());

                var startString = Strophe.serialize(start);
                this._conn.rawOutput(startString);
                this.socket.send(startString);
            },

            /** PrivateFunction: _reqToData
             * _Private_ function to get a stanza out of a request.
             *
             * WebSockets don't use requests, so the passed argument is just returned.
             *
             *  Parameters:
             *    (Object) stanza - The stanza.
             *
             *  Returns:
             *    The stanza that was passed.
             */
            _reqToData: function (stanza) {
                return stanza;
            },

            /** PrivateFunction: _send
             *  _Private_ part of the Connection.send function for WebSocket
             *
             * Just flushes the messages that are in the queue
             */
            _send: function () {
                this._conn.flush();
            },

            /** PrivateFunction: _sendRestart
             *
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function () {
                clearTimeout(this._conn._idleTimeout);
                this._conn._onIdle.bind(this._conn)();
            }
        };
        return Strophe;
    }));

    (function(root){
        if(true){
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                __WEBPACK_LOCAL_MODULE_5__,
                __WEBPACK_LOCAL_MODULE_6__,
                __WEBPACK_LOCAL_MODULE_7__
            ], __WEBPACK_AMD_DEFINE_RESULT__ = function (wrapper) {
                return wrapper;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
    })(this);


/* jshint ignore:end */


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function StreamManagement(StropheClient) {

    const Strophe = StropheClient.Strophe;

    /**
     * Overwrite the Strophe helper method so that it only does comparison on lowercase strings
     * @param el
     * @param name
     * @returns {boolean}
     */
    Strophe.isTagEqual = function (el, name) {
        return (el.tagName || el.node.tagName) === name;
    };

    /**
     * StropheJS - Stream Management XEP-0198
     *
     * This plugin implements stream mangemament ACK capabilities of the specs XEP-0198.
     * Note: Resumption is not supported in this current implementation.
     *
     * Reference: http://xmpp.org/extensions/xep-0198.html
     *
     * @class streamManagement
     */
    Strophe.addConnectionPlugin('streamManagement', {

        /**
         * @property {Boolean} logging: Set to true to enable logging regarding out of sync stanzas.
         */
        logging: true,

        /**
         * @property {Boolean} returnWholeStanza: Set to true to return the acknowledged stanzas, otherwise only return its ID.
         */
        returnWholeStanza: false,

        /**
         * @property {Boolean} autoSendCountOnEveryIncomingStanza: Set to true to send an 'a' response after every stanza.
         * @default false
         * @public
         */
        autoSendCountOnEveryIncomingStanza: false,

        /**
         * @property {Integer} requestResponseInterval: Set this value to send a request for counter on very interval
         * number of stanzas sent. Set to 0 to disable.
         * @default 5
         * @public
         */
        requestResponseInterval: 0,

        allowResume: true,

        /**
         * @property {Pointer} _c: Strophe connection instance.
         * @private
         */
        _c: null,

        /**
         * @property {String} _NS XMPP Namespace.
         * @private
         */
        _NS: 'urn:xmpp:sm:3',

        /**
         * @property {Boolean} _isStreamManagementEnabled
         * @private
         */
        _isStreamManagementEnabled: false,

        /**
         * @property {Integer} _serverProcesssedStanzasCounter: Keeps count of stanzas confirmed processed by the server.
         * The server is the source of truth of this value. It is the 'h' attribute on the latest 'a' element received
         * from the server.
         * @private
         */
        _serverProcesssedStanzasCounter: null,

        /**
         * @property {Integer} _clientProcessedStanzasCounter: Counter of stanzas received by the client from the server.
         * Client is the source of truth of this value. It is the 'h' attribute in the 'a' sent from the client to
         * the server.
         * @private
         */
        _clientProcessedStanzasCounter: null,

        /**
         * @property {Integer} _clientSentStanzasCounter
         * @private
         */
        _clientSentStanzasCounter: null,

        /**
         * Stores a reference to Strophe connection xmlOutput function to wrap counting functionality.
         * @method _originalXMLOutput
         * @type {Handler}
         * @private
         */
        _originalXMLOutput: null,

        /**
         * @property {Handler} _requestHandler: Stores reference to handler that process count request from server.
         * @private
         */
        _requestHandler: null,

        /**
         * @property {Handler} _incomingHandler: Stores reference to handler that processes incoming stanzas count.
         * @private
         */
        _incomingHandler: null,

        /**
         * @property {Integer} _requestResponseIntervalCount: Counts sent stanzas since last response request.
         */
        _requestResponseIntervalCount: 0,

        /**
         * @property {Queue} _unacknowledgedStanzas: Maintains a list of packet ids for stanzas which have yet to be acknowledged.
         */
        _unacknowledgedStanzas: [],

        /**
         * @property {Array} _acknowledgedStanzaListeners: Stores callbacks for each stanza acknowledged by the server.
         * Provides the packet id of the stanza as a parameter.
         * @private
         */
        _acknowledgedStanzaListeners: [],

        _counters: {
            incoming: 0,
            outgoing: 0,
            server: 0
        },

        addAcknowledgedStanzaListener: function (listener) {
            this._acknowledgedStanzaListeners.push(listener);
        },

        enable: function (max) {
            const attrs = {xmlns: this._NS, resume: this.allowResume};
            if (max) {
                try {
                    attrs.max = "" + (max / 1000);
                } catch (e) {
                    console.error(`Couldn't convert '${max}' to milliseconds:`, e);
                }
            }
            this._c.send(StropheClient.$build('enable', attrs));
            this._c.flush();
            this._c.pause();
        },

        requestAcknowledgement: function () {
            this._requestResponseIntervalCount = 0;
            this._c.send(StropheClient.$build('r', {xmlns: this._NS}));
        },

        getOutgoingCounter: function () {
            return this._counters.outgoing;
        },

        getServerProcessedCounter: function () {
            return this._counters.server;
        },

        getIncomingCounter: function () {
            return this._counters.incoming;
        },

        init: function (conn) {
            this._c = conn;
            Strophe.addNamespace('SM', this._NS);
            const counters = localStorage.getItem(this._c.options.instance_id + "_counters");
            if (counters !== null) {
                let json = null;
                try {
                    json = JSON.parse(counters);
                } catch (e) {}
                if (json !== null) {
                    this._counters = json;
                }
            }

            // Storing original xmlOutput function to use additional logic
            this._originalXMLOutput = this._c.xmlOutput;
            this._c.xmlOutput = this.xmlOutput.bind(this);
        },

        statusChanged: function (status, condition) {
            if (status === Strophe.Status.CONNECTED || status === Strophe.Status.DISCONNECTED) {

                this._requestResponseIntervalCount = 0;
                this._isStreamManagementEnabled = false;
                // don't reset the stanza counter if we are resuming the stream
                if (status === Strophe.Status.CONNECTED && condition !== "resumed") {
                    this._resetCounters();
                }

                // If we have just resumed then stream management is enabled
                if (status === Strophe.Status.CONNECTED && condition === "resumed") {
                    this._isStreamManagementEnabled = true;
                }

                this._unacknowledgedStanzas = [];

                if (this._requestHandler) {
                    this._c.deleteHandler(this._requestHandler);
                }

                if (this._incomingHandler) {
                    this._c.deleteHandler(this._incomingHandler);
                }

                this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, 'r');
                this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this), null, null);
            }
        },

        /**
         * This method overrides the send method implemented by Strophe.Connection
         * to count outgoing stanzas
         *
         * @method Send
         * @public
         */
        xmlOutput: function (elem) {
            function _shouldIncrease(element) {
                return (Strophe.isTagEqual(element, 'iq') || Strophe.isTagEqual(element, 'presence') || Strophe.isTagEqual(element, 'message'));
            }

            if (_shouldIncrease(elem)) {
                this._increaseSentStanzasCounter(elem);
            } else {
                // elem is a Strophe object on connection close, causes error :/
                if (elem.children !== undefined) {
                    var child;
                    for (var i = 0; i < elem.children.length; i++) {
                        child = elem.children[i];
                        if (_shouldIncrease()) {
                            this._increaseSentStanzasCounter(child);
                        }
                    }
                }
            }

            return this._originalXMLOutput.call(this._c, elem);
        },

        _incomingStanzaHandler: function (elem) {

            if (Strophe.isTagEqual(elem, 'enabled') && elem.getAttribute('xmlns') === this._NS) {
                this._isStreamManagementEnabled = true;
                this._c.resume();
            }

            if (Strophe.isTagEqual(elem, 'iq') || Strophe.isTagEqual(elem, 'presence') || Strophe.isTagEqual(elem, 'message')) {
                this._increaseReceivedStanzasCounter();

                if (this.autoSendCountOnEveryIncomingStanza) {
                    this._answerProcessedStanzas();
                }

                // If we got an error back from a previous message rollback the client sent stanza counter
                if (Strophe.isTagEqual(elem, 'message') && elem.getAttribute("type") === "error") {
                    this._counters.outgoing = (this._counters.outgoing - 1);
                }

            }

            if (Strophe.isTagEqual(elem, 'a')) {
                var handledCount = parseInt(elem.getAttribute('h'));
                this._handleAcknowledgedStanzas(handledCount, this._counters.server);
                this._counters.server = handledCount;
                this._persistCounters();
                if (this.requestResponseInterval > 0) {
                    this._requestResponseIntervalCount = 0;
                }
            }

            return true;
        },

        _handleAcknowledgedStanzas: function (reportedHandledCount, lastKnownHandledCount) {
            var delta = reportedHandledCount - lastKnownHandledCount;

            if (delta < 0) {
                this._throwError('New reported stanza count lower than previous. New: ' + reportedHandledCount + ' - Previous: ' + lastKnownHandledCount);
            }

            if (delta > this._unacknowledgedStanzas.length) {
                this._throwError('Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: ' + delta + ' - Unacknowledge Stanza Count: ' + this._unacknowledgedStanzas.length + ' - New: ' + reportedHandledCount + ' - Previous: ' + lastKnownHandledCount);
            }

            for (var i = 0; i < delta; i++) {
                var stanza = this._unacknowledgedStanzas.shift();
                for (var j = 0; j < this._acknowledgedStanzaListeners.length; j++) {
                    this._acknowledgedStanzaListeners[j](stanza);
                }
            }

            if (this.logging && this._unacknowledgedStanzas.length > 0) {
                console.warn('Unacknowledged stanzas', this._unacknowledgedStanzas);
            }
        },

        _handleServerRequestHandler: function () {
            this._answerProcessedStanzas();
            return true;
        },

        _answerProcessedStanzas: function (force) {
            if (this._isStreamManagementEnabled || force === true) {
                this._c.send(StropheClient.$build('a', {xmlns: this._NS, h: this._counters.incoming}));
            }
        },

        _increaseSentStanzasCounter: function (elem) {
            if (this._isStreamManagementEnabled) {
                this._unacknowledgedStanzas.push(this.returnWholeStanza ? elem : elem.getAttribute('id'));
                this._counters.outgoing++;
                this._persistCounters();
                if (this.requestResponseInterval > 0) {
                    this._requestResponseIntervalCount++;

                    if (this._requestResponseIntervalCount === this.requestResponseInterval) {
                        this.requestAcknowledgement();
                    }
                }
            }
        },

        _increaseReceivedStanzasCounter: function () {
            if (this._isStreamManagementEnabled) {
                this._counters.incoming++;
                this._persistCounters();
            }
        },

        _persistCounters: function () {
            localStorage.setItem(this._c.options.instance_id + "_counters", JSON.stringify(this._counters));
        },

        _resetCounters: function () {
            this._counters = {
                incoming: 0,
                outgoing: 0,
                server: 0
            };
            this._persistCounters();
        },

        _throwError: function (msg) {
            console.error(msg);
        },

    });

    return StropheClient;

}

/* harmony default export */ __webpack_exports__["a"] = (StreamManagement);


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 01/12/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
const users_worker_js_1 = __webpack_require__(70);
const utils_1 = __webpack_require__(31);
class UsersDirectory {
    constructor(instanceId, debug = false) {
        this._instanceId = null;
        this._worker = null;
        this._debug = false;
        this._db = null;
        this._dbName = null;
        this.initialised = false;
        this._workerResponseListeners = {};
        this._instanceId = instanceId;
        this._debug = debug;
        this._dbName = `${instanceId}_user_index`;
    }
    _onWorkerResponse(e) {
        if (e.data && this._debug) {
            // LR: This is currently causing too many logs, especially when we've got many
            // conversations in CM.
            // console.log(`Worker: ${e.data.msg}`);
        }
        if (e.data._id) {
            const callback = this._workerResponseListeners[e.data._id];
            if (!callback)
                return;
            const result = callback(e.data);
            if (result !== true)
                delete this._workerResponseListeners[e.data._id];
        }
        else {
            switch (e.data.action) {
                case "store-record":
                    const transaction = this._db.transaction([this._dbName], "readwrite");
                    transaction.oncomplete = () => {
                        this._postMessageToWorker({
                            action: "store-record-response",
                            success: true,
                            key: e.data.key
                        });
                    };
                    transaction.onerror = (err) => {
                        console.error(`Failed to put '${e.data.key}'.`);
                        this._postMessageToWorker({
                            key: e.data.key,
                            action: "store-record-response",
                            success: false,
                            msg: err.toString()
                        });
                    };
                    transaction.objectStore(this._dbName).put(e.data.record, e.data.key);
                    break;
                case "retrieve-record":
                    const getRequest = this._db.transaction([this._dbName]).objectStore(this._dbName).get(e.data.key);
                    getRequest.onsuccess = () => {
                        this._postMessageToWorker({
                            action: "retrieve-record-response",
                            success: true,
                            key: e.data.key,
                            record: getRequest.result
                        });
                    };
                    getRequest.onerror = (err) => {
                        console.error(`Failed to get ${e.data.key}:`, err);
                        this._postMessageToWorker({
                            key: e.data.key,
                            action: "retrieve-record-response",
                            success: false,
                            msg: err.toString(),
                            record: null
                        });
                    };
                    break;
            }
        }
    }
    _postMessageToWorker(data, cb) {
        if (this._worker === null)
            throw new Error("Worker has not been initialised!");
        const _id = utils_1.generateGuid();
        if (cb)
            this._workerResponseListeners[_id] = cb;
        this._worker.postMessage(Object.assign({}, data, { _id }));
    }
    /**
     * Method used to set-up the worker instance and initialise the database and index within the worker
     * @returns {Promise<string>}
     */
    initialise(keyBuffer, iVector) {
        return new Promise((resolve, reject) => {
            const openRequest = indexedDB.open(this._dbName);
            openRequest.onupgradeneeded = (event) => {
                event.target.result.createObjectStore(this._dbName);
            };
            openRequest.onerror = (err) => {
                console.error("Couldn't open IndexedDB database.", err);
            };
            openRequest.onsuccess = (event) => {
                this._db = event.target.result;
                this._worker = new Worker(window.URL.createObjectURL(new Blob([`const start = ${users_worker_js_1.default.toString()}; start.call(self);`], { type: "text/javascript" })));
                this._worker.onmessage = this._onWorkerResponse.bind(this);
                this._postMessageToWorker({
                    action: "initialise",
                    instanceId: this._instanceId,
                    key: keyBuffer,
                    iv: iVector,
                    debug: this._debug
                }, (data) => {
                    if (data.success === true) {
                        this.initialised = true;
                        resolve(data.msg);
                    }
                    else {
                        console.error(data.msg);
                        this.initialised = false;
                        this.destroy(true).then(() => {
                            reject(data.msg);
                        });
                    }
                    return false;
                });
            };
        });
    }
    /**
     * Method used to download any updates to the user directory from the specified endpoint
     * @param jid {String} - The JID of the user for authentication
     * @param pass {String} - The password of the user for authentication
     * @param endpoint {String} - The URL to the JSON containing the user directory
     * @returns {Promise<string>}
     */
    update(jid, pass, endpoint) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "fetch",
                endpoint: endpoint,
                jid: jid,
                pass: pass
            }, (data) => {
                if (data.success === true) {
                    resolve(data);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method used to perform a full-text search on all users within the directory which have been downloaded and indexed
     * Searchable fields are jid, prefix, firstName, lastName and title
     * @param query
     * @returns {Promise<string | DirectoryUser[]>}
     */
    search(query, fields) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "search",
                query: query,
                fields: fields || []
            }, (data) => {
                if (data.success === true) {
                    resolve(data.results);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method used to find a single user in the directory by the JID
     * @param {String} jid
     * @returns {Promise<DirectoryUser | string>}
     */
    getUserByJid(jid) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "jid-search",
                jid: jid
            }, (data) => {
                if (data.success === true) {
                    resolve(data.result);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method to return all users in the user directory - use at your own risk if there are many users in the directory
     * @returns {Promise<DirectoryUser[]>}
     */
    getAllUsers(excludeDeleted = false) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "get-all-users"
            }, (data) => {
                if (data.success === true) {
                    if (excludeDeleted) {
                        resolve(data.results.filter((u) => !u.deleted));
                    }
                    else {
                        resolve(data.results);
                    }
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method to destroy the database that the users are stored in
     * @returns {Promise<string>}
     */
    destroy(override = false) {
        if (this.initialised !== true && override === false)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._db.close();
            const deleteRequest = indexedDB.deleteDatabase(this._dbName);
            deleteRequest.onerror = (event) => {
                reject("Error deleting user directory database.");
            };
            deleteRequest.onsuccess = () => {
                this._db = null;
                this.initialised = false;
                resolve();
            };
            deleteRequest.onblocked = () => {
                reject("Couldn't delete user directory database due to the operation being blocked.");
            };
        });
    }
    static _resolvePath(path) {
        if (!path)
            return null;
        if (path.indexOf("http") === 0 || path.indexOf("//") === 0) {
            return path;
        }
        else {
            return (path.indexOf("/") === 0) ? window.location.origin + path : `${window.location.origin}/${path}`;
        }
    }
}
exports.UsersDirectory = UsersDirectory;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Wrapper class around setTimeout functionality which allows for pausing and resuming a timeout
 */

Object.defineProperty(exports, "__esModule", { value: true });
class Timer {
    /**
     * @param callback { Function } - The function to be executed when the timer has completed
     * @param duration { Number } - The number of milliseconds the timer should execute for
     */
    constructor(id, callback, duration, pauseable = true) {
        this._id = null;
        this._timeout = -1;
        this._startTime = -1;
        this._totalTimeRun = -1;
        this._complete = false;
        this._duration = -1;
        this._callback = null;
        this._paused = false;
        this._pauseable = false;
        this._id = id;
        this._duration = duration;
        this._callback = callback;
        this._startTime = new Date().getTime();
        this._timeout = setTimeout(this._callback, this._duration);
        this._pauseable = (pauseable !== false);
    }
    /**
     * @private
     * Private method used to calculate the time difference between when the timer started and the current time
     * @param time { Number } - The time to compare against now
     */
    _timeDiff(time) {
        return new Date().getTime() - time;
    }
    /**
     * Cancel the timer
     */
    cancel() {
        clearTimeout(this._timeout);
        this._paused = false;
    }
    /**
     * Pause the timer which can then be resumed
     */
    pause() {
        clearTimeout(this._timeout);
        this._totalTimeRun = this._timeDiff(this._startTime);
        this._complete = this._totalTimeRun >= this._duration;
        if (!this._complete)
            this._paused = true;
    }
    /**
     * Resume a paused timer
     */
    resume() {
        this._paused = false;
        this._timeout = (this._complete) ? -1 : setTimeout(this._callback, this._duration - this._totalTimeRun);
    }
    /**
     * End a timer
     */
    end() {
        this._paused = false;
        clearTimeout(this._timeout);
        this._callback();
    }
    /**
     * Restart the timer
     */
    restart() {
        this._paused = false;
        this._startTime = new Date().getTime();
        this._timeout = setTimeout(this._callback, this._duration);
    }
    get paused() {
        return this._paused;
    }
    get pauseable() {
        return this._pauseable;
    }
    get id() {
        return this._id;
    }
}
exports.default = Timer;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
///<reference path="interfaces.ts"/>
/**
 * Created by Graham.Mackenzie on 28/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
class VCardSimple {
    constructor() {
        this.nsResolve = function (prefix) {
            if (prefix == "vc") {
                return "vcard-temp";
            }
            return null;
        };
        this.json = {};
    }
    static fromXml(xml) {
        const newVCard = new VCardSimple();
        try {
            newVCard.initFromXML(xml);
        }
        catch (e) {
            console.error("Bad vCard: " + e);
            return undefined;
        }
        return newVCard;
    }
    static fromJSON(card) {
        const newVCard = new VCardSimple();
        newVCard.initFromJSON(card);
        return newVCard;
    }
    _extractEmail(email) {
        const newEmail = {};
        if (typeof email.USERID === "string") {
            newEmail.address = email.USERID;
        }
        if (email.HOME) {
            newEmail.home = true;
        }
        if (email.WORK) {
            newEmail.work = true;
        }
        if (email.INTERNET) {
            newEmail.internet = true;
        }
        if (email.PREF) {
            newEmail.pref = true;
        }
        if (email.X400) {
            newEmail.x400 = true;
        }
        return newEmail;
    }
    _extractTelephone(tel) {
        const newTel = {};
        if (typeof tel.NUMBER === "string") {
            newTel.number = tel.NUMBER;
        }
        if (tel.HOME) {
            newTel.home = true;
        }
        if (tel.WORK) {
            newTel.work = true;
        }
        if (tel.VOICE) {
            newTel.voice = true;
        }
        if (tel.FAX) {
            newTel.fax = true;
        }
        if (tel.PAGER) {
            newTel.pager = true;
        }
        if (tel.MSG) {
            newTel.msg = true;
        }
        if (tel.CELL) {
            newTel.cell = true;
        }
        if (tel.VIDEO) {
            newTel.video = true;
        }
        if (tel.BBS) {
            newTel.bbs = true;
        }
        if (tel.MODEM) {
            newTel.modem = true;
        }
        if (tel.ISDN) {
            newTel.isdn = true;
        }
        if (tel.PCS) {
            newTel.pcs = true;
        }
        if (tel.PREF) {
            newTel.pref = true;
        }
        return newTel;
    }
    _extractAddress(adr) {
        const newAdr = {};
        if (typeof adr.POBOX === "string") {
            newAdr.poBox = adr.POBOX;
        }
        if (typeof adr.EXTADD === "string") {
            newAdr.extraAddress = adr.EXTADD;
        }
        if (typeof adr.STREET === "string") {
            newAdr.street = adr.STREET;
        }
        if (typeof adr.LOCALITY === "string") {
            newAdr.locality = adr.LOCALITY;
        }
        if (typeof adr.REGION === "string") {
            newAdr.locality = adr.REGION;
        }
        if (typeof adr.PCODE === "string") {
            newAdr.locality = adr.PCODE;
        }
        if (typeof adr.CTRY === "string") {
            newAdr.locality = adr.CTRY;
        }
        if (adr.WORK) {
            newAdr.work = true;
        }
        if (adr.HOME) {
            newAdr.home = true;
        }
        if (adr.POSTAL) {
            newAdr.postal = true;
        }
        if (adr.PARCEL) {
            newAdr.parcel = true;
        }
        if (adr.DOM) {
            newAdr.dom = true;
        }
        if (adr.INTL) {
            newAdr.intl = true;
        }
        if (adr.PREF) {
            newAdr.pref = true;
        }
        return newAdr;
    }
    initFromXML(xml) {
        const obj = {};
        if (typeof xml.VERSION === "string") {
            obj["version"] = xml.VERSION;
        }
        if (typeof xml.FN === "string") {
            obj["fullName"] = xml.FN;
        }
        if (typeof xml.N === "object" && !Array.isArray(xml.N)) {
            obj["name"] = {};
            if (typeof xml.N.FAMILY === "string") {
                obj["name"]["family"] = xml.N.FAMILY;
            }
            if (typeof xml.N.GIVEN === "string") {
                obj["name"]["given"] = xml.N.GIVEN;
            }
            if (typeof xml.N.MIDDLE === "string") {
                obj["name"]["middle"] = xml.N.MIDDLE;
            }
            if (typeof xml.N.PREFIX === "string") {
                obj["name"]["prefix"] = xml.N.PREFIX;
            }
            if (typeof xml.N.SUFFIX === "string") {
                obj["name"]["suffix"] = xml.N.SUFFIX;
            }
        }
        if (typeof xml.NICKNAME === "string") {
            obj["nickName"] = xml.NICKNAME;
        }
        if (typeof xml.PHOTO === "object" && !Array.isArray(xml.PHOTO)) {
            obj["photo"] = {};
            if (typeof xml.PHOTO.TYPE === "string") {
                obj["photo"]["type"] = xml.PHOTO.TYPE;
            }
            if (typeof xml.PHOTO.BINVAL === "string") {
                obj["photo"]["binval"] = xml.PHOTO.BINVAL;
            }
        }
        if (typeof xml.BDAY === "string") {
            obj["birthday"] = xml.BDAY;
        }
        if (typeof xml.ADR === "object") {
            obj.address = [];
            if (Array.isArray(xml.ADR)) {
                xml.ADR.forEach((adr) => {
                    obj.address.push(this._extractAddress(adr));
                });
            }
            else {
                obj.address.push(this._extractAddress(xml.ADR));
            }
        }
        if (typeof xml.TEL === "object") {
            obj.telephone = [];
            if (Array.isArray(xml.TEL)) {
                xml.TEL.forEach((tel) => {
                    obj.telephone.push(this._extractTelephone(tel));
                });
            }
            else {
                obj.telephone.push(this._extractTelephone(xml.TEL));
            }
        }
        if (typeof xml.EMAIL === "object") {
            obj.email = [];
            if (Array.isArray(xml.EMAIL)) {
                xml.EMAIL.forEach((email) => {
                    obj.email.push(this._extractEmail(email));
                });
            }
            else {
                obj.email.push(this._extractEmail(xml.EMAIL));
            }
        }
        if (typeof xml.JABBERID === "string") {
            obj["jabberId"] = xml.JABBERID;
        }
        if (typeof xml.MAILER === "string") {
            obj["mailer"] = xml.MAILER;
        }
        if (typeof xml.TZ === "string") {
            obj["timeZone"] = xml.TZ;
        }
        if (typeof xml.GEO === "object" && !Array.isArray(xml.GEO)) {
            obj["geolocation"] = {};
            if (typeof xml.GEO.LAT === "string") {
                obj["geolocation"]["lat"] = xml.GEO.LAT;
            }
            if (typeof xml.GEO.LON === "string") {
                obj["geolocation"]["lng"] = xml.N.GIVEN;
            }
        }
        if (typeof xml.TITLE === "string") {
            obj["title"] = xml.TITLE;
        }
        if (typeof xml.ROLE === "string") {
            obj["role"] = xml.ROLE;
        }
        if (typeof xml.LOGO === "object" && !Array.isArray(xml.LOGO)) {
            obj["logo"] = {};
            if (typeof xml.LOGO.TYPE === "string") {
                obj["logo"]["type"] = xml.PHOTO.TYPE;
            }
            if (typeof xml.PHOTO.BINVAL === "string") {
                obj["logo"]["binval"] = xml.PHOTO.BINVAL;
            }
            if (typeof xml.PHOTO.EXTVAL === "string") {
                obj["logo"]["extval"] = xml.PHOTO.EXTVAL;
            }
        }
        if (typeof xml.AGENT === "object" && !Array.isArray(xml.AGENT)) {
            obj["agent"] = {};
            if (typeof xml.AGENT.EXTVAL === "string") {
                obj["agent"]["extval"] = xml.AGENT.EXTVAL;
            }
        }
        if (typeof xml.ORG === "object" && !Array.isArray(xml.ORG)) {
            obj["organisation"] = {};
            if (typeof xml.ORG.ORGNAME === "string") {
                obj["organisation"]["name"] = xml.ORG.ORGNAME;
            }
            if (typeof xml.ORG.ORGUNIT === "string") {
                obj["organisation"]["unit"] = xml.ORG.ORGUNIT;
            }
        }
        if (typeof xml.CATEGORIES === "object") {
            obj.categories = [];
            if (Array.isArray(xml.CATEGORIES)) {
                xml.CATEGORIES.forEach((cat) => {
                    obj.categories.push({
                        "keyword": cat.KEYWORD
                    });
                });
            }
            else {
                obj.telephone.push({
                    "keyword": xml.CATEGORIES.KEYWORD
                });
            }
        }
        if (typeof xml.NOTE === "string") {
            obj["note"] = xml.NOTE;
        }
        if (typeof xml.PRODID === "string") {
            obj["prodid"] = xml.PRODID;
        }
        if (typeof xml.REV === "string") {
            obj["rev"] = xml.REV;
        }
        if (typeof xml["SORT-STRING"] === "string") {
            obj["sortString"] = xml["SORT-STRING"];
        }
        if (typeof xml.SOUND === "object" && !Array.isArray(xml.SOUND)) {
            obj["sound"] = {};
            if (typeof xml.SOUND.PHONETIC === "string") {
                obj["sound"]["phonetic"] = xml.SOUND.PHONETIC;
            }
            if (typeof xml.SOUND.BINVAL === "string") {
                obj["sound"]["binval"] = xml.SOUND.BINVAL;
            }
            if (typeof xml.SOUND.EXTVAL === "string") {
                obj["sound"]["extval"] = xml.SOUND.EXTVAL;
            }
        }
        if (typeof xml.UID === "string") {
            obj["uid"] = xml.UID;
        }
        if (typeof xml.URL === "string") {
            obj["url"] = xml.URL;
        }
        if (typeof xml.DESC === "string") {
            obj["description"] = xml.DESC;
        }
        if (typeof xml.CLASS === "object" && !Array.isArray(xml.CLASS)) {
            if (xml.CLASS.PUBLIC) {
                obj["classification"] = "public";
            }
            if (xml.CLASS.PRIVATE) {
                obj["classification"] = "private";
            }
            if (xml.CLASS.CONFIDENTIAL) {
                obj["classification"] = "confidential";
            }
        }
        if (typeof xml.KEY === "object" && !Array.isArray(xml.KEY)) {
            obj["key"] = {};
            if (typeof xml.KEY.CRED === "string") {
                obj["key"]["credential"] = xml.KEY.CRED;
            }
            if (typeof xml.KEY.TYPE === "string") {
                obj["key"]["type"] = xml.KEY.TYPE;
            }
        }
        this.json = obj;
    }
    initFromJSON(card) {
        this.json = card;
    }
    toJSON() {
        return this.json;
    }
    toXML(includeParent) {
        const doc = (new DOMParser()).parseFromString('<vCard xmlns="vcard-temp"/>', 'text/xml');
        const rootElement = doc.firstElementChild;
        this.json.fullName && this.addNode(rootElement, "FN", this.json.fullName);
        if (this.json.name) {
            const nameElement = this.addNode(rootElement, "N");
            this.json.name.family && this.addNode(nameElement, "FAMILY", this.json.name.family);
            this.json.name.given && this.addNode(nameElement, "GIVEN", this.json.name.given);
            this.json.name.middle && this.addNode(nameElement, "MIDDLE", this.json.name.middle);
            this.json.name.prefix && this.addNode(nameElement, "PREFIX", this.json.name.prefix);
            this.json.name.suffix && this.addNode(nameElement, "SUFFIX", this.json.name.suffix);
        }
        this.json.nickName && this.addNode(rootElement, "NICKNAME", this.json.nickName);
        if (this.json.photo) {
            const photoElement = this.addNode(rootElement, "PHOTO");
            this.json.photo.type && this.addNode(photoElement, "TYPE", this.json.photo.type);
            this.json.photo.binval && this.addNode(photoElement, "BINVAL", this.json.photo.binval);
        }
        this.json.birthday && this.addNode(rootElement, "BDAY", this.json.birthday);
        if (this.json.address) {
            this.json.address.forEach((address) => {
                const adrElement = this.addNode(rootElement, "ADR");
                if (address.home)
                    this.addNode(adrElement, "HOME");
                if (address.work)
                    this.addNode(adrElement, "WORK");
                if (address.postal)
                    this.addNode(adrElement, "POSTAL");
                if (address.parcel)
                    this.addNode(adrElement, "PARCEL");
                if (address.dom)
                    this.addNode(adrElement, "DOM");
                if (address.intl)
                    this.addNode(adrElement, "INTL");
                if (address.pref)
                    this.addNode(adrElement, "PREF");
                address.poBox && this.addNode(adrElement, "POBOX", address.poBox);
                address.extraAddress && this.addNode(adrElement, "EXTADD", address.extraAddress);
                address.street && this.addNode(adrElement, "STREET", address.street);
                address.locality && this.addNode(adrElement, "LOCALITY", address.locality);
                address.region && this.addNode(adrElement, "REGION", address.region);
                address.postcode && this.addNode(adrElement, "PCODE", address.postcode);
                address.country && this.addNode(adrElement, "CTRY", address.country);
            });
        }
        if (this.json.telephone) {
            this.json.telephone.forEach((telephone) => {
                const telElement = this.addNode(rootElement, "TEL");
                if (telephone.home)
                    this.addNode(telElement, "HOME");
                if (telephone.work)
                    this.addNode(telElement, "WORK");
                if (telephone.voice)
                    this.addNode(telElement, "VOICE");
                if (telephone.fax)
                    this.addNode(telElement, "FAX");
                if (telephone.pager)
                    this.addNode(telElement, "PAGER");
                if (telephone.msg)
                    this.addNode(telElement, "MSG");
                if (telephone.cell)
                    this.addNode(telElement, "CELL");
                if (telephone.video)
                    this.addNode(telElement, "VIDEO");
                if (telephone.bbs)
                    this.addNode(telElement, "BBS");
                if (telephone.modem)
                    this.addNode(telElement, "MODEM");
                if (telephone.isdn)
                    this.addNode(telElement, "ISDN");
                if (telephone.pcs)
                    this.addNode(telElement, "PCS");
                if (telephone.pref)
                    this.addNode(telElement, "PREF");
                telephone.number && this.addNode(telElement, "NUMBER", telephone.number);
            });
        }
        if (this.json.email) {
            this.json.email.forEach((email) => {
                const emailElement = this.addNode(rootElement, "EMAIL");
                if (email.home)
                    this.addNode(emailElement, "HOME");
                if (email.work)
                    this.addNode(emailElement, "WORK");
                if (email.internet)
                    this.addNode(emailElement, "INTERNET");
                if (email.pref)
                    this.addNode(emailElement, "PREF");
                if (email.x400)
                    this.addNode(emailElement, "X400");
                email.address && this.addNode(emailElement, "USERID", email.address);
            });
        }
        this.json.jabberId && this.addNode(rootElement, "JABBERID", this.json.jabberId);
        this.json.mailer && this.addNode(rootElement, "MAILER", this.json.mailer);
        this.json.timeZone && this.addNode(rootElement, "TZ", this.json.timeZone);
        if (this.json.geolocation) {
            const geoElement = this.addNode(rootElement, "GEO");
            this.json.geolocation.lat && this.addNode(geoElement, "LAT", this.json.geolocation.lat);
            this.json.geolocation.lng && this.addNode(geoElement, "LON", this.json.geolocation.lng);
        }
        this.json.title && this.addNode(rootElement, "TITLE", this.json.title);
        this.json.role && this.addNode(rootElement, "ROLE", this.json.role);
        if (this.json.logo) {
            const logoElement = this.addNode(rootElement, "LOGO");
            this.json.logo.type && this.addNode(logoElement, "TYPE", this.json.logo.type);
            this.json.logo.binval && this.addNode(logoElement, "BINVAL", this.json.logo.binval);
            this.json.logo.extval && this.addNode(logoElement, "EXTVAL", this.json.logo.extval);
        }
        // TODO: AGENT
        if (this.json.organisation) {
            const orgElement = this.addNode(rootElement, "ORG");
            this.json.organisation.name && this.addNode(orgElement, "ORGNAME", this.json.organisation.name);
            this.json.organisation.unit && this.addNode(orgElement, "ORGUNIT", this.json.organisation.unit);
        }
        if (this.json.categories) {
            this.json.categories.forEach((category) => {
                const catElement = this.addNode(rootElement, "CATEGORIES");
                category.keyword && this.addNode(catElement, "KEYWORD", category.keyword);
            });
        }
        this.json.note && this.addNode(rootElement, "NOTE", this.json.note);
        this.json.productId && this.addNode(rootElement, "PRODID", this.json.productId);
        this.json.lastRevised && this.addNode(rootElement, "REV", this.json.lastRevised);
        this.json.sortString && this.addNode(rootElement, "SORT-STRING", this.json.sortString);
        if (this.json.sound) {
            const soundElement = this.addNode(rootElement, "SOUND");
            this.json.sound.phonetic && this.addNode(soundElement, "PHONETIC", this.json.sound.phonetic);
            this.json.sound.extval && this.addNode(soundElement, "EXTVAL", this.json.sound.extval);
            this.json.sound.binval && this.addNode(soundElement, "BINVAL", this.json.sound.binval);
        }
        this.json.uid && this.addNode(rootElement, "UID", this.json.uid);
        this.json.url && this.addNode(rootElement, "URL", this.json.url);
        this.json.description && this.addNode(rootElement, "DESC", this.json.description);
        if (this.json.classification) {
            const classElement = this.addNode(rootElement, "CLASS");
            this.json.classification === "public" && this.addNode(classElement, "PUBLIC");
            this.json.classification === "private" && this.addNode(classElement, "PRIVATE");
            this.json.classification === "confidential" && this.addNode(classElement, "CONFIDENTIAL");
        }
        if (this.json.key) {
            const keyElement = this.addNode(rootElement, "KEY");
            this.json.key.credential && this.addNode(keyElement, "CRED", this.json.key.credential);
            this.json.key.type && this.addNode(keyElement, "TYPE", this.json.key.type);
        }
        let xml = "";
        if (includeParent) {
            xml = (new XMLSerializer()).serializeToString(doc);
        }
        else {
            const rootNode = doc.children[0];
            for (let i = 0; i < rootNode.childElementCount; i++) {
                console.log(rootNode.childNodes.item(i));
                const yml = (new XMLSerializer()).serializeToString(rootNode.childNodes.item(i));
                xml += yml;
            }
        }
        return xml;
    }
    addNode(parent, nodeName, textContent) {
        const newElement = parent.ownerDocument.createElement(nodeName);
        parent.appendChild(newElement);
        if (textContent !== undefined) {
            newElement.textContent = textContent;
        }
        return newElement;
    }
}
exports.VCardSimple = VCardSimple;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ct_xmpp_client_1 = __webpack_require__(21);
const LayerRegistration_1 = __webpack_require__(45);
const Logger_1 = __webpack_require__(17);
const i18n_1 = __webpack_require__(193);
const Models = __webpack_require__(1);
const Events = __webpack_require__(9);
const Errors = __webpack_require__(25);
const Utils = __webpack_require__(2);
const events_1 = __webpack_require__(9);
const Events_1 = __webpack_require__(4);
class BaseLayer {
    // === Constructor === //
    constructor(name, config) {
        this.messageQueueProcessorDebounce = null;
        // === Protected fields === //
        this.suppressMode = false;
        this._messageHandlers = new Map();
        this._messageProcessorQueue = Promise.resolve();
        this._suppressModeQueue = [];
        this._deferredStanzas = [];
        this._waitingAlertId = null;
        this._isProcessing = false;
        if (!config)
            throw new Error("You must supply a config object");
        if (config.i18n && config.i18n.enabled) {
            Utils.setLocale(config.i18n.locale || config.i18n.language || "en-GB");
        }
        else {
            Utils.setLocale("en-GB");
        }
        this.name = name;
        this.config = config;
        this._eventListeners = {};
        this.logger = new Logger_1.Logger(this.config.logging || []);
        this._setUpHandlers();
        document.addEventListener("backbutton", () => {
            if (this._backHandler)
                this._backHandler();
        }, false);
        LayerRegistration_1.LayerRegistration.addInstance(this.name, this);
    }
    // === Static instance registration === //
    static getInstance(name) {
        return LayerRegistration_1.LayerRegistration.getInstance(name);
    }
    static onReady(name, callback) {
        LayerRegistration_1.LayerRegistration.onReady(name, callback);
    }
    moveTaskToBack() {
        this.emit(events_1.BaseEvents.MoveTaskToBack);
    }
    setBackHandler(handler) {
        this._oldBackHandler = this._backHandler;
        this._backHandler = handler;
    }
    popBackHandler() {
        this._backHandler = this._oldBackHandler;
    }
    isProcessing() {
        return this._isProcessing;
    }
    bootstrap(comms, store) {
        this._buildCommonComponents();
        return Promise.resolve()
            .then(() => this._setStore(store))
            .then(() => this._setLogger())
            .then(() => this._setComms(comms))
            .then(() => this._setupPushNotifications())
            .then(() => this._setupCommonEventListeners())
            .then(() => LayerRegistration_1.LayerRegistration.fireReady(this.name))
            .catch((err) => {
            LayerRegistration_1.LayerRegistration.fireReady(this.name);
            setTimeout(() => {
                this.error("Error during bootstrap", err);
            }, 100);
        });
    }
    // === Event/action handlers === //
    on(name, callback, oneTimeOnly = false, allowSuppress = false) {
        if (this._eventListeners[name] === undefined) {
            this._eventListeners[name] = [];
        }
        const listenerId = Utils.generateRandomSixString();
        const eventDetail = {
            id: listenerId,
            oneTimeOnly: oneTimeOnly,
            allowSuppress: allowSuppress,
            callback: (evt) => __awaiter(this, void 0, void 0, function* () {
                yield callback(evt.detail);
            })
        };
        this._eventListeners[name].push(eventDetail);
        // return an unsubscribe function
        return () => {
            const idx = this._eventListeners[name].findIndex(x => x.id === listenerId);
            if (idx !== -1) {
                return this._eventListeners[name].splice(idx, 1)[0];
            }
        };
    }
    emit(name, data, cancelSuppress = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const emitPromises = [Promise.resolve()];
            if (!this._eventListeners[name]) {
                this._eventListeners[name] = [];
            }
            this.logger.log(Logger_1.LoggerTypes.Events, `%c RAISING EVENT:%c ${name} (${this._eventListeners[name].length} listeners)`, "color: #066; font-weight: bold;", "color: #999; font-weight: normal;", { data: data });
            const indexesToRemove = [];
            for (let i = 0; i < this._eventListeners[name].length; i++) {
                const eventListener = this._eventListeners[name][i];
                if (!this.suppressMode || !eventListener.allowSuppress || cancelSuppress) {
                    emitPromises.push(eventListener.callback({ detail: data }));
                }
                if (eventListener.oneTimeOnly === true) {
                    indexesToRemove.push(i);
                }
            }
            if (indexesToRemove.length) {
                this._eventListeners[name] = this._eventListeners[name].filter((x, idx) => !indexesToRemove.includes(idx));
            }
            yield Promise.all(emitPromises);
        });
    }
    login(user, password) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.login(user, password);
        });
    }
    attemptReconnect() {
        this.comms.attemptReconnect();
    }
    logout(forceCleanUp = false, fireEvents = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.logout(forceCleanUp, fireEvents);
        });
    }
    getSyncedTimestamp() {
        return this.comms.getSyncedTimestamp();
    }
    getConnectionStatus() {
        return this.comms.getConnectionStatus();
    }
    clearAllData(keepCache = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.store.clearAllData();
                yield this.comms.clearAllData(keepCache);
            }
            catch (ex) {
                this.error("Error clearing data", ex);
            }
        });
    }
    getCurrentUserJid() {
        return this.comms.username;
    }
    getCurrentUserResource() {
        return this.comms.getCurrentUserResource();
    }
    getCurrentUser() {
        return null; // TODO:KP: can we obtain at least the basic information of the current user via the XMPP Client?
    }
    getCurrentXmppDisplayName() {
        return this.comms.username;
    }
    updateUserDirectory() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.comms.updateUserDirectory();
        });
    }
    getUserByJid(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.getUserByJid(jid);
        });
    }
    getAllDirectoryUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.getAllDirectoryUsers();
        });
    }
    getGroupMemberCache() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log(Logger_1.LoggerTypes.Other, "Generating group member cache...");
            const groupMemberMap = new Map();
            const users = yield this.getAllDirectoryUsers();
            users.forEach(user => {
                const userGroups = user.group.split(", ");
                userGroups.forEach(userGroup => {
                    if (groupMemberMap[userGroup] === undefined) {
                        groupMemberMap[userGroup] = [];
                    }
                    groupMemberMap[userGroup].push(user);
                });
            });
            this.logger.log(Logger_1.LoggerTypes.Other, "Group member cache generated");
            return groupMemberMap;
        });
    }
    searchUsers(searchTerm = "", fields = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.searchUsers(searchTerm, fields);
        });
    }
    markChatEntryRead(chatEntry) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.comms.markMessageRead(chatEntry.id);
        });
    }
    downloadMessageAttachments(chatMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chatMessage.attachments || chatMessage.attachments.length === 0)
                return;
            return this.comms.downloadMessageAttachments(chatMessage.id);
        });
    }
    downloadFile(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.comms.downloadFile(url);
            }
            catch (ex) {
                this.error("Error downloading file", ex);
            }
        });
    }
    downloadFileWithoutCatch(url, bypassEncryption = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.downloadFile(url, bypassEncryption);
        });
    }
    processXmlStanzaStringsFromMam(stanzaStrings, dispatch = true) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.comms.processXmlStanzaStringsFromMam(stanzaStrings, dispatch);
            }
            catch (ex) {
                this.error("Error processing XML stanzas from MAM", ex);
            }
        });
    }
    error(title, friendlyError, realError = null) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cancelSuppressMode("*");
            this.dismissWaitingMessage();
            const errorMessage = (typeof (friendlyError) === "string")
                ? friendlyError
                : friendlyError.message || "Unknown error";
            this.emit(Events.BaseEvents._Request_RaiseAlert, new Models.DefaultAlerts(this).AlertErrorWithOkayButton(title, errorMessage, 1, {}));
            this.logger.error(realError || friendlyError);
        });
    }
    getLabel(labelName, data) {
        if (!this.config.labels || !this.config.labels[labelName])
            return null;
        const labelValue = this.translate(this.config.labels[labelName], false);
        return Utils.tokenReplace(labelValue, data);
    }
    translate(textKey, nullIfNotPresent = false) {
        if (!this.config.i18n || this.config.i18n.enabled !== true || typeof (this.config.i18n.translateFn) !== "function")
            return textKey;
        if (typeof (textKey) === "undefined")
            return undefined;
        if (textKey === null)
            return null;
        if (textKey === "")
            return "";
        const translation = this.config.i18n.translateFn(textKey);
        if (translation === null) {
            return (nullIfNotPresent === true)
                ? null
                : this.config.i18n.debugMode
                    ? ` ${textKey} `
                    : textKey;
        }
        return translation;
    }
    translateI18nItem(item) {
        if (!this.config.i18n || this.config.i18n.enabled !== true)
            return item.key;
        // try scoped key first
        const translation = this.translate(item.scopedKey, true);
        if (translation !== null)
            return translation;
        // try non-scoped key
        return this.translate(item.key);
    }
    getUniqueCommsId() {
        return this.comms.getUniqueId();
    }
    sendMessage(messageType, to, data, attachments = [], passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataClone = Utils.deepCloneObject(data);
            const message = yield this._prepareMessage(messageType, dataClone);
            if (message === null)
                return null;
            try {
                const serverEcho = yield this.comms.sendMessage(to, message, attachments);
                return Utils.parseMessagePayload(serverEcho, messageType);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending message", ex);
            }
        });
    }
    sendRoomChatMessage(roomName, text, attachments = [], useChatMarkers = true, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.comms.sendRoomMessage(roomName, text, null, attachments, useChatMarkers);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending room chat message", ex);
            }
        });
    }
    sendRoomMessage(roomName, messageType, data, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataClone = Utils.deepCloneObject(data);
            const message = yield this._prepareMessage(messageType, dataClone);
            if (message === null)
                return null;
            try {
                const serverEcho = yield this.comms.sendRoomMessage(roomName, null, message);
                return Utils.parseMessagePayload(serverEcho, messageType);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending room message", ex);
            }
        });
    }
    sendMulticastMessage(messageType, data, to, attachments = [], passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataClone = Utils.deepCloneObject(data);
            const message = yield this._prepareMessage(messageType, dataClone);
            if (message === null)
                return null;
            try {
                const serverEcho = yield this.comms.sendMulticastMessage(to, message, attachments);
                return Utils.parseMessagePayload(serverEcho, messageType);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else {
                    // A small hack to exclude stream management errors from interrupting the UI
                    // These are errors but they won't stop any functionality from working
                    // Awaiting a fix from Leon in the xmpp-client
                    if (typeof ex === "object") {
                        this.logger.error(ex);
                        this._workOutIfAttachmentTooLarge(ex);
                    }
                    else {
                        this.error("Error sending multicast message", ex);
                    }
                }
            }
        });
    }
    sendIq(to, type, messageType, data, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataClone = Utils.deepCloneObject(data);
            const handler = this._getHandlerForMessageType(messageType);
            if (!handler)
                return null;
            const iqPayload = yield this._prepareIq(messageType, dataClone);
            if (iqPayload === null)
                return null;
            let iqResponse = null;
            try {
                iqResponse = yield this.comms.sendIq(to, type, iqPayload);
            }
            catch (ex) {
                const iqError = ex;
                if (passThroughException)
                    throw iqError;
                else
                    return yield handler.callHandleIqErrorResponse(dataClone, iqError);
            }
            try {
                return yield handler.callHandleIqResponse(dataClone, iqResponse);
            }
            catch (ex) {
                const iqError = new Errors.IQError(ex.message || ex, iqResponse);
                if (passThroughException)
                    throw iqError;
                else
                    return yield handler.callHandleIqErrorResponse(dataClone, iqError);
            }
        });
    }
    sendMessageToBot(messageType, data, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataClone = Utils.deepCloneObject(data);
            try {
                yield this._sendBotCommand(messageType, dataClone, null);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending bot message", ex);
            }
        });
    }
    sendBotCommand(command, data, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataClone = Utils.deepCloneObject(data);
            try {
                return yield this.comms.sendBotCommand(command.toString(), dataClone);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending bot command", ex);
            }
        });
    }
    setSupportLoggingTypes(types = ["_all_"]) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.setTypes(types);
            return yield this.store.saveLoggerTypes(types);
        });
    }
    resetSupportLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.resetTypes();
            return yield this.store.deleteLoggerTypes();
        });
    }
    showWaitingMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.dismissWaitingMessage();
            const alert = new Models.DefaultAlerts(this).AlertWaiting(message);
            this._waitingAlertId = alert.id;
            this._alertModalManager.raiseAlert(alert);
        });
    }
    dismissWaitingMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._waitingAlertId) {
                this._alertModalManager.dismissAlertById(this._waitingAlertId);
                this._waitingAlertId = null;
            }
        });
    }
    enableSuppressMode(id, singleInstance = false) {
        if (id === "*")
            throw new Error("Suppress mode cannot be enabled with the id '*'");
        if (singleInstance && this._suppressModeQueue.includes(id)) {
            this.logger.log(Logger_1.LoggerTypes.Other, `%c SUPPRESSION MODE ALREADY EXISTS IN QUEUE %c${id}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
        }
        else {
            this.logger.log(Logger_1.LoggerTypes.Other, `%c ADDING TO SUPPRESSION MODE QUEUE %c${id}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
            this._suppressModeQueue.push(id);
        }
        this.logger.log(Logger_1.LoggerTypes.Other, "%c SUPPRESSION MODE QUEUE", "color: #696; font-weight: bold;", this._suppressModeQueue);
        if (!this.suppressMode) {
            this.logger.log(Logger_1.LoggerTypes.Other, "%c ENTERING SUPPRESSION MODE", "color: #696; font-weight: bold;");
            this.suppressMode = true;
        }
    }
    cancelSuppressMode(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._suppressModeQueue.length === 0)
                return;
            this._messageProcessorQueue = this._messageProcessorQueue.then(() => {
                return new Promise(resolve => {
                    if (id === "*") {
                        this.logger.log(Logger_1.LoggerTypes.Other, "%c CLEARING SUPPRESSION MODE QUEUE", "color: #696; font-weight: bold;");
                        this._suppressModeQueue = [];
                        this.suppressMode = false;
                    }
                    else {
                        const idx = this._suppressModeQueue.indexOf(id);
                        if (idx !== -1) {
                            this.logger.log(Logger_1.LoggerTypes.Other, `%c REMOVING FROM SUPPRESSION MODE QUEUE %c${id}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
                            this._suppressModeQueue.splice(idx, 1);
                            this.logger.log(Logger_1.LoggerTypes.Other, "%c SUPPRESSION MODE QUEUE", "color: #696; font-weight: bold;", this._suppressModeQueue);
                        }
                    }
                    if (this.suppressMode === true && this._suppressModeQueue.length === 0) {
                        this.logger.log(Logger_1.LoggerTypes.Other, "%c EXITING SUPPRESSION MODE", "color: #696; font-weight: bold;");
                        this.suppressMode = false;
                        if (this._deferredStanzas.length > 0) {
                            const deferredStanzas = [...this._deferredStanzas];
                            const deferredMessages = deferredStanzas.filter(x => x.eventType === ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE).map(x => x.payload.data);
                            this._deferredStanzas = [];
                            this.logger.log(Logger_1.LoggerTypes.Other, `%c HANDLING ${deferredMessages.length} DEFERRED MESSAGE(S) RECEIVED DURING SUPPRESSED MODE`, "color: #696; font-weight: bold;", deferredMessages);
                            deferredStanzas.forEach(x => {
                                switch (x.eventType) {
                                    case ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE:
                                        this.handleNewMessage(x.payload);
                                        break;
                                    case ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED:
                                        this.handleMessageUpdate(x.payload);
                                        break;
                                    case ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED:
                                        this.handleChatMarkerUpdate(x.payload);
                                        break;
                                }
                            });
                        }
                        else {
                            this.logger.log(Logger_1.LoggerTypes.Other, `%c NO MESSAGES RECEIVED DURING SUPPRESSED MODE`, "color: #696; font-weight: bold;");
                        }
                        this.logger.log(Logger_1.LoggerTypes.Other, "%c REDRAWING UIS", "color: #696; font-weight: bold;");
                        this.emit(Events.BaseEvents._Request_RedrawAllUIs);
                    }
                    resolve();
                });
            });
            return this._messageProcessorQueue;
        });
    }
    addDeferredStanza(stanza) {
        if (!this._deferredStanzas)
            this._deferredStanzas = [];
        this.logger.log(Logger_1.LoggerTypes.Other, `%c ADDING DEFERRED STANZA %c${stanza.id} > ${stanza.eventType}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;", { payload: stanza.payload });
        this._deferredStanzas.push(stanza);
    }
    removeDeferredStanza(id, eventType) {
        if (!this._deferredStanzas || !this._deferredStanzas.length)
            return;
        if (this._deferredStanzas.some(x => x.id === id && x.eventType === eventType)) {
            this.logger.log(Logger_1.LoggerTypes.Other, `%c REMOVING DEFERRED STANZA %c${id} > ${eventType}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
            this._deferredStanzas = this._deferredStanzas.filter(x => {
                return (x.id !== id || x.eventType !== eventType);
            });
        }
    }
    getHandlerForMessage(message) {
        const messageType = Utils.getMessageType(message);
        return this._getHandlerForMessageType(messageType);
    }
    setTheme(theme) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.store.saveTheme(theme);
            this._setThemeOnHtml(theme);
        });
    }
    // === Private functions === //
    _setComms(comms) {
        return new Promise((resolve, reject) => {
            const initTimeoutDuration = this.config.xmpp.initTimeout || 10000;
            const commsInitializationTimeout = setTimeout(() => {
                reject(`Comms was not initialised within ${Math.floor(initTimeoutDuration / 1000)} seconds. Aborting.`);
            }, initTimeoutDuration);
            this.comms = comms;
            this.comms.onLogin((data) => {
                this.comms.getServerVersion();
                this.handleLogin(data);
            });
            this.comms.onLogout((data) => {
                this.handleLogout(data);
            });
            this.comms.onNewMessage((message) => {
                this.handleNewMessage(message);
            });
            this.comms.onMessageUpdate((message) => {
                this.handleMessageUpdate(message);
            });
            this.comms.onChatMarkerUpdate((receipt) => {
                this.handleChatMarkerUpdate(receipt);
            });
            this.comms.onStatusUpdate((status, reconnectTime, disconnectStatus) => {
                this.handleConnectionChange(status, reconnectTime, disconnectStatus);
            });
            this.comms.onPresenceUpdate((contact) => {
                this.handlePresenceUpdate(contact);
            });
            this.comms.onRoomNewParticipant((participant) => {
                this.handleRoomParticipantUpdate(participant);
            });
            this.comms.onRoomParticipantUpdate((participant) => {
                this.handleRoomParticipantUpdate(participant);
            });
            this.comms.onStartFetchingMissedMessages(() => {
                this.enableSuppressMode("baseLayer#mam", true);
            });
            this.comms.onFinishedFetchingMissedMessages(() => {
                this.cancelSuppressMode("baseLayer#mam");
            });
            this.comms.onInitialized(() => {
                resolve();
                clearTimeout(commsInitializationTimeout);
                // attempt auto-login if user id, domain and password are present in the config
                if (this.config.xmpp.user.id && this.config.xmpp.user.password && this.config.xmpp.user.domain) {
                    this.showWaitingMessage(`Logging in as ${this.config.xmpp.user.id}`);
                    this._attemptAutoLogin(this.config.xmpp.user.id, this.config.xmpp.user.password, this.config.xmpp.user.domain);
                }
            });
        });
    }
    _setStore(store) {
        return new Promise(resolve => {
            this.store = store;
            this.store.init().then(() => resolve());
        });
    }
    _setLogger() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const existingLoggerTypes = yield this.store.getLoggerTypes();
            if (existingLoggerTypes) {
                this.logger.setTypes(existingLoggerTypes);
            }
            resolve();
        }));
    }
    _setupPushNotifications() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const win = window;
            if (this.config.enablePushNotifications && win.cordova) {
                if (win.cordova.plugins.notification) {
                    if (win.cti.store.notification && win.cti.store.notification.token) {
                        yield this.store.savePushNotificationToken(win.cti.store.notification.token);
                        resolve();
                    }
                    else {
                        win.cordova.plugins.notification.registerForPush((token) => __awaiter(this, void 0, void 0, function* () {
                            yield this.store.savePushNotificationToken(token);
                            resolve();
                        }), err => {
                            this.logger.error(err);
                            resolve();
                        }, {
                            channelName: this.name
                        });
                    }
                }
                else
                    resolve();
            }
            else
                resolve();
        }));
    }
    _setupCommonEventListeners() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Reload any previous theme
            const theme = yield this.store.getTheme();
            this._setThemeOnHtml(theme);
            this.on(Events.BaseEvents._Request_ThemeChange, (themeName) => __awaiter(this, void 0, void 0, function* () {
                yield this.store.saveTheme(themeName);
                this._setThemeOnHtml(themeName);
            }));
            resolve();
        }));
    }
    _setThemeOnHtml(themeName) {
        document.querySelector("html").setAttribute("theme", themeName);
        this.emit(Events.BaseEvents._Request_RedrawAllUIs);
    }
    _setUpHandlers() {
        this._messageHandlers = new Map();
        this.getHandlers().forEach(handler => {
            // add to message handlers
            if (handler.messageKey)
                this._messageHandlers.set(handler.messageKey, handler);
            // set up event handlers
            if (handler.eventType && handler.eventType.length) {
                handler.eventType.forEach(eventType => {
                    this.on(eventType, (e) => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield handler.callHandleEvent(eventType, e);
                        }
                        catch (ex) {
                            this.error("Error handling event", `Event type: ${eventType.toString()}. ${ex.message || ex}`);
                        }
                    }));
                });
            }
        });
    }
    _prepareMessage(messageType, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            const payload = yield handler.callCreateMessage(data);
            if (payload === null || payload === undefined)
                return null;
            return {
                [handler.messageKey]: JSON.stringify(payload)
            };
        });
    }
    _prepareIq(messageType, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            const payload = yield handler.callCreateIq(data);
            if (payload === null || payload === undefined)
                return null;
            return payload;
        });
    }
    _sendBotCommand(messageType, data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationName = messageType.toString();
            const message = yield this._prepareBotMessage(messageType, data, previousBotResponse);
            if (message === null)
                return;
            const botResponse = yield this.comms.sendBotCommand(operationName, message);
            if (botResponse && botResponse.success === false) {
                const shouldRetry = yield this._shouldRetryBotMessage(messageType, data, botResponse);
                if (shouldRetry === true) {
                    yield this._sendBotCommand(messageType, data, botResponse);
                }
            }
        });
    }
    _prepareBotMessage(messageType, data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            const payload = yield handler.callCreateBotMessage(data, previousBotResponse);
            if (payload === null || payload === undefined)
                return null;
            return {
                [handler.messageKey]: JSON.stringify(payload)
            };
        });
    }
    _shouldRetryBotMessage(messageType, data, botResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            return yield handler.callHandleFailedBotResponse(data, botResponse);
        });
    }
    _buildCommonComponents() {
        return __awaiter(this, void 0, void 0, function* () {
            const containerTag = "div";
            const containerId = "___ct_base_layer_modal_container";
            let container = document.querySelector(`${containerTag}#${containerId}`);
            if (!container) {
                container = document.createElement(containerTag);
                container.id = containerId;
                container.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0; z-index: 99999;");
                document.body.appendChild(container);
            }
            // get or add modal manager component
            this._alertModalManager = document.querySelector("ct-alert-modal-manager");
            if (!this._alertModalManager) {
                this._alertModalManager = document.createElement("ct-alert-modal-manager");
                this._alertModalManager.owner = this.name;
                container.appendChild(this._alertModalManager);
            }
            yield this.generateCommonComponents(container);
        });
    }
    _attemptAutoLogin(userId, password, domain) {
        return __awaiter(this, void 0, void 0, function* () {
            let username = `${userId}@${domain}`;
            if (this.config.xmpp.user && this.config.xmpp.user.forceLowercaseJid === true) {
                username = username.toLowerCase();
            }
            this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c ATTEMPTING AUTOMATIC LOGIN AS > %c${username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            yield this.comms.login(username, password);
        });
    }
    _getHandlerForMessageType(messageType) {
        if (!this._messageHandlers.get(messageType.toString())) {
            this.error("No handler found", `No handlers was found for message type '${messageType.toString()}'`);
        }
        return this._messageHandlers.get(messageType);
    }
    _workOutIfAttachmentTooLarge(ex) {
        const error = "There was an error sending the message, please try again.";
        if (ex.nodeName && ex.nodeName === "iq") {
            if (ex.childNodes && ex.childNodes[1] && ex.childNodes[1].nodeName === "error") {
                const error = ex.childNodes[1];
                if (error.childNodes && error.childNodes[1] && error.childNodes[1].nodeName === "text") {
                    const text = error.childNodes[1];
                    const fileSizeStr = text.textContent.match(/\d+/)[0];
                    const fileSize = fileSizeStr ? parseInt(fileSizeStr) : 0;
                    if (fileSize) {
                        const maxMb = Math.round(fileSize / 1024 / 1024);
                        const errorMsg = `The attachment is too large. Please select a file lower than ${maxMb}MB in size.`;
                        this.error("Attachment Too Large", errorMsg);
                        throw new Error(errorMsg);
                    }
                    else {
                        const errorMsg = "The attachment is too large. Please choose a smaller attachment.";
                        this.error("Attachment Too Large", errorMsg);
                        throw new Error(errorMsg);
                    }
                }
            }
        }
        this.error("Error sending multicast message", error);
        throw new Error(error);
    }
    // === Protected Functions === //
    handleLogin(data) {
        this.emit(Events.BaseEvents.LoginResult, data);
    }
    handleLogout(data) {
        this.emit(Events.BaseEvents.LogoutResult, data);
    }
    _finishedProcessing() {
        clearTimeout(this.messageQueueProcessorDebounce);
        this.messageQueueProcessorDebounce = setTimeout(() => {
            this._isProcessing = false;
            this.emit(Events_1.ChatEvents.MessageProcessorQueueEmpty);
        }, 1000);
    }
    handleNewMessage(message) {
        if (this.suppressMode === true && message.fromMam !== true) {
            this.addDeferredStanza({ id: message._id, eventType: ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, payload: message });
            return;
        }
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(message.jid, message.ts));
        const messageType = Utils.getMessageType(message);
        const parsedMessage = Utils.parseMessagePayload(message, messageType);
        const handler = this._getHandlerForMessageType(messageType);
        if (!handler)
            return;
        // chain message handling to end of promise queue
        this._messageProcessorQueue = this._messageProcessorQueue
            .then(() => __awaiter(this, void 0, void 0, function* () {
            try {
                this._isProcessing = true;
                this.removeDeferredStanza(message._id, ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE);
                this.logger.log(Logger_1.LoggerTypes.ProcessingReceived, `%c PROCESSING NEW MESSAGE:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", Utils.getMessageContentForDebug(parsedMessage));
                const p = yield handler.callHandleMessage(parsedMessage);
                this._finishedProcessing();
                return p;
            }
            catch (ex) {
                this.error("Error processing message", ex);
            }
        }))
            .catch(ex => this.error("Error processing message", ex));
    }
    handleMessageUpdate(message) {
        if (this.suppressMode === true) {
            this.addDeferredStanza({ id: message._id, eventType: ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, payload: message });
            return;
        }
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(message.jid, message.ts));
        const messageType = Utils.getMessageType(message);
        const parsedMessage = Utils.parseMessagePayload(message, messageType);
        const handler = this._getHandlerForMessageType(messageType);
        if (!handler)
            return;
        // chain message handling to end of promise queue
        this._messageProcessorQueue = this._messageProcessorQueue
            .then(() => __awaiter(this, void 0, void 0, function* () {
            try {
                this.removeDeferredStanza(message._id, ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED);
                this.logger.log(Logger_1.LoggerTypes.ProcessingUpdated, `%c PROCESSING MESSAGE UPDATE:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", Utils.getMessageContentForDebug(parsedMessage));
                const p = yield handler.callHandleMessageUpdate(parsedMessage);
                this._finishedProcessing();
                return p;
            }
            catch (ex) {
                this.error("Error processing message update", ex);
            }
        }))
            .catch(ex => this.error("Error processing message update", ex));
    }
    handleChatMarkerUpdate(update) {
        if (this.suppressMode === true) {
            this.addDeferredStanza({ id: update.message_id, eventType: ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, payload: update });
            return;
        }
        const receipt = Object.assign({}, update);
        let bareJidResource = `${receipt.sender_resource}@${this.config.xmpp.user.domain}`;
        if (this.config.xmpp.user && this.config.xmpp.user.forceLowercaseJid === true) {
            bareJidResource = bareJidResource.toLowerCase();
        }
        receipt.sender_resource = bareJidResource;
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(receipt.sender_resource, receipt.message.updated_at || receipt.message.ts));
        const messageType = Utils.getMessageType(receipt.message);
        const parsedMessage = Utils.parseMessagePayload(receipt.message, messageType);
        const parsedReceipt = Object.assign({}, receipt, { message: parsedMessage });
        const handler = this._getHandlerForMessageType(messageType);
        if (!handler)
            return;
        // chain message handling to end of promise queue
        this._messageProcessorQueue = this._messageProcessorQueue
            .then(() => __awaiter(this, void 0, void 0, function* () {
            try {
                this.removeDeferredStanza(update.message_id, ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED);
                const username = receipt.sender_resource.split("@").shift();
                this.logger.log(Logger_1.LoggerTypes.ProcessingChatMarker, `%c PROCESSING CHAT MARKER: %c${username} > ${receipt.type}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                const p = yield handler.callHandleMessageReceipt(parsedReceipt);
                this._finishedProcessing();
                return p;
            }
            catch (ex) {
                this.error("Error processing chat marker", ex);
            }
        }))
            .catch(ex => this.error("Error processing chat marker", ex));
    }
    handleRoomParticipantUpdate(update) {
        if (!update.jid)
            return;
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(update.jid, update.updated_at || update.ts));
        const role = (update.metadata && update.metadata.role)
            ? update.metadata.role
            : "";
        this.emit(Events.BaseEvents.RoomParticipantUpdate, new Events.RoomParticipantUpdateEventArgs(update.jid, update.room_name, role, Models.RoomRole[update.room_role]));
    }
    handleConnectionChange(status, reconnectTime, disconnectStatus) {
        this.comms.setConnectionStatus(status);
        BaseLayer.onReady(this.name, () => {
            this.emit(Events.BaseEvents.ConnectionStatusChange, new Events.ConnectionStatusEventArgs(status, reconnectTime, disconnectStatus));
        });
    }
    handlePresenceUpdate(contact) {
        if (contact.online) {
            this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(contact.id, this.getSyncedTimestamp()));
        }
        const connectionStatus = contact.online
            ? Models.ConnectionStatus.Connected
            : Models.ConnectionStatus.Disconnected;
        this.emit(Events.BaseEvents.OtherUserConnectionStatusChange, new Events.UserConnectionStatusEventArgs(contact.id, connectionStatus));
    }
    // === I18n static helper === //
    static getUniqueTranslationKeys(fullyQualified = false, ...scopes) {
        return i18n_1.getCommonI18nKeys(fullyQualified, ...scopes);
    }
}
exports.BaseLayer = BaseLayer;
// tslint:enable no-any


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(24);
const base_1 = __webpack_require__(0);
const LayerRegistration_1 = __webpack_require__(45);
const Logger_1 = __webpack_require__(17);
const models_1 = __webpack_require__(1);
const events_1 = __webpack_require__(9);
const CTBaseComponent_1 = __webpack_require__(44);
class CTLayerComponent extends CTBaseComponent_1.CTBaseComponent {
    constructor() {
        super(...arguments);
        this._connected = false;
        this._metadata = null;
        this._defaultAlerts = null;
        this._debouncers = {};
        this._listenerUnsubscribers = [];
    }
    get layer() {
        if (!this._baseLayer)
            return null;
        return this._baseLayer;
    }
    get metadata() {
        if (this.constructor.prototype._metadata === null && !this._metadata)
            throw new Error(`Metadata not set for component <${this.localName}>`);
        return this.constructor.prototype._metadata || this._metadata;
    }
    get defaultAlerts() {
        return this._defaultAlerts || (this._defaultAlerts = new models_1.DefaultAlerts(this._baseLayer));
    }
    // abstract get generateComponentStyles(): string;
    get generateComponentStyles() {
        return null;
    }
    // === Render lifecycle events === //
    getStyles() {
        if (this.styles && this.styles.length) {
            return this.styles.reduce((acc, cur) => acc += cur, "");
        }
        const componentStyles = this.generateComponentStyles;
        return componentStyles || "";
    }
    get componentStyles() {
        return this.getStyles();
    }
    componentMarkup() {
        if (!this.layer) {
            const parent = this._findParentCTLayerComponent();
            if (parent) {
                this._baseLayer = parent._baseLayer;
                this._initializeForBaseLayer();
            }
            if (!this._connected)
                return null;
            if (!this.layer) {
                if (parent) {
                    // tslint:disable-next-line no-console
                    console.error(`Component <${this.localName}> child of <${parent.localName}> does not have an owner layer specified`);
                }
                else {
                    // tslint:disable-next-line no-console
                    console.error(`Component <${this.localName}> does not have an owner layer specified`);
                }
                return skate.h("em", { style: { display: "inline-block", fontSize: "12px", color: "#900", backgroundColor: "#FF0", padding: "3px 6px" } }, `${this.localName}:`, skate.h("br"), "OWNER NOT SPECIFIED");
            }
        }
        return this.generateComponentMarkup();
    }
    // === Web component lifecycle events === //
    connectedCallback() {
        super.connectedCallback();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._listenerUnsubscribers.forEach(unsubscribe => unsubscribe());
    }
    attributeChangedCallback(name, oldVal, newVal) {
        super.attributeChangedCallback(name, oldVal, newVal);
        switch (name) {
            case "owner":
                if ((newVal !== oldVal) && (newVal !== "")) {
                    this.owner = newVal;
                    this._attemptConnectToBaseLayer();
                }
                break;
        }
    }
    // === Public utility functions === //
    setMetadata(metadata) {
        this._metadata = metadata;
    }
    defer(fn) {
        setTimeout(fn, 0);
    }
    debounce(name, action, duration = 100) {
        clearTimeout(this._debouncers[name]);
        this._debouncers[name] = setTimeout(() => {
            action();
            delete this._debouncers[name];
        }, duration);
    }
    cancelDebounce(name) {
        clearTimeout(this._debouncers[name]);
    }
    emitEvent(name, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._baseLayer) {
                yield this._baseLayer.emit(name, data);
            }
            else {
                // tslint:disable-next-line no-console
                console.error(`Could not emit event from component <${this.localName}> - it does not have an owner layer specified`);
            }
        });
    }
    emitComponentEvent(name, data) {
        if (this._baseLayer) {
            this._baseLayer.logger.log(Logger_1.LoggerTypes.Events, `%c RAISING COMPONENT EVENT:%c ${name}`, "color: #066; font-weight: bold;", "color: #999; font-weight: normal;", { component: this, data: data });
            this.dispatchEvent(new CustomEvent(name, { detail: data }));
        }
        else {
            // tslint:disable-next-line no-console
            console.error(`Could not emit event from component <${this.localName}> - it does not have an owner layer specified`);
        }
    }
    addListener(name, callback, options) {
        if (this._baseLayer) {
            let onceOnly = false;
            let allowSuppress = true;
            if (options && options.onceOnly === true)
                onceOnly = true;
            if (options && options.dontSuppress === true)
                allowSuppress = false;
            const unsubscribe = this._baseLayer.on(name, callback, onceOnly, allowSuppress);
            this._listenerUnsubscribers.push(unsubscribe);
        }
        else {
            // tslint:disable-next-line no-console
            console.error(`Could not set event handler on component <${this.localName}> - it does not have an owner layer specified`);
        }
    }
    addListeners(names, callback, options) {
        names.forEach(x => {
            this.addListener(x, callback, options);
        });
    }
    launchModal(alert) {
        this._baseLayer.emit(events_1.BaseEvents._Request_RaiseAlert, alert);
    }
    launchAckownledgeDialog(title, message, onOk) {
        this._baseLayer.emit(events_1.BaseEvents._Request_RaiseAlert, this.defaultAlerts.AlertAcknowledge(title, message, 1, {
            okay: () => {
                onOk();
            }
        }));
    }
    launchConfirmationDialog(title, question, onYes, onNo) {
        this._baseLayer.emit(events_1.BaseEvents._Request_RaiseAlert, this.defaultAlerts.AlertYesNoQuestion(title, question, 1, {
            yes: () => {
                onYes();
            },
            no: () => {
                if (typeof (onNo) === "function")
                    onNo();
            }
        }));
    }
    showWaitingMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._baseLayer.showWaitingMessage(message);
        });
    }
    dismissWaitingMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._baseLayer.dismissWaitingMessage();
        });
    }
    getLabel(labelName, data) {
        return this.layer.getLabel(labelName, data);
    }
    translate(label, nullIfNotPresent) {
        return this._baseLayer.translate(label, false);
    }
    translateI18nItem(item) {
        let key;
        if (item && ["scope", "key"].every(key => item.hasOwnProperty(key))) {
            key = item.key;
        }
        else {
            key = item.toString();
            item = this.metadata && this.metadata.getI18nItem(key) || null;
        }
        if (item === null)
            return key;
        if (this.metadata === null)
            return key;
        if (!this._baseLayer.config.i18n || this._baseLayer.config.i18n.enabled !== true)
            return key;
        // try scoped key first
        const translation = this._baseLayer.translate(item.scopedKey, true);
        if (translation !== null)
            return translation;
        // try non-scoped key
        return this._baseLayer.translate(item.key);
    }
    // === Private functions === //
    _attemptConnectToBaseLayer() {
        if (!this.owner)
            return;
        LayerRegistration_1.LayerRegistration.onReady(this.owner, () => {
            this._connectToLayer();
        });
    }
    _connectToLayer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._connected)
                return;
            if (!this.owner)
                return;
            this._baseLayer = LayerRegistration_1.LayerRegistration.getInstance(this.owner) || null;
            if (!this._baseLayer)
                return;
            yield this._initializeForBaseLayer();
        });
    }
    _initializeForBaseLayer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.layer)
                return;
            yield this.initialize.apply(this);
            this.setupListeners();
            this._connected = true;
            this.forceRedraw();
            /**
             * This is a temp change to test removing components from the redraw UI event.
             * Only the chat message list is being exluded right now, but more can be added
             * into the array below.
             *
             * The goal is to eventually abandon this event entirely at some point in the future.
             */
            const exclusions = [
                "ct-cl-chat-message-list",
                "ct-cl-new-conversation",
                "ctcl-attachment-handler",
                "ctcl-audio-recorder-player"
            ];
            if (!exclusions.includes(this.nodeName.toLowerCase())) {
                this.addListener(events_1.BaseEvents._Request_RedrawAllUIs, () => __awaiter(this, void 0, void 0, function* () {
                    if (!this.layer)
                        return;
                    yield this.initialize.apply(this);
                    this.forceRedraw();
                }));
            }
        });
    }
    _findParentCTLayerComponent() {
        let parent = this;
        let finished = false;
        do {
            // tslint:disable-next-line no-any
            parent = (parent.parentNode || parent.host);
            if (!parent)
                finished = true;
            if (parent && parent.owner)
                finished = true;
        } while (!finished);
        return parent || null;
    }
}
CTLayerComponent.is = null;
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTLayerComponent.prototype, "owner", void 0);
exports.CTLayerComponent = CTLayerComponent;
// tslint:enable no-any
// tslint:enable typedef


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const strophe_1 = __webpack_require__(42);
const ct_xmpp_client_1 = __webpack_require__(21);
const models_1 = __webpack_require__(1);
const errors_1 = __webpack_require__(25);
const events_1 = __webpack_require__(9);
const Logger_1 = __webpack_require__(17);
const utils_1 = __webpack_require__(2);
class BaseComms {
    constructor(name, config, store, logger) {
        this._firstConnectionInitialized = false;
        this._loggingIn = false;
        this._loginTimeout = null;
        this._clientName = name;
        const clientOptions = {
            debug: (logger.getTypesAsEnumValues().includes(Logger_1.LoggerTypes.XmppClient)),
            mucHost: config.mucHost,
            mam: {
                auto: (config.mam && config.mam.autoFetch === true) || false,
                defaultTimeLimit: config.maxMessageAge || 0,
                pageSize: 500
            },
            autoLogin: (config.autoLogin !== undefined ? config.autoLogin : true),
            autoReconnect: (config.autoReconnect !== undefined ? config.autoReconnect : true),
            enablePing: config.enablePing !== false,
            pingInterval: config.pingInterval || 5000,
            pingTimeout: config.pingTimeout || 10000,
            multicastHost: config.multicastHost,
            uploadHost: config.uploadHost,
            autoMarkMessages: config.useChatMarkers,
            autoPurgeOldMessagesAge: config.maxMessageAge || 0,
            encryption: config.encryption || false,
            fileEncryption: config.fileEncryption || false,
            authAttachments: config.authAttachments === true,
            streamResumption: config.streamResumption !== false,
            useEncodedJidAsResource: (config.user && config.user.userPersistentResource === true) || false,
            adSpn: config.adSpn || null,
            adSecurityPackage: config.adSecurityPackage || null,
            push: config.push || { androidEnabled: false, iosEnabled: true },
            updateUserDirectoryOnLogin: config.updateUserDirectoryOnLogin || null,
            enableMessageCarbons: config.enableMessageCarbons || false,
            bringToForegroundOnVoipPush: (config.bringToForegroundOnVoipPush !== undefined) ? config.bringToForegroundOnVoipPush : null,
            updateUserDirectoryInterval: config.updateUserDirectoryInterval || 30 * 1000 * 60,
            alwaysSendPresence: config.alwaysSendPresence,
            sleepingBeauty: config.sleepingBeauty
        };
        if (config.push)
            clientOptions.push = config.push;
        if (config.adTokenPlaceholder)
            clientOptions.adTokenPlaceholder = config.adTokenPlaceholder;
        this.client = new ct_xmpp_client_1.CtXmppClient(this._clientName, config.endpoint, clientOptions);
        this.store = store;
        this.logger = logger;
        this.xmppConfig = config;
        this._localEventHandlers = {};
        this._setupCommonHandlers();
    }
    // === Event handlers === //
    onInitialized(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.INITIALISED, () => {
            handler();
        });
    }
    onLogin(handler) {
        const eventName = "comms-login";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onLogout(handler) {
        const eventName = "comms-logout";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onNewMessage(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, (message) => {
            handler(Object.assign({}, message));
        });
    }
    onMessageUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, (message) => {
            handler(Object.assign({}, message));
        });
    }
    onChatMarkerUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, (receipt) => {
            handler(Object.assign({}, receipt));
        });
    }
    onStatusUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.STATUS, (status) => {
            this.resetServerVersion();
            let sts = models_1.ConnectionStatus.Disconnected;
            let disconnectStatus = null;
            switch (status.id) {
                case strophe_1.default.Strophe.Status.CONNFAIL:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(status.wontReconnect, status.reason);
                    break;
                case strophe_1.default.Strophe.Status.AUTHFAIL:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(false, status.reason);
                    break;
                case strophe_1.default.Strophe.Status.ERROR:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(status.wontReconnect, status.reason);
                    break;
                case strophe_1.default.Strophe.Status.CONNECTING:
                    sts = models_1.ConnectionStatus.Connecting;
                    break;
                case strophe_1.default.Strophe.Status.AUTHENTICATING:
                    sts = models_1.ConnectionStatus.Connecting;
                    break;
                case strophe_1.default.Strophe.Status.CONNECTED:
                    sts = models_1.ConnectionStatus.Connected;
                    break;
                case strophe_1.default.Strophe.Status.DISCONNECTING:
                    sts = models_1.ConnectionStatus.Disconnecting;
                    break;
                case strophe_1.default.Strophe.Status.DISCONNECTED:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(status.wontReconnect, status.reason);
                    document.dispatchEvent(new CustomEvent("__cm-connection-change", { detail: sts }));
                    break;
                default:
                    models_1.ConnectionStatus.Disconnected;
                    break;
            }
            handler(sts, status.reconnectTime, disconnectStatus);
        });
    }
    onPresenceUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, (contact) => {
            handler(contact);
        });
    }
    onRoomNewParticipant(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_PARTICIPANT, (participant) => {
            handler(Object.assign({}, participant));
        });
    }
    onRoomParticipantUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PARTICIPANT_UPDATED, (participant) => {
            handler(Object.assign({}, participant));
        });
    }
    onError(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.ERROR, (err) => {
            handler(err);
        });
    }
    onStartFetchingMissedMessages(handler) {
        const eventName = "missed-messages-start";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onFinishedFetchingMissedMessages(handler) {
        const eventName = "missed-messages-finished";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    // tslint:disable-next-line no-any
    onAutoReconnected(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_RECONNECTED, data => {
            this.getServerVersion();
            handler(data);
        });
    }
    onDatabasesAutoDestroyed(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_DBS_DESTROYED, () => {
            handler();
        });
    }
    // === Public functions === //
    getSyncedTimestamp(ts) {
        const clientTs = (ts === null || ts === undefined)
            ? new Date().getTime()
            : ts;
        return this.client.getSyncedTimestamp(clientTs);
    }
    getCurrentUserResource() {
        return this.client.resource;
    }
    getConnectionStatus() {
        return this.status;
    }
    setConnectionStatus(status) {
        this.status = status;
    }
    login(username, password, fireEvents = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._loggingIn === true)
                return Promise.reject(new Error("Login currently in progress, please wait."));
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    let fullPassword = password;
                    if (this.xmppConfig.user.sendAppIdentifier === true) {
                        fullPassword = `app_id~${this.xmppConfig.user.appIdentifier}~${password}`;
                    }
                    this._loggingIn = true;
                    clearTimeout(this._loginTimeout);
                    const loginTimeoutDuration = this.xmppConfig.loginTimeout || 10000;
                    this._loginTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        clearTimeout(this._loginTimeout);
                        yield this.logout(true, true);
                        this.logger.log(Logger_1.LoggerTypes.Connectivity, "%c LOGIN TIMED OUT", "color: #600; font-weight: bold;");
                        reject(new Error(`Logging in took longer than ${Math.floor(loginTimeoutDuration / 1000)} seconds. Please check your connectivity and try again.`));
                    }), loginTimeoutDuration);
                    if (this.xmppConfig.user && this.xmppConfig.user.forceLowercaseJid === true) {
                        username = username.toLowerCase();
                    }
                    this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c ATTEMPTING LOGIN > %c${username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                    this.username = username;
                    yield this.client.login(username, fullPassword);
                    this.checkTimeSync(false);
                    if (fireEvents) {
                        this.triggerLoginEvent(true);
                    }
                    clearTimeout(this._loginTimeout);
                    this._loggingIn = false;
                    resolve();
                }
                catch (ex) {
                    clearTimeout(this._loginTimeout);
                    this._loggingIn = false;
                    this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c LOGIN FAILED > %c${username}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;");
                    this.username = "";
                    if (fireEvents) {
                        this.triggerLoginEvent(false, ex.msg);
                    }
                    reject(ex);
                }
            }));
        });
    }
    logout(forceCleanUp = false, fireEvents = true) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c LOGGING OUT > %c${this.username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                this._loggingIn = false;
                this._firstConnectionInitialized = false;
                yield this.client.logout(forceCleanUp);
                this.username = "";
                if (fireEvents) {
                    this.triggerLogoutEvent(true);
                }
            }
            catch (ex) {
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c LOGOUT FAILED > %c${this.username}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;");
                if (fireEvents) {
                    this.triggerLogoutEvent(false);
                }
            }
        });
    }
    attemptReconnect() {
        this.client.reLoginNow();
    }
    joinRoom(room) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._joinOrLeaveRoom(room);
        });
    }
    leaveRoom(room) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._joinOrLeaveRoom(room, true);
        });
    }
    setClientStateActive(active) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = active
                ? ct_xmpp_client_1.CtXmppClient.CLIENT_STATES.ACTIVE
                : ct_xmpp_client_1.CtXmppClient.CLIENT_STATES.INACTIVE;
            this.client.setClientState(state);
        });
    }
    getUniqueId() {
        return this.client.getUniqueId();
    }
    sendMessage(to, payload, attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!to)
                throw new Error("No recipient specified");
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to send message: not currently connected");
            const sentMessage = yield this.client.sendChatMessage(to, null, payload, attachments);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c MESSAGE SENT: %c${to} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(sentMessage));
            }
            return sentMessage;
        });
    }
    sendRoomMessage(roomName, body = null, data = null, attachments = [], useChatMarkers = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!roomName)
                throw new Error("No room name specified");
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to send room message: not currently connected");
            const sentMessage = yield this.client.sendGroupChatMessage(roomName, body, data, attachments, useChatMarkers);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c ROOM MESSAGE SENT: %c${roomName} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(sentMessage));
            }
            return sentMessage;
        });
    }
    sendMulticastMessage(to, payload, attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to multicast message: not currently connected");
            const sentMessage = yield this.client.sendMulticastMessage(to, null, payload, attachments);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                const toData = JSON.stringify(to);
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c MUTILCAST MESSAGE SENT: %c${toData} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(sentMessage));
            }
            return sentMessage;
        });
    }
    sendIq(to, type, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!to)
                throw new Error("No recipient specified");
            if (!type)
                throw new Error("No type specified");
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to send IQ: not currently connected");
            // tslint:disable-next-line no-any
            const operation = Object.keys(payload)[0];
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c IQ SENT: %c${operation} >`, "color: #906; font-weight: bold;", "color: #999; font-weight: normal;", { iq: payload });
            }
            try {
                const iqResponse = yield this.client.sendIq(to, type, payload);
                if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                    this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c IQ RESPONSE: %c${operation} >`, "color: #906; font-weight: bold;", "color: #999; font-weight: normal;", Object.assign({}, iqResponse));
                }
                return iqResponse.iq;
            }
            catch (exIq) {
                // tslint:disable-next-line no-any
                const errorJson = ct_xmpp_client_1.CtXmppClient.xmlToJson(exIq);
                const errorText = errorJson && errorJson.iq && errorJson.iq.error && errorJson.iq.error.text && errorJson.iq.error.text.$value || "";
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c IQ ERROR: %c${operation} > ${errorText}`, "color: #C00; font-weight: bold;", "color: #999; font-weight: normal;", Object.assign({}, errorJson));
                throw new errors_1.IQError(errorText, errorJson.iq);
            }
        });
    }
    sendBotCommand(operationName, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error(`Unable to send bot command "${operationName}": not currently connected`);
            if (!this.xmppConfig.bot)
                throw new Error("No bot configured in XmppConfig");
            const botComponentJid = this.xmppConfig.bot.componentJid;
            if (!botComponentJid)
                throw new Error("Unable to issue bot command; no bot component jid configured");
            if (payload !== undefined && payload !== null) {
                const payloadToDisplay = Object.assign({}, payload);
                if (operationName in payloadToDisplay) {
                    payloadToDisplay[operationName] = JSON.parse(payloadToDisplay[operationName]);
                }
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c BOT COMMAND SENT: %c${operationName} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { data: payloadToDisplay });
            }
            else {
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c BOT COMMAND SENT: %c${operationName}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            try {
                const botResponse = yield this.client.sendBotCommand(botComponentJid, operationName, payload, this.xmppConfig.bot.timeout);
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c BOT RESPONSE: %c${operationName} > ${botResponse.success ? "success" : "fail"}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { data: botResponse.data || null });
                return botResponse;
            }
            catch (ex) {
                // the error "Server connections to local subdomains are forbidden" is thrown when the BOT is unavailable to accept connected, so
                // we reword the error message to be a bit more meaningful
                const errorMessage = (ex === "Server connections to local subdomains are forbidden")
                    ? `Unable to connect to bot: ${botComponentJid}`
                    : ex.message || ex;
                throw new Error(errorMessage);
            }
        });
    }
    deleteMessageById(id, deleteAttachments = true) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deleteMessageById(id, deleteAttachments);
        });
    }
    /**
     * Deletes messages for a certain room.
     *
     * @param name The room name. Note: this isn't the full jid, just everything before the @.
     */
    deleteMessageByRoomName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deleteMessagesByRoomName(name);
        });
    }
    // tslint:disable-next-line no-any
    updateStatus(status, label, broadcast = false, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.setChatStatus(status, label, broadcast, metadata);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Status)) {
                const responseData = JSON.stringify(response);
                this.logger.log(Logger_1.LoggerTypes.Status, `%c STATUS UPDATED: %c${responseData}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            return response;
        });
    }
    listParticipantsByRoom(roomName) {
        return __awaiter(this, void 0, void 0, function* () {
            const participants = yield this.client.listParticipantsByRoom(roomName);
            return Promise.all(participants.map((x) => __awaiter(this, void 0, void 0, function* () {
                return yield this._participantToUser(x);
            })));
        });
    }
    getParticipantByRoomAndJid(roomName, jid) {
        return __awaiter(this, void 0, void 0, function* () {
            const participant = yield this.client.getParticipantByRoomAndJid(roomName, jid);
            return (!!participant)
                ? yield this._participantToUser(participant)
                : null;
        });
    }
    getAllContacts() {
        return __awaiter(this, void 0, void 0, function* () {
            const contacts = yield this.client.getContacts();
            return Promise.all(contacts.map((x) => __awaiter(this, void 0, void 0, function* () {
                return yield this._xmppContactToUser(x);
            })).filter(x => x !== null));
        });
    }
    getUserByJid(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.client.getUserByJid(jid);
            if (!user)
                return null;
            return yield this._directoryUserToUser(user);
        });
    }
    updateUserDirectory() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.updateUserDirectory();
        });
    }
    getAllDirectoryUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.getAllUsers();
        });
    }
    searchUsers(searchTerm = "", fields = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const hasSearchTerm = (searchTerm !== undefined && searchTerm !== null && searchTerm.length > 0);
            const directoryUsers = hasSearchTerm
                ? yield this.client.searchUsers(searchTerm, fields)
                : yield this.client.getAllUsers();
            // removed sorting by name, and async inside map (is that allowed?) so that things appear in the right order.
            const users = [];
            for (const u of directoryUsers) {
                if (u !== null) {
                    users.push(yield this._directoryUserToUser(u));
                }
            }
            return users;
        });
    }
    markMessageRead(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use the config to determine if we need to mark messages
            if (!this.xmppConfig.useChatMarkers)
                return;
            const message = yield this.client.getMessageById(messageId);
            if (!message)
                return; // doesn't exist
            // NK Note:
            // This is an experimental check to not send chat markers when not needed. It seems that the
            // original code (commented out below) will always return false, so we're ALWAYS sending chat
            // markers regardless of whether we have sent one before. I suspect that at some point (possibly
            // different server config, etc), the checks below were correct and working but are now not valid.
            if (message.mine || !message.markable)
                return; // mine or unmarkable therefore doesn't need a marker
            if (message.state.markers.some(x => x.type === "read" && (x.sender_resource && (x.sender_resource.toLowerCase() === this.username.split("@")[0].toLowerCase())) ||
                x.sender_id.toLowerCase() === this.username.toLowerCase())) {
                return; // already marked read
            }
            // Original marker check code. Uncomment this back in if we're seeing issues.
            // if (message.state.markers.some(x => x.type === "read" && x.sender_resource === this.username)) return; // already marked read
            yield this.client.markMessageRead(message);
        });
    }
    getChatHistory(recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.getChatHistory(recipient);
        });
    }
    queryMam(to, archiveId, jid, timeLimit, dispatch = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.queryMam(to, archiveId, jid, timeLimit, dispatch);
        });
    }
    processXmlStanzaStringsFromMam(stanzaStrings, dispatch = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.processXmlStanzaStringsFromMam(stanzaStrings, dispatch);
        });
    }
    clearAllData(keepCache = false) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.destroyDbs(false, keepCache);
        });
    }
    createPushNotificationRegistration(registrationDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = this._generatePushNotificationPayload(registrationDetails.platform, registrationDetails.channelUri, registrationDetails.azureId);
            return yield this.client.sendIq("push.localhost", "set", payload);
        });
    }
    checkTimeSync(forceOutput = true) {
        const clientTime = new Date().getTime();
        const syncedTime = this.getSyncedTimestamp(clientTime);
        const diff = Math.abs(syncedTime - clientTime);
        const diffTolerance = 10000; // allow up to 10s difference before highlighting
        const withinTolerance = (diff < diffTolerance);
        const diffColor = withinTolerance ? "#666" : "#F00";
        const diffColor2 = withinTolerance ? "#999" : "#F00";
        const loggerMethod = forceOutput
            ? console.log
            : withinTolerance
                ? () => { }
                : console.log;
        loggerMethod.call(console.log, `%c CLIENT TIME: %c${new Date(clientTime).toTimeString()}`, "color: #666; font-weight: bold;", "color: #999; font-weight: normal;");
        loggerMethod.call(console.log, `%c SERVER TIME: %c${new Date(syncedTime).toTimeString()}`, "color: #666; font-weight: bold;", "color: #999; font-weight: normal;");
        if (diff) {
            const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
            const minutes = Math.floor((diff / (1000 * 60)) % 60);
            const seconds = Math.floor((diff / 1000) % 60);
            const milliseconds = Math.floor(diff % 1000);
            let timeDisplay = "";
            if (hours > 0)
                timeDisplay += `${hours}h `;
            if (minutes > 0)
                timeDisplay += `${minutes}m `;
            if (seconds > 0)
                timeDisplay += `${seconds}s `;
            if (milliseconds > 0)
                timeDisplay += `${milliseconds}ms `;
            if (clientTime > syncedTime) {
                loggerMethod.call(console.log, `%c TIME SYNC: %cClient is %c${timeDisplay.trim()} ahead %cof server`, `color: ${diffColor}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`, `color: ${diffColor2}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`);
            }
            else {
                loggerMethod.call(console.log, `%c TIME SYNC: %cClient is %c${timeDisplay.trim()} behind %cserver`, `color: ${diffColor}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`, `color: ${diffColor2}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`);
            }
        }
        else {
            loggerMethod.call(console.log, `%c TIME SYNC: %cClient and server times are identical`, "color: #666; font-weight: bold;", "color: #999; font-weight: normal;");
        }
    }
    updateVCardForUser(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.username && this.username === jid)
                return null;
            yield this.client.updatevCardForContact(jid);
        });
    }
    getOurVCard() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.getOurvCard();
            }
            catch (ex) {
                // might not have a vCard
                return null;
            }
        });
    }
    downloadMessageAttachments(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield this.client.getMessageById(messageId);
            if (!message)
                return;
            yield this.client.downloadAttachments(message, true);
        });
    }
    downloadFile(url, bypassEncryption = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line no-any
            const result = yield this.client.doDownload(url);
            return result.source || null;
        });
    }
    /**
     * Requests the server version from the XMPP server.
     */
    getServerVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            this.serverVersion = yield this.client.getServerVersion();
        });
    }
    /**
     * Resets the server version.
     * This is required to prevent server versions being cached (and therefore older or incorrect
     * server versions being reported by QA or users).
     */
    resetServerVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            this.serverVersion = null;
        });
    }
    /**
     * Uploads a single file and then returns the get path as a string.
     * @param filePath File path of the file you wish to upload.
     */
    uploadFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.uploadAttachment(filePath);
            }
            catch (ex) {
                // tslint:disable-next-line no-any
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c UPLOAD ERROR: %c$Unable to upload file > ${ex}`, "color: #C00; font-weight: bold;", "color: #999; font-weight: normal;", filePath);
                throw new Error("Unable to upload attachment");
            }
        });
    }
    // === Protected functions === //
    initializeFirstConnection() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    buildCurrentUser(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            const username = jid.split("@").shift();
            const user = {
                id: jid,
                jid: jid,
                username: username,
                firstName: "",
                lastName: "",
                connectionStatus: this.getConnectionStatus()
            };
            const vcard = yield this.getOurVCard();
            return yield this.embelishUser(user, vcard, models_1.UserAdditionalDetailsType.VCard);
        });
    }
    triggerLoginEvent(success, errorMessage) {
        this._fireLocalEventHandlers("comms-login", new events_1.CommsEventArgs(success, errorMessage));
    }
    triggerLogoutEvent(success, errorMessage) {
        this._fireLocalEventHandlers("comms-logout", new events_1.CommsEventArgs(success, errorMessage));
    }
    triggerFetchingMissedMessagesState(fetching) {
        if (fetching) {
            this._fireLocalEventHandlers("missed-messages-start");
        }
        else {
            this._fireLocalEventHandlers("missed-messages-finished");
        }
    }
    // === Private functions === //
    _setupCommonHandlers() {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, (message) => __awaiter(this, void 0, void 0, function* () {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageReceived)) {
                this.logger.log(Logger_1.LoggerTypes.MessageReceived, `%c MESSAGE RECEIVED:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(message));
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, (message) => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageUpdated)) {
                this.logger.log(Logger_1.LoggerTypes.MessageUpdated, `%c MESSAGE UPDATED:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(message));
            }
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, (receipt) => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageChatMarker)) {
                const username = receipt.sender_resource.split("@").shift();
                this.logger.log(Logger_1.LoggerTypes.MessageChatMarker, `%c CHAT MARKER RECEIVED: %c${username} > ${receipt.type}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.STATUS, (status) => __awaiter(this, void 0, void 0, function* () {
            const connectionStatus = models_1.ConnectionStatus[status.label];
            this.setConnectionStatus(connectionStatus);
            if (connectionStatus === models_1.ConnectionStatus.Connected) {
                this.username = this.client.bareJid;
                if (this._firstConnectionInitialized === false) {
                    yield this.initializeFirstConnection();
                    this._firstConnectionInitialized = true;
                }
            }
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Connectivity)) {
                const suffix = (!!status.reconnectTime)
                    ? ` - reconnect attempt in ${status.reconnectTime / 1000} second(s)`
                    : "";
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c CONNECTIVITY CHANGE: %c${connectionStatus}${suffix}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_PARTICIPANT, (participant) => __awaiter(this, void 0, void 0, function* () {
            if (!participant.jid)
                return;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Participation)) {
                const user = yield this._participantToUser(participant);
                this.logger.log(Logger_1.LoggerTypes.Participation, `%c NEW PARTICIPANT: %c${user.username} > ${user.connectionStatus}`, "color: #006; font-weight: bold;", "color: #999; font-weight: normal;", { participant: participant });
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PARTICIPANT_UPDATED, (participant) => __awaiter(this, void 0, void 0, function* () {
            if (!participant.jid)
                return;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Participation)) {
                const user = yield this._participantToUser(participant);
                this.logger.log(Logger_1.LoggerTypes.Participation, `%c PARTICIPANT UPDATED: %c${user.username} > ${user.connectionStatus}`, "color: #006; font-weight: bold;", "color: #999; font-weight: normal;", { participant: participant });
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, (contact) => __awaiter(this, void 0, void 0, function* () {
            if (!contact.id)
                return;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Presence)) {
                const user = yield this._xmppContactToUser(contact);
                if (!user)
                    this.logger.error(Logger_1.LoggerTypes.Presence, `%c PRESENCE UPDATED FOR UNKNOWN CONTACT:`, "color: #006; font-weight: bold;", { contact: contact });
                else
                    this.logger.log(Logger_1.LoggerTypes.Presence, `%c PRESENCE UPDATED: %c${user.username} > ${user.connectionStatus}`, "color: #006; font-weight: bold;", "color: #999; font-weight: normal;");
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.ERROR, (err) => {
            this.logger.error(`%c ERROR:`, "color: #C00; font-weight: bold;", "\r\n\t", err);
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_RECONNECTED, ({ resumed }) => __awaiter(this, void 0, void 0, function* () {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Connectivity)) {
                const suffix = (resumed === true)
                    ? " - STREAM RESUMED"
                    : "";
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c AUTO RECONNECTED AFTER DISCONNECT${suffix}`, "color: #669; font-weight: bold;");
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.DBS_DESTROYED, () => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.CleanUp)) {
                this.logger.log(Logger_1.LoggerTypes.CleanUp, `%c DATABASES DESTROYED`, "color: #669; font-weight: bold;");
            }
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_DBS_DESTROYED, () => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.CleanUp)) {
                this.logger.log(Logger_1.LoggerTypes.CleanUp, `%c DATABASES AUTO DESTROYED`, "color: #669; font-weight: bold;");
            }
        });
    }
    _joinOrLeaveRoom(room, leave = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (room.type === "participant") {
                (yield leave)
                    ? this.client.leaveRoom(room.name)
                    : this.client.joinRoom(room.name);
            }
            if (room.type === "subscriber") {
                (yield leave)
                    ? this.client.unsubscribeFromRoom(room.name)
                    : this.client.subscribeToRoom(room.name, room.nodes);
            }
        });
    }
    _participantToUser(participant) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = {
                id: participant._id,
                jid: participant.jid,
                username: participant.username,
                firstName: "",
                lastName: "",
                connectionStatus: participant.online
                    ? models_1.ConnectionStatus.Connected
                    : models_1.ConnectionStatus.Disconnected
            };
            return this.embelishUser(user, participant, models_1.UserAdditionalDetailsType.Participant);
        });
    }
    _xmppContactToUser(contact) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contact || !contact.id)
                return null;
            const user = {
                id: contact.id,
                jid: contact.id,
                username: contact.id.substring(0, contact.id.indexOf("@")),
                firstName: "",
                lastName: "",
                connectionStatus: contact.online
                    ? models_1.ConnectionStatus.Connected
                    : models_1.ConnectionStatus.Disconnected,
                groups: contact.groups,
                subscription: contact.subscription
            };
            return this.embelishUser(user, contact, models_1.UserAdditionalDetailsType.Contact);
        });
    }
    _directoryUserToUser(directoryUser) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!directoryUser || !directoryUser.jid)
                return null;
            const id = directoryUser.jid;
            const user = {
                id: id,
                jid: id,
                username: id.substring(0, id.indexOf("@")),
                connectionStatus: models_1.ConnectionStatus.Disconnected,
                prefix: directoryUser.prefix,
                firstName: directoryUser.firstName,
                lastName: directoryUser.lastName,
                displayName: null,
                telephone: directoryUser.telephone,
                jobTitle: directoryUser.jobTitle,
                avatar: directoryUser.avatar,
                group: directoryUser.group
            };
            return this.embelishUser(user, directoryUser, models_1.UserAdditionalDetailsType.DirectoryUser);
        });
    }
    // tslint:disable-next-line no-any
    _fireLocalEventHandlers(name, data) {
        if (this._localEventHandlers[name] !== undefined) {
            this._localEventHandlers[name].forEach(handler => handler(data));
        }
    }
    _generatePushNotificationPayload(deviceType, deviceToken, installationId) {
        return {
            push: {
                $attributes: {
                    xmlns: "urn:commontime:infinity:push"
                },
                notification: {
                    type: deviceType === "android" ? "gcm" : "apns",
                    installation_id: installationId,
                    registration_id: deviceToken
                }
            }
        };
    }
}
exports.BaseComms = BaseComms;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(24);
// tslint:disable no-any variable-name
/**
 * This represents a SkateJS type which will bind to a boolean property using
 * the string representation of "true" or "false in an attribute. This works around
 * the default "boolean" SkateJS type which is only false if the attribute does
 * not exist.
 *
 * Usage (using typescript decorators):
 *
 * @prop({ type: Stroolean, attribute: true, default: false })
 * myBooleanProperty: boolean
 */
exports.Stroolean = skate.prop.create({
    coerce: val => (typeof (val) === "string" && val.toLowerCase() === "true"),
    default: false,
    deserialize: val => (typeof (val) === "string" && val.toLowerCase() === "true"),
    serialize: val => (val ? "true" : "false")
});
/**
 * This represents a SkateJS type which will bind to a numerical property using
 * the string representation of the number, or a "null" value. This works around
 * the default "number" SkateJS type which is always 0 even if a null default is
 * specified.
 *
 * Usage (using typescript decorators):
 *
 * @prop({ type: Strumber, attribute: true, default: null })
 * myBooleanProperty: boolean
 */
exports.NullableNumber = skate.prop.create({
    coerce: val => (val === "null") ? null : parseInt(val),
    default: null,
    deserialize: val => (val === "null") ? null : parseInt(val),
    serialize: val => (val === null || val === undefined) ? "null" : val.toString()
});
// tslint:enable no-any variable-name


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(24);
const identityFn = (x) => x;
function prop(property) {
    return function (target, propertyKey) {
        // obtain properties provide by the @prop decorator
        const { type } = property, skPropConfig = __rest(property, ["type"]);
        // parse to find out the type of property
        const configType = parseType(type);
        // reference the skatejs prop function, e.g. prop.string
        const skatePropTypeFn = skate.prop[configType] || identityFn;
        // get constructor of element
        const ctor = target.constructor;
        // grab any existing props previously defined
        const existingProps = (ctor.props || {});
        // concatenate all props together
        const newProps = Object.assign({}, existingProps, { [propertyKey]: skatePropTypeFn(skPropConfig) });
        // apply to the current instance of the component
        Object.defineProperty(ctor, "props", {
            configurable: true,
            get() {
                return newProps;
            }
        });
    };
}
exports.prop = prop;
function parseType(type) {
    if (typeof type !== "function") {
        return;
    }
    const inst = type();
    if (inst instanceof Array) {
        return "array";
    }
    if (typeof inst === "object") {
        return "object";
    }
    return (typeof inst);
}
// tslint:enable no-any


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
class IQError extends Error {
    constructor(message, iqResponse) {
        super(message);
        this.iqResponse = iqResponse;
    }
}
exports.IQError = IQError;
// tslint:enable no-any


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
class NotConnectedError extends Error {
    constructor(connectionStatus, message) {
        super(message);
        this.connectionStatus = connectionStatus;
    }
}
exports.NotConnectedError = NotConnectedError;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(23);
class CommsEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(success, errorMessage) {
        super();
        this.success = success;
        if (errorMessage) {
            this.errorMessage = errorMessage;
        }
    }
}
exports.CommsEventArgs = CommsEventArgs;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(23);
class ConnectionStatusEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(status, reconnectTime, disconnectStatus) {
        super();
        this.status = status;
        this.reconnectTime = reconnectTime;
        this.disconnectStatus = disconnectStatus;
    }
}
exports.ConnectionStatusEventArgs = ConnectionStatusEventArgs;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(23);
class RoomParticipantUpdateEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(jid, roomName, role, roomRole) {
        super();
        this.jid = jid;
        this.roomName = roomName;
        this.role = role;
        this.roomRole = roomRole;
    }
}
exports.RoomParticipantUpdateEventArgs = RoomParticipantUpdateEventArgs;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(23);
class UserActivityEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(jid, date) {
        super();
        this.jid = jid;
        this.date = date;
    }
}
exports.UserActivityEventArgs = UserActivityEventArgs;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(23);
class UserConnectionStatusEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(jid, connectionStatus) {
        super();
        this.jid = jid;
        this.connectionStatus = connectionStatus;
    }
}
exports.UserConnectionStatusEventArgs = UserConnectionStatusEventArgs;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
class BaseHandler {
    constructor(layer) {
        this.messageKey = null;
        this.eventType = [];
        this.layer = layer;
        this.defaultAlerts = new models_1.DefaultAlerts(layer);
    }
    createMessage(data) { throw new Error("Not implemented"); }
    createIq(data) { throw new Error("Not implemented"); }
    createBotMessage(data, previousBotResponse) { throw new Error("Not implemented"); }
    handleFailedBotResponse(data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () { return false; });
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessageReceipt(receipt) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleIqResponse(data, response) {
        return __awaiter(this, void 0, void 0, function* () { return response; });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () { return error.iqResponse; });
    }
    // === Public functions to invoke the above implementations === //
    //     These allows us to introduce "before" and "after" hooks to all calls if we want to
    callCreateMessage(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = this.createMessage(data);
            this._embelishI18n(message);
            return message;
        });
    }
    callCreateIq(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = this.createIq(data);
            this._embelishI18n(message);
            return message;
        });
    }
    callCreateBotMessage(data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield this.createBotMessage(data);
            this._embelishI18n(message);
            return message;
        });
    }
    callHandleFailedBotResponse(data, botResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!botResponse || botResponse.success === true)
                return false;
            return yield this.handleFailedBotResponse(data, botResponse);
        });
    }
    callHandleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessage(message);
        });
    }
    callHandleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessageUpdate(message);
        });
    }
    callHandleMessageReceipt(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessageReceipt(receipt);
        });
    }
    callHandleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleEvent(eventType, eventData);
        });
    }
    callHandleIqResponse(data, response) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.handleIqResponse(data, response);
        });
    }
    callHandleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.handleIqErrorResponse(data, error);
        });
    }
    // === Private functions === //
    _embelishI18n(message) {
        if (this.layer.config.i18n && this.layer.config.i18n.enabled === true) {
            message.language = this.layer.config.i18n.language;
            message.locale = this.layer.config.i18n.locale;
        }
    }
}
exports.BaseHandler = BaseHandler;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
class I18nItem {
    constructor(scope, key) {
        this.scope = scope;
        this.key = key;
    }
    get scopedKey() {
        return `${this.scope}_${this.key}`;
    }
}
exports.I18nItem = I18nItem;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(11);
// tslint:disable no-any
class Metadata {
    constructor(scope, enumObject) {
        if (scope) {
            this._scope = (typeof (scope) === "string")
                ? scope
                : "name" in scope
                    ? scope.name
                    : scope.toString();
        }
        this._i18nItems = new Map();
        if (enumObject)
            this.fillFromEnum(enumObject);
    }
    fillFromEnum(enumObject) {
        let idx = 0;
        for (const val in enumObject) {
            if (enumObject.hasOwnProperty(val) && idx % 2 !== 0)
                this.addI18nItem(val);
            idx += 1;
        }
    }
    addI18nItem(key) {
        if (!key)
            return;
        this._i18nItems.set(key.toString(), new _1.I18nItem(this._scope, key.toString()));
    }
    getI18nItem(key) {
        if (!key)
            return;
        const keyAsString = key.toString();
        if (!this._i18nItems.has(keyAsString))
            throw new Error(`No i18n item registered for key: "${keyAsString}"`);
        return this._i18nItems.get(keyAsString);
    }
    getUniqueI18Keys(fullyQualified) {
        return [...this._i18nItems.values()]
            .map(x => {
            return fullyQualified ? x.scopedKey : x.key;
        })
            .filter((key, idx, arr) => {
            return arr.indexOf(key) === idx;
        });
    }
}
exports.Metadata = Metadata;
// tslint:enable no-any


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(24);
// tslint:disable no-any
function ComponentStylesMixin(base) {
    class ComponentStyles extends base {
        constructor(...args) {
            super(...args);
            const shadyCSS = window.ShadyCSS;
            const hasNativeShadowDOMSupport = !shadyCSS;
            if (!this.styleElements)
                this.styleElements = [];
            // if no styles have been specified for the component then do nothing.
            if (!this.componentStyles)
                return;
            if (hasNativeShadowDOMSupport) {
                this.styleElements = [
                    skate.h("style", this.componentStyles),
                    ...this.styleElements
                ];
            }
            else {
                // if the OverridingStylesMixin is also being applied, then we need to stop this mixin and let the OverridingStylesMixin
                // apply the component styles, otherwise the overriding styles will get added to the head before the component styles,
                // therefore overriding nothing
                if (!this.overridingStylesMixinApplied)
                    return;
                const elementName = this.localName; // _this_ should ultimately be of type HTMLElement
                if (ComponentStyles._seenTags[elementName] !== true) {
                    ComponentStyles._seenTags[elementName] = true;
                    const $template = document.createElement("template");
                    $template.innerHTML = `<style>${this.componentStyles}</style>`;
                    shadyCSS.prepareTemplate($template, elementName);
                }
            }
        }
        // used the inform other mixins of the presence of this one
        get componentStylesMixinApplied() {
            return true;
        }
    }
    ComponentStyles._seenTags = {};
    return ComponentStyles;
}
exports.ComponentStylesMixin = ComponentStylesMixin;
// tslint:enable no-any


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var renderMixin_1 = __webpack_require__(94);
exports.RenderMixin = renderMixin_1.RenderMixin;
var componentStylesMixin_1 = __webpack_require__(91);
exports.ComponentStylesMixin = componentStylesMixin_1.ComponentStylesMixin;
var overridingStylesMixin_1 = __webpack_require__(93);
exports.OverridingStylesMixin = overridingStylesMixin_1.OverridingStylesMixin;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(24);
// tslint:disable no-any
function OverridingStylesMixin(base) {
    class OverridingStyles extends base {
        constructor(...args) {
            super(...args);
            const elementName = this.localName; // _this_ should ultimately be of type HTMLElement
            const shadyCSS = window.ShadyCSS;
            const hasNativeShadowDOMSupport = !shadyCSS;
            // look for __CtOverridingStyles property on the window object
            const overridingStylesObject = (window.__CtOverridingStyles) || {};
            const componentOverridingStyleSheets = [
                ...overridingStylesObject["*"] || [],
                ...overridingStylesObject[elementName.toLowerCase()] || []
            ];
            // we don't initially check for overrriding style sheets here because we need this code to execute if ComponentStylesMixin is depending on it
            if (hasNativeShadowDOMSupport) {
                // have any overriding stylesheets been added to this tag?
                if (componentOverridingStyleSheets) {
                    if (!this.styleElements)
                        this.styleElements = [];
                    componentOverridingStyleSheets.forEach(x => {
                        const isFile = /^(.*?)\.css$/.test(x);
                        const content = isFile
                            ? `@import url('${x}');`
                            : x;
                        this.styleElements = [
                            ...this.styleElements,
                            skate.h("style", content)
                        ];
                    });
                }
            }
            else {
                if (OverridingStyles._seenTags[elementName] !== true) {
                    OverridingStyles._seenTags[elementName] = true;
                    // multiple sheets can be provided so we need to queue them all up
                    const promises = [];
                    function fetchSheet(url) {
                        return new Promise(resolve => {
                            const xhr = new XMLHttpRequest();
                            xhr.onreadystatechange = () => {
                                if (xhr.readyState === XMLHttpRequest.DONE) {
                                    if (xhr.status === 200) {
                                        resolve(xhr.responseText);
                                    }
                                    else {
                                        resolve(`:host { content: 'Error: could not load stylesheet: ${url}' }`);
                                    }
                                }
                            };
                            xhr.open("GET", url);
                            xhr.send();
                        });
                    }
                    if (componentOverridingStyleSheets) {
                        componentOverridingStyleSheets.forEach(x => {
                            const isFile = /^(.*?)\.css$/.test(x);
                            const promise = isFile
                                ? fetchSheet(x)
                                : Promise.resolve(x);
                            promises.push(promise);
                        });
                    }
                    Promise
                        .all(promises)
                        .then(styles => {
                        // once we have all the CSS we need to mash them into a template element for the ShadyCSS polyfill
                        const $template = document.createElement("template");
                        // if component styles are available and the ComponentStylesMixin has been applied then we need to apply the styles here *before* we apply the overriding styles
                        if (this.componentStyles && this.componentStylesMixinApplied === true) {
                            $template.innerHTML += this.componentStyles;
                        }
                        if (styles.length > 0) {
                            const css = styles.join("\n");
                            $template.innerHTML += `<style>${css}</style>`;
                        }
                        if ($template.innerHTML.length) {
                            shadyCSS.prepareTemplate($template, elementName);
                        }
                    });
                }
            }
        }
        // used the inform other mixins of the presence of this one
        get overridingStylesMixinApplied() {
            return true;
        }
    }
    OverridingStyles._seenTags = {};
    return OverridingStyles;
}
exports.OverridingStylesMixin = OverridingStylesMixin;
// tslint:enable no-any


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
function RenderMixin(base) {
    class Render extends base {
        renderCallback() {
            const styles = ensureArray(this.styleElements || []);
            const html = ensureArray(this.componentMarkup
                ? this.componentMarkup() || []
                : []);
            return [
                ...styles,
                ...html
            ];
        }
    }
    function ensureArray(value) {
        return (value instanceof Array)
            ? value
            : [value];
    }
    return Render;
}
exports.RenderMixin = RenderMixin;
// tslint:enable no-any


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var AppMode;
(function (AppMode) {
    // tslint:disable no-any
    AppMode[AppMode["Broadcaster"] = "broadcaster"] = "Broadcaster";
    AppMode[AppMode["Responder"] = "responder"] = "Responder";
    // tslint:enable no-any
})(AppMode = exports.AppMode || (exports.AppMode = {}));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ChatEntryType;
(function (ChatEntryType) {
    // tslint:disable no-any
    ChatEntryType[ChatEntryType["Meta"] = "meta"] = "Meta";
    ChatEntryType[ChatEntryType["Chat"] = "chat"] = "Chat";
    ChatEntryType[ChatEntryType["Divider"] = "divider"] = "Divider";
    // tslint:enable no-any
})(ChatEntryType = exports.ChatEntryType || (exports.ChatEntryType = {}));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ChatRole;
(function (ChatRole) {
    // tslint:disable no-any
    ChatRole[ChatRole["Participant"] = "member"] = "Participant";
    ChatRole[ChatRole["Administrator"] = "admin"] = "Administrator";
    ChatRole[ChatRole["Owner"] = "owner"] = "Owner";
    // tslint:enable no-any
})(ChatRole = exports.ChatRole || (exports.ChatRole = {}));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus[ConnectionStatus["Connecting"] = "connecting"] = "Connecting";
    ConnectionStatus[ConnectionStatus["Connected"] = "connected"] = "Connected";
    ConnectionStatus[ConnectionStatus["Disconnected"] = "disconnected"] = "Disconnected";
    ConnectionStatus[ConnectionStatus["Disconnecting"] = "disconnecting"] = "Disconnecting";
})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));
// tslint:enable no-any


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
class DisconnectionStatus {
    constructor(wontReconnect, reason) {
        this.wontReconnect = wontReconnect;
        this.reason = reason;
    }
    getReason() {
        return this.reason;
    }
}
exports.DisconnectionStatus = DisconnectionStatus;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var RoomRole;
(function (RoomRole) {
    // tslint:disable no-any
    RoomRole[RoomRole["None"] = "none"] = "None";
    RoomRole[RoomRole["Participant"] = "participant"] = "Participant";
    RoomRole[RoomRole["Moderator"] = "moderator"] = "Moderator";
    // tslint:enable
})(RoomRole = exports.RoomRole || (exports.RoomRole = {}));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var UserAdditionalDetailsType;
(function (UserAdditionalDetailsType) {
    // tslint:disable no-any
    UserAdditionalDetailsType[UserAdditionalDetailsType["Contact"] = "contact"] = "Contact";
    UserAdditionalDetailsType[UserAdditionalDetailsType["VCard"] = "vcard"] = "VCard";
    UserAdditionalDetailsType[UserAdditionalDetailsType["Participant"] = "participant"] = "Participant";
    UserAdditionalDetailsType[UserAdditionalDetailsType["DirectoryUser"] = "directoryuser"] = "DirectoryUser";
    // tslint:enable no-any
})(UserAdditionalDetailsType = exports.UserAdditionalDetailsType || (exports.UserAdditionalDetailsType = {}));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(31);
const Logger_1 = __webpack_require__(17);
const utils_2 = __webpack_require__(2);
class BaseStore {
    constructor(name, logger, autoCompact = false, encryption = true) {
        this._saveToPersistentQueue = Promise.resolve();
        this._isDestoryingDb = false;
        this.name = name;
        this.logger = logger;
        this._autoCompact = autoCompact;
        this._encryption = encryption;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._db) {
                yield this._createDb(this.name);
            }
            this.state = yield this.getFromPersistent();
            if (this.logger.shouldLog(Logger_1.LoggerTypes.DataStorage)) {
                const stateClone = utils_2.deepCloneObject(this.state);
                this.logger.log(Logger_1.LoggerTypes.DataStorage, " %cINITIAL STATE:", "color: #606; font-weight: bold;", Object.assign({}, stateClone));
                this.prevState = stateClone;
            }
        });
    }
    savePushNotificationToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pushNotificationToken = token;
            yield this.saveToPersistent();
        });
    }
    getPushNotificationToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.pushNotificationToken;
        });
    }
    savePushNotificationAzureId(azureId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pushNotificationTokenAzureId = azureId;
            yield this.saveToPersistent();
        });
    }
    getPushNotificationAzureId() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.pushNotificationTokenAzureId;
        });
    }
    clearAllData() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                localStorage.removeItem(this.name);
                if (this._db && !this._isDestoryingDb) {
                    this._isDestoryingDb = true;
                    this._db
                        .destroy()
                        .then(() => {
                        this._createDb(this.name);
                        return this.init();
                    })
                        .then(() => {
                        this._isDestoryingDb = false;
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    getLoggerTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.loggerTypes;
        });
    }
    saveLoggerTypes(types) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.loggerTypes = types;
            return yield this.saveToPersistent();
        });
    }
    deleteLoggerTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            delete this.state.loggerTypes;
            return yield this.saveToPersistent();
        });
    }
    getStateSnapshot() {
        return this.state;
    }
    getTheme() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.theme || "";
        });
    }
    saveTheme(theme) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.theme = theme;
            return yield this.saveToPersistent();
        });
    }
    getFromPersistent() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._db) {
                try {
                    return yield this._db.get(this.name);
                }
                catch (ex) {
                    const state = this.generateInitialState();
                    const res = yield this._db.put(state);
                    state._rev = res.rev;
                    return state;
                }
            }
            else {
                return localStorage.getItem(this.name)
                    ? JSON.parse(localStorage.getItem(this.name))
                    : this.generateInitialState();
            }
        });
    }
    saveToPersistent() {
        return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._saveDebouncer);
            this._saveDebouncer = setTimeout(() => {
                if (this._db) {
                    this._saveToPersistentQueue = this._saveToPersistentQueue.then(() => __awaiter(this, void 0, void 0, function* () {
                        try {
                            const res = yield this._db.put(this.state);
                            this.state._rev = res.rev;
                            if (this.logger.shouldLog(Logger_1.LoggerTypes.DataStorage)) {
                                this._logUpdate();
                            }
                        }
                        catch (ex) {
                            throw new Error(ex);
                        }
                    }));
                }
                else {
                    localStorage[this.name] = JSON.stringify(this.state);
                    if (this.logger.shouldLog(Logger_1.LoggerTypes.DataStorage)) {
                        this._logUpdate();
                    }
                }
            }, 150);
        });
    }
    // === Private functions === //
    _createDb(name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (window.PouchDB) {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cUSING POUCHDB: %c${name}`, "color: #606; font-weight: bold;", "color: #999; font-weight: normal;");
                this._db = new window.PouchDB(`${name}`, {
                    revs_limit: 1,
                    auto_compaction: this._autoCompact
                });
                if (this._encryption === true) {
                    this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cENCRYPTING POUCHDB...`, "color: #606; font-weight: bold;", "color: #999; font-weight: normal;");
                    // tslint:disable-next-line no-any
                    const keyBuffer = yield utils_1.getEncryptionKey(name + "_layer");
                    this._db.crypto({ key: keyBuffer });
                }
            }
            else {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, " %cCANNOT FIND POUCHDB, USING LOCAL STORAGE INSTEAD", "color: #606; font-weight: bold;");
            }
        });
    }
    _logUpdate() {
        const stateClone = utils_2.deepCloneObject(this.state);
        // tslint:disable-next-line no-any
        const diffs = utils_2.getDiffs(this.prevState, stateClone);
        // tslint:disable-next-line no-any
        const groupedDiffs = utils_2.groupArrayItemsByKey(diffs, x => x.path);
        const changedProps = Object.keys(groupedDiffs);
        if (diffs.length === 0) {
            this.logger.log(Logger_1.LoggerTypes.DataStorage, " %cSTATE UPDATED %c- NO STATE CHANGES", "color: #606; font-weight: bold;", "color: #999; font-weight: bold;", Object.assign({}, stateClone));
        }
        else {
            this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cSTATE UPDATED`, "color: #606; font-weight: bold;", Object.assign({}, stateClone));
            this.logger.group(Logger_1.LoggerTypes.DataStorage, diffs.length < 3, ` %c${diffs.length} STATE CHANGE(S):`, "color: #999; font-weight: bold;");
            changedProps.forEach(key => {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, `%cstate.${key}:`, "color: #666; font-weight: normal;");
                groupedDiffs[key].forEach(diff => {
                    if (diff.added || diff.deleted) {
                        const color = diff.added ? "090" : "900";
                        this.logger.log(Logger_1.LoggerTypes.DataStorage, `  %c${diff.type.toLowerCase()}:`, `color: #${color}; font-weight: normal;`, diff.rhs);
                    }
                    else {
                        this.logger.log(Logger_1.LoggerTypes.DataStorage, `  %c${diff.lhs || "<empty>"} %c %c${diff.rhs}`, "color: #900; font-weight: normal;", "color: #CCC;", "color: #090; font-weight: normal;");
                    }
                });
            });
            this.logger.groupEnd(Logger_1.LoggerTypes.DataStorage);
        }
        this.prevState = stateClone;
    }
}
exports.BaseStore = BaseStore;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const events_1 = __webpack_require__(9);
const models_1 = __webpack_require__(1);
const Keys_1 = __webpack_require__(20);
class CTCLComponent extends base_1.CTLayerComponent {
    initialize(layer) {
        return __awaiter(this, void 0, void 0, function* () {
            this.layer.setShowChatFunction(() => {
                this.emitComponentEvent("go-chat");
            });
        });
    }
    setupConnectionStatusListener(onChange) {
        this._updateConnectionStatus(this.layer.getConnectionStatus());
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            this._updateConnectionStatus(detail.status, onChange);
        }, { dontSuppress: true });
    }
    showAcknowledge(title, message) {
        return new Promise(resolve => {
            super.launchAckownledgeDialog(title, message, () => resolve());
        });
    }
    requestConfirmation(message) {
        return new Promise(resolve => {
            const title = this.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.ARE_YOU_SURE));
            super.launchConfirmationDialog(title, message, () => resolve(true), () => resolve(false));
        });
    }
    // === Private functions === //
    _updateConnectionStatus(status, handler) {
        this.connectionStatus = status;
        this.isOnline = status === models_1.ConnectionStatus.Connected;
        if (typeof (handler) === "function")
            handler({ status: this.connectionStatus, online: this.isOnline });
    }
}
__decorate([
    base_1.prop({ type: String, attribute: false, default: models_1.ConnectionStatus.Disconnected })
], CTCLComponent.prototype, "connectionStatus", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLComponent.prototype, "isOnline", void 0);
exports.CTCLComponent = CTCLComponent;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ct_xmpp_client_1 = __webpack_require__(21);
const errors_1 = __webpack_require__(25);
const Logger_1 = __webpack_require__(17);
const BaseComms_1 = __webpack_require__(78);
const models_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(2);
const ChatUtils_1 = __webpack_require__(10);
const Keys_1 = __webpack_require__(20);
const Keys_2 = __webpack_require__(13);
const Events_1 = __webpack_require__(4);
class Comms extends BaseComms_1.BaseComms {
    constructor(name, config, store, logger, chatLayer) {
        super(name, config, store, logger);
        this.user = null;
        this._loggedIn = false;
        this._postLoginTimeout = null;
        this._shouldClearData = false;
        this._mamFetchInProgress = false;
        this._mamQueryInProgress = false;
        this._disconnectedDuringMamFetch = false;
        // === Overridden base functions === //
        /**
         * This is a catch all that is called when you disconnect during login.
         * It will clear down the login timeout and reset the data so that the next
         * login attempt is starting from a clean slate.
         */
        this._onDisconnectDuringLogin = (status) => {
            if (status.detail === models_1.ConnectionStatus.Disconnected && this._postLoginTimeout) {
                this.clearPostLoginTimeout();
                this._chatLayer.clearAllData();
                document.removeEventListener("__cm-connection-change", this._onDisconnectDuringLogin);
            }
        };
        this._chatLayer = chatLayer;
        this._setupHandlers();
    }
    login(username, password, fireEvents = true) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            this._chatLayer.showWaitingMessage(this._chatLayer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.AUTHENTICATING)));
            this._chatLayer.enableSuppressMode("chat/comms#login", true);
            document.removeEventListener("__cm-connection-change", this._onDisconnectDuringLogin);
            document.addEventListener("__cm-connection-change", this._onDisconnectDuringLogin);
            try {
                yield _super("login").call(this, username, password, false);
                yield this._postLogin();
            }
            catch (ex) {
                this._handleLoginFailure();
                this.triggerLoginEvent(false, ex.msg);
                throw ex;
            }
        });
    }
    // === Protected functions === //
    setPresence() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.client.sendPresence();
            }
            catch (ex) {
                this.logger.error(ex);
                throw ex;
            }
        });
    }
    getAllMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.getAllMessages();
        });
    }
    getMucHost() {
        return this.client.mucHost;
    }
    findChatEntriesToPurge(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            let chatEntries = [];
            try {
                // Get all the messages
                const allMessages = yield this.getAllMessages();
                // Filter down to only messages in the conversation
                const messagesInConversation = allMessages.filter((message) => message.recipient_id === `${conversation.id}@${this.client.mucHost}` || message.sender_id === `${conversation.id}@${this.client.mucHost}`);
                // Order them by timestamp
                const messagesInConversationOrdered = messagesInConversation.sort((a, b) => {
                    return a.ts - b.ts;
                });
                // Filter out the messages to be kept (i.e. the newest n - default 30)
                chatEntries = messagesInConversationOrdered.splice(0, messagesInConversationOrdered.length - this._chatLayer.config.behaviour.maxChatEntriesToStore);
            }
            catch (err) {
                this.logger.error("Couldn't fetch chat entries to purge:", err);
            }
            return chatEntries;
        });
    }
    isMamFetchInProgress() {
        return this._mamFetchInProgress;
    }
    embelishUser(user) {
        return __awaiter(this, void 0, void 0, function* () {
            user.connectionStatus = user.connectionStatus || models_1.ConnectionStatus.Disconnected;
            user.displayName = utils_1.formatUserName(user, utils_1.NameFormat.PREFIX_FIRST_LAST);
            return user;
        });
    }
    // === Private functions === //
    _setupHandlers() {
        this.onStatusUpdate((status) => __awaiter(this, void 0, void 0, function* () {
            if (status === models_1.ConnectionStatus.Connected) {
                this._chatLayer.enableSuppressMode("chat/comms#login", true);
            }
            if (this.user) {
                this.user.connectionStatus = status;
            }
        }));
        this.onAutoReconnected(({ resumed }) => __awaiter(this, void 0, void 0, function* () {
            const wasLoggedIn = (this._loggedIn === true);
            const isStreamResumption = (resumed === true);
            if (wasLoggedIn === false) {
                try {
                    yield this._chatLayer.bootstrapper;
                    yield this._postLogin(isStreamResumption);
                }
                catch (ex) {
                    this._handleLoginFailure();
                    this.triggerLoginEvent(false, ex);
                }
            }
            else if (this._disconnectedDuringMamFetch || !isStreamResumption) {
                if (this._disconnectedDuringMamFetch) {
                    // there is a risk that the data known by the XMPP library databases is out of sync with our databases because the MAM fetch was interrupted,
                    // so the safest thing is to delete all local data so that the next MAM fetch can be from a clean slate
                    yield this._chatLayer.clearAllData();
                }
                const latestIdentifier = yield this._chatLayer.store.getLatestIdentifier();
                yield this._chatLayer.loadAllConversations();
                yield this._processMissedPersonalMamMessage(latestIdentifier);
                this._chatLayer.cancelSuppressMode("chat/comms#login");
                yield this._priorityAlert();
                yield this.setPresence();
            }
            else {
                this._chatLayer.cancelSuppressMode("chat/comms#login");
                yield this._priorityAlert();
                yield this.setPresence();
            }
            this._chatLayer.emit(Events_1.ChatEvents.AutoReconnected, { resumed });
        }));
        this.onDatabasesAutoDestroyed(() => __awaiter(this, void 0, void 0, function* () {
            this._shouldClearData = true;
        }));
    }
    _priorityAlert() {
        return __awaiter(this, void 0, void 0, function* () {
            const conversation = this._chatLayer.getNewestPendingAlert();
            if (conversation) {
                return yield this._chatLayer.priorityAlert(conversation);
            }
        });
    }
    _postLogin(resumed = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.username)
                return Promise.reject(new Error("Error in post-login: no username specified"));
            yield this._chatLayer.showWaitingMessage(this._chatLayer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.SYNCING)));
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                this.clearPostLoginTimeout();
                const loginTimeoutDuration = this.xmppConfig.loginTimeout || 10000;
                this._postLoginTimeout = setTimeout(() => {
                    this.clearPostLoginTimeout();
                    this.logger.log(Logger_1.LoggerTypes.Connectivity, "%c LOGIN TIMED OUT", "color: #600; font-weight: bold;");
                    reject(new Error(this._chatLayer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.LOGIN_TIMEOUT))));
                }, loginTimeoutDuration);
                if (this._shouldClearData) {
                    this.logger.log(Logger_1.LoggerTypes.CleanUp, `%c DELETING DATA FOR FRESH USER`, "color: #669; font-weight: bold;");
                    yield this._chatLayer.store.clearChatData();
                    this._shouldClearData = false;
                }
                this.user = yield this._chatLayer.getUserByJid(this.username);
                if (!this.user) {
                    const errorMessage = this._chatLayer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.USER_NOT_FOUND)).replace("{{username}}", this.username);
                    return reject(new Error(errorMessage));
                }
                const latestIdentifier = yield this._chatLayer.store.getLatestIdentifier();
                yield this._chatLayer.showWaitingMessage(this._chatLayer.translateI18nItem(Keys_2.ChatCommonMetadata.getI18nItem(Keys_2.ChatCommonI18nKeys.FETCHING_CONVERSATIONS)));
                yield this._chatLayer.loadAllConversations();
                if (!resumed) {
                    // Dont query the personal MAM if we have resumed the stream
                    yield this._chatLayer.showWaitingMessage(this._chatLayer.translateI18nItem(Keys_2.ChatCommonMetadata.getI18nItem(Keys_2.ChatCommonI18nKeys.FETCHING_OWN_DATA)));
                    yield this._processMissedPersonalMamMessage(latestIdentifier);
                }
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c LOGIN COMPLETE > %c${this.username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                yield this._chatLayer.dismissWaitingMessage();
                this._chatLayer.cancelSuppressMode("chat/comms#login");
                this.clearPostLoginTimeout();
                this._loggedIn = true;
                yield this.setPresence();
                yield this._chatLayer.purgeAllConversations();
                this.triggerLoginEvent(true);
                yield this._priorityAlert();
                resolve();
            }));
        });
    }
    _handleLoginFailure() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            this.user = null;
            this._loggedIn = false;
            yield _super("logout").call(this, true, true);
        });
    }
    // === Implementation === //
    fetchConversationMessages(conversation, lastId = null, count = null, timestamp = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let archiveId = (Date.now() * 1000).toString();
            if (lastId) {
                const message = yield this.client.getMessageById(lastId);
                archiveId = message.archive_id;
            }
            return yield this._fetchEarlierConversationMessages(conversation, archiveId, count, timestamp);
        });
    }
    clearStoredConversationMessages(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deleteMessagesByRoomName(conversation.id);
        });
    }
    clearStoredConversationAttachments(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const proms = [];
                conversation.attachments.forEach((attachment) => {
                    if (attachment.local !== undefined) {
                        proms.push(new Promise((resolve) => {
                            return this.client.deleteFile(attachment.local).then(resolve).catch(err => {
                                this.logger.log(Logger_1.LoggerTypes.XmppClient, `Couldn't delete attachment at: '${attachment.local}':`, err);
                                resolve();
                            });
                        }));
                    }
                });
                Promise.all(proms).then(() => {
                    resolve();
                });
            }));
        });
    }
    clearPostLoginTimeout() {
        clearTimeout(this._postLoginTimeout);
        this._postLoginTimeout = null;
    }
    // === Private functions === //
    _processMissedPersonalMamMessage(latestIdentifier = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mamFetchInProgress === true) {
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c MAM FETCHING ALREADY IN PROGRESS: SKIPPING MAM CHECK`, "color: #669; font-weight: bold;");
                return;
            }
            try {
                this._mamQueryInProgress = false;
                this._disconnectedDuringMamFetch = false;
                const lastKnownId = latestIdentifier && latestIdentifier.toString() || null;
                // If we don't have a last identifier then we don't need to query the MAM because the conversation fetch will give us everything we need
                if (lastKnownId === null)
                    return;
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c QUERYING PERSONAL MAM FOR MISSED MESSAGE(S) FOR USER: %c${this.username} (since ${lastKnownId})`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                const start = Date.now();
                const mamMessages = yield this.client.queryMam(null, lastKnownId, null, null, false);
                const end = Date.now();
                this._mamQueryInProgress = false;
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c QUERYING PERSONAL MAM TOOK ${end - start}ms`, "color: #669; font-weight: bold;");
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c FOUND ${mamMessages.length} MISSED MESSAGE(S) IN PERSONAL MAM`, "color: #669; font-weight: bold;");
                if (mamMessages.length > 0) {
                    const invalidMessages = [];
                    const ignoredMessages = [];
                    mamMessages.forEach(message => {
                        if (!message || !utils_1.jidsMatch(message.recipient_id, this.username)) {
                            invalidMessages.push(message);
                            return;
                        }
                        const messageType = utils_1.getMessageType(message);
                        if (!messageType) {
                            invalidMessages.push(message);
                            return;
                        }
                        if (this.logger.shouldLog(Logger_1.LoggerTypes.Mam)) {
                            this.logger.log(Logger_1.LoggerTypes.Mam, `%c DISPATCHING PERSONAL MAM MESSAGE:%c`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(message));
                        }
                        this.client._dispatchEvent(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, message);
                    });
                    this.logger.log(Logger_1.LoggerTypes.Mam, `%c ${mamMessages.length - ignoredMessages.length - invalidMessages.length} PERSONAL MAM MESSAGE(S) DISPATCHED`, "color: #669; font-weight: bold;");
                    if (ignoredMessages.length > 0) {
                        this.logger.log(Logger_1.LoggerTypes.Mam, `%c ${ignoredMessages.length} PERSONAL MAM MESSAGE(S) IGNORED DUE TO STANZA EXCLUSION RULES`, "color: #669; font-weight: bold;", ignoredMessages);
                    }
                    if (invalidMessages.length > 0) {
                        this.logger.log(Logger_1.LoggerTypes.Mam, `%c ${invalidMessages.length} INVALID PERSONAL MAM MESSAGE(S) IGNORED`, "color: #C00; font-weight: bold;", invalidMessages);
                    }
                    this._mamFetchInProgress = false;
                }
                else {
                    this._mamFetchInProgress = false;
                }
            }
            catch (exIq) {
                // tslint:disable-next-line no-any
                const errorJson = ct_xmpp_client_1.CtXmppClient.xmlToJson(exIq);
                const errorText = errorJson && errorJson.iq && errorJson.iq.error && errorJson.iq.error.text && errorJson.iq.error.text.$value || "";
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c ERROR DURING PERSONAL MAM FETCH`, "color: #C00; font-weight: bold;", Object.assign({}, errorJson));
                throw new errors_1.IQError(errorText, errorJson.iq);
            }
        });
    }
    _fetchEarlierConversationMessages(conversation, archiveId, count, timestamp = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mamFetchInProgress === true) {
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c MAM FETCHING ALREADY IN PROGRESS: SKIPPING MAM CHECK`, "color: #669; font-weight: bold;");
                return;
            }
            try {
                const roomName = conversation.roomJid.split("@").shift();
                this._mamQueryInProgress = false;
                this._disconnectedDuringMamFetch = false;
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c QUERYING ROOM MAM FOR MESSAGES FOR CONVERSATION: %c${roomName} (before ${archiveId})`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                const start = Date.now();
                const mamMessages = yield this.client.queryMamRoomHistoryByName(roomName, archiveId, count, false, timestamp);
                const end = Date.now();
                this._mamQueryInProgress = false;
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c QUERYING ROOM MAM TOOK ${end - start}ms`, "color: #669; font-weight: bold;");
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c FOUND ${mamMessages.length} MESSAGE(S) IN THE ROOM MAM`, "color: #669; font-weight: bold;", mamMessages);
                const validMamMessages = [];
                if (mamMessages.length > 0) {
                    const invalidMessages = [];
                    const ignoredMessages = [];
                    mamMessages.forEach(message => {
                        if (!message) {
                            invalidMessages.push(message);
                            return;
                        }
                        const messageType = utils_1.getMessageType(message);
                        if (!messageType) {
                            invalidMessages.push(message);
                            return;
                        }
                        if (this.logger.shouldLog(Logger_1.LoggerTypes.Mam)) {
                            this.logger.log(Logger_1.LoggerTypes.Mam, `%c DISPATCHING ROOM MAM MESSAGE:%c`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;", utils_1.getMessageContentForDebug(message));
                        }
                        this.client._dispatchEvent(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, message);
                        validMamMessages.push(message);
                    });
                    const chatEntries = yield Promise.all(validMamMessages.map((message) => __awaiter(this, void 0, void 0, function* () { return yield ChatUtils_1.convertToChatEntry(message, this._chatLayer); })));
                    this.logger.log(Logger_1.LoggerTypes.Mam, `%c ${mamMessages.length - ignoredMessages.length - invalidMessages.length} ROOM MAM MESSAGE(S) DISPATCHED`, "color: #669; font-weight: bold;");
                    if (ignoredMessages.length > 0) {
                        this.logger.log(Logger_1.LoggerTypes.Mam, `%c ${ignoredMessages.length} ROOM MAM MESSAGE(S) IGNORED DUE TO STANZA EXCLUSION RULES`, "color: #669; font-weight: bold;", ignoredMessages);
                    }
                    if (invalidMessages.length > 0) {
                        this.logger.log(Logger_1.LoggerTypes.Mam, `%c ${invalidMessages.length} INVALID ROOM MAM MESSAGE(S) IGNORED`, "color: #C00; font-weight: bold;", invalidMessages);
                    }
                    this._mamFetchInProgress = false;
                    return chatEntries;
                }
                else {
                    this._mamFetchInProgress = false;
                    return [];
                }
            }
            catch (exIq) {
                // tslint:disable-next-line no-any
                const errorJson = ct_xmpp_client_1.CtXmppClient.xmlToJson(exIq);
                const errorText = errorJson && errorJson.iq && errorJson.iq.error && errorJson.iq.error.text && errorJson.iq.error.text.$value || "";
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c ERROR DURING ROOM MAM FETCH`, "color: #C00; font-weight: bold;", Object.assign({}, errorJson));
                if (!errorText.includes("Only members may query archives of this room")) {
                    throw new errors_1.IQError(errorText, errorJson.iq);
                }
                return;
            }
        });
    }
}
exports.Comms = Comms;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const ct_xmpp_client_1 = __webpack_require__(21);
const components_1 = __webpack_require__(3);
const component_1 = __webpack_require__(15);
const Models_1 = __webpack_require__(5);
const models_1 = __webpack_require__(1);
const ctcl_audio_recorder_player_1 = __webpack_require__(49);
const Events_1 = __webpack_require__(4);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ADD_AUDIO_ATTACHMENT"] = "Add Audio Attachment"] = "ADD_AUDIO_ATTACHMENT";
    I18nKeys[I18nKeys["NO_AUDIO_ATTACHED"] = "No audio attached"] = "NO_AUDIO_ATTACHED";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLAudioAttachment = class CTCLAudioAttachment extends base_1.CTLayerComponent {
    constructor() {
        // === Attribute properties === //
        super(...arguments);
        this._loadFromSource = false;
        this.attachClick = () => __awaiter(this, void 0, void 0, function* () {
            const files = yield ct_xmpp_client_1.CtXmppClient.pickFile({ mimeTypes: this.fileTypes });
            if (files && files.length) {
                this._loadFromSource = true;
                this.audioSrc = files[0];
                if (this.callback) {
                    this.callback(this.audioSrc);
                }
            }
        });
        this._recordClick = () => __awaiter(this, void 0, void 0, function* () {
            this._loadFromSource = false;
            this.audioSrc = "";
            this.recordAudio = !this.recordAudio;
        });
        this._onRecordFinished = (filepath) => {
            if (this.callback)
                this.callback(filepath);
        };
        this._onRecordingDeleted = () => {
            this.audioSrc = "";
            this._loadFromSource = false;
            if (this.callback)
                this.callback(this.audioSrc);
        };
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.addListener(Events_1.ChatEvents.AudioRecordingStarted, () => this.audioRecording = true);
        this.addListener(Events_1.ChatEvents.AudioRecordingStopped, () => this.audioRecording = false);
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("h4", null, this.translateI18nItem(I18nKeys.ADD_AUDIO_ATTACHMENT)),
            window.__CTRender("div", { class: "controls" },
                this.allowAttach &&
                    window.__CTRender("div", { class: `action ${this.recordAudio || this.audioSrc ? "disabled" : ""}`, onClick: this.recordAudio || this.audioSrc ? null : this.attachClick },
                        window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.MusicalNote })),
                this.allowRecord &&
                    window.__CTRender("div", { class: `action ${this.audioSrc || this.audioRecording ? "disabled" : ""}`, onClick: this.audioSrc || this.audioRecording ? null : this._recordClick },
                        window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Microphone })),
                window.__CTRender("div", { class: "placeholder" }, this.isLoading
                    ? window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true })
                    : this.recordAudio || this.audioSrc
                        ? window.__CTRender(ctcl_audio_recorder_player_1.CTCLAudioRecorderPlayer, { onRecordingFinished: this._onRecordFinished, onAudioRemoved: this._onRecordingDeleted, showRecord: !this._loadFromSource, source: this.audioSrc, allowRemoval: true })
                        : window.__CTRender("p", null, this.translateI18nItem(I18nKeys.NO_AUDIO_ATTACHED))))));
    }
};
__decorate([
    base_1.prop({ type: Array, attribute: true, default: ["audio/mp3", "audio/mp4", "audio/m4a"] })
], CTCLAudioAttachment.prototype, "fileTypes", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTCLAudioAttachment.prototype, "callback", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioAttachment.prototype, "isLoading", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTCLAudioAttachment.prototype, "audioSrc", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioAttachment.prototype, "recordAudio", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLAudioAttachment.prototype, "audioRecording", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLAudioAttachment.prototype, "allowAttach", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLAudioAttachment.prototype, "allowRecord", void 0);
CTCLAudioAttachment = __decorate([
    component_1.component({ tag: "ct-cl-audio-attachment", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host div.container{display:flex;padding:10px;flex-direction:column}:host div.container h4{margin-top:0;font-weight:normal;text-transform:uppercase;font-size:0.8em;color:var(--tertiary-placeholder-color, #212121)}:host div.container div.controls{display:flex}:host div.container div.controls div.action{display:flex;justify-content:center;align-items:center;flex:none;width:36px;height:36px;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border-radius:50%;cursor:pointer;margin-right:10px;transition:0.5s all ease-in}:host div.container div.controls div.action.disabled{background:var(--subtle-font-color, #828688);cursor:default}:host div.container div.controls div.placeholder{display:flex;flex:1}:host div.container div.controls div.placeholder ctcl-audio-player{flex:0}:host div.container div.controls div.placeholder div.action{margin-left:auto}:host div.container div.controls div.placeholder p{margin:auto 0;align-items:center;color:var(--subtle-font-color, #828688)}
    `], i18nKeys: I18nKeys })
], CTCLAudioAttachment);
exports.CTCLAudioAttachment = CTCLAudioAttachment;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Models_1 = __webpack_require__(5);
const Base_1 = __webpack_require__(12);
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const ct_cl_header_1 = __webpack_require__(29);
const models_1 = __webpack_require__(1);
const Events_1 = __webpack_require__(4);
const metadata_1 = __webpack_require__(11);
const utils_1 = __webpack_require__(2);
const Models = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(8);
const Models_2 = __webpack_require__(173);
const PriorityConversationAcknowledgedEventArgs_1 = __webpack_require__(55);
const ctcl_attachment_handler_1 = __webpack_require__(48);
const ConversationConfigReader_1 = __webpack_require__(14);
const ct_action_sheet_1 = __webpack_require__(58);
const volume_control_1 = __webpack_require__(57);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["EXPIRED_PRIORITY_CONVERSATION"] = "Expired Priority Conversation"] = "EXPIRED_PRIORITY_CONVERSATION";
    I18nKeys[I18nKeys["ACKNOWLEDGE"] = "Acknowledge"] = "ACKNOWLEDGE";
    I18nKeys[I18nKeys["MUTE"] = "Mute"] = "MUTE";
    I18nKeys[I18nKeys["CONVERSATION_IS_CLOSED"] = "This conversation is closed."] = "CONVERSATION_IS_CLOSED";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLConversationAlertMetadata {
    static _create() {
        return new metadata_1.Metadata(CTCLConversationAlert, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLConversationAlertMetadata._instance = null;
exports.CTCLConversationAlertMetadata = CTCLConversationAlertMetadata;
class CTCLConversationAlert extends Base_1.CTCLComponent {
    constructor() {
        super();
        // private _priority: Priority = null;
        this._raisedBy = "";
        this._animationDuration = 500;
        this.mute = () => {
            this.layer.mute();
            this.muted = true;
        };
        this.setMetadata(CTCLConversationAlertMetadata.instance);
    }
    initialize(layer) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this, layer);
        });
    }
    setupListeners() {
        this.setupConnectionStatusListener((data) => {
            if (data.online) {
                if (this.muted === true && this.disableMute === false) {
                    // Resume alert after being muted whilst offline
                    this.emitEvent(Events_1.ChatEvents.ResumeAlertAfterPlayingAudio);
                }
            }
        });
        this.addListener(Events_1.ChatEvents.PriorityConversationAcknowledgedOnAnotherDevice, () => __awaiter(this, void 0, void 0, function* () {
            yield this.layer.clearPendingAlert(this.conversation);
            this._resetAndClose();
        }));
        this.addListener(Events_1.ChatEvents.MuteAlertToPlayOtherAudio, () => {
            this.disableMute = true;
        });
        this.addListener(Events_1.ChatEvents.ResumeAlertAfterPlayingAudio, () => {
            this.muted = false;
            this.disableMute = false;
        });
    }
    show(conversation, animate) {
        return __awaiter(this, void 0, void 0, function* () {
            this.animate = animate;
            const newConversation = conversation || this.layer.getNewestPendingAlert();
            if (newConversation) {
                this.conversation = newConversation;
                this._config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, this.conversation);
                this._raisedBy = yield this._getConversationStarter();
                this.showing = false; // Just in case it was already showing and we need to re-render the attachment handler components
                this.muted = false;
                yield utils_1.sleep(animate ? this._animationDuration : 0);
                if (this.conversation.attachments) {
                    const image = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.IMAGE);
                    const audio = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.AUDIO);
                    const video = this.conversation.attachments.find(x => x.type === Models_1.SupportedAttachmentType.VIDEO);
                    if (image) {
                        this.imgAttachmentSrc = image.local || image.path;
                    }
                    if (audio) {
                        this.audioAttachmentSrc = audio.local || audio.path;
                    }
                    if (video) {
                        this.videoAttachmentSrc = video.local || video.path;
                    }
                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        this.showing = true;
                    }), 500);
                }
                else {
                    this.showing = true;
                }
            }
        });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;flex-direction:column;position:fixed;top:0;left:0;height:100%;width:100%;background:#ffffff;font-size:1em;transform:translateY(100%);will-change:transform;z-index:99997}:host .chat-conversation-alert{flex-direction:column;height:100%;display:flex;background-color:var(--list-bg);color:var(--default-font-color)}:host .chat-conversation-alert .header .action{cursor:pointer}:host .chat-conversation-alert .header .pending-count{border-radius:50%;width:30px;height:30px;padding-top:6px;text-align:center;filter:brightness(85%)}:host .chat-conversation-alert .header-priority-details{display:flex;flex:0 0 auto;flex-direction:row;background:var(--header-bg, #22b1c8);color:var(--header-text, #fff)}:host .chat-conversation-alert .header-priority-details>div{padding-left:10px;padding-right:10px;padding-top:8px;padding-bottom:8px}:host .chat-conversation-alert .header-priority-details>div>div{color:var(--header-text, #fff)}:host .chat-conversation-alert .header-priority-details>:not(:last-child){flex:0 0 125px}:host .chat-conversation-alert .header-priority-details>:last-child{flex:1 1 auto}:host .chat-conversation-alert .header-priority-details label{font-size:1em}:host .chat-conversation-alert .header-priority-details .header-priority-detail-value{font-size:1.333em}:host .chat-conversation-alert .chat-description{font-size:1.333em;display:flex;flex-direction:column;flex:1;padding:20px 25px;overflow-y:auto;white-space:pre-line;max-height:270px}:host .chat-conversation-alert .attachment{display:flex;padding:20px 25px 0;flex:0 1 auto;flex-direction:column;min-height:250px;max-height:250px}:host .chat-conversation-alert .attachment div.image{display:flex;flex:1;justify-content:center;align-self:center;padding:20px}:host .chat-conversation-alert .attachment div.image img{height:100%}:host .chat-conversation-alert .attachment div.audio{display:flex;flex:1}:host .chat-conversation-alert .attachment div.audio ctcl-attachment-handler{height:initial;margin-bottom:auto}:host .chat-conversation-alert .footer{flex:0 0 auto;color:#fff;font-size:1em;background:var(--secondary-color, #f2f2f2);border-top:var(--secondary-border, 1px solid #ddd);padding:10px 20px;flex-direction:row;display:flex;margin-top:auto}:host .chat-conversation-alert .footer .yes{flex:1 1;margin:0 5px}:host .chat-conversation-alert .footer .mute{margin-left:10px;font-weight:300}:host([animate]){transition:transform var(--animation-normal, .5s) ease-out}:host([showing]){transform:translateY(0)}
        `;
    }
    generateComponentMarkup() {
        if (!this.showing)
            return null;
        if (!this.conversation) {
            return null;
        }
        return (window.__CTRender("div", { class: "chat-conversation-alert" },
            this._renderHeader(),
            this._renderAttachment(),
            this._renderDescription(),
            this._renderFooter()));
    }
    static get is() {
        return "ct-cl-conversation-alert";
    }
    _renderHeader() {
        const heading = this.conversation.subject;
        const subHeading = this._config.name;
        const darker = this._config.colorCode ? this._colorLuminance(this._config.colorCode, -0.05) : null;
        const darkest = this._config.colorCode ? this._colorLuminance(this._config.colorCode, -0.1) : null;
        return [
            window.__CTRender(ct_cl_header_1.CTCLHeader, { class: "header", backgroundColor: this._config.colorCode },
                window.__CTRender("div", { slot: "left-action" }, (!this._config.autoAlert) &&
                    window.__CTRender(components_1.CTIcon, { class: "action", width: "20", height: "20", icon: models_1.Icons.COMMON.ChevronLeft, onClick: e => this._resetAndClose() })),
                window.__CTRender("div", { slot: "heading" }, heading),
                window.__CTRender("div", { slot: "sub-heading" }, subHeading),
                window.__CTRender("div", { slot: "right-action" }, this._renderPendingCount())),
            window.__CTRender("div", { class: "header-priority-details" },
                window.__CTRender("div", { style: renderUtils_1.buildStyles({ backgroundColor: darker }) },
                    window.__CTRender("div", null,
                        window.__CTRender("label", null, "TIME SENT:"),
                        window.__CTRender("div", { class: "header-priority-detail-value", id: "priority-time-sent-value" }, utils_1.getFriendlyTime(new Date(this.conversation.createdTime))))),
                window.__CTRender("div", { style: renderUtils_1.buildStyles({ backgroundColor: darkest }) },
                    window.__CTRender("div", null,
                        window.__CTRender("label", null, "RAISED BY:"),
                        window.__CTRender("div", { class: "header-priority-detail-value", id: "priority-raised-by-value" }, this._raisedBy))))
        ];
    }
    _renderDescription() {
        if (!this.conversation.description)
            return null;
        return (window.__CTRender("div", { id: "chat-description", class: "chat-description" }, this.conversation.description));
    }
    _renderAttachment() {
        if (this.conversation.attachments && this.conversation.attachments.length === 0) {
            return null;
        }
        return (window.__CTRender("div", { class: "attachment" },
            this.videoAttachmentSrc && (window.__CTRender("div", { class: "video" },
                window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: this.videoAttachmentSrc, type: Models_1.SupportedAttachmentType.VIDEO, conversationId: this.conversation.id }))),
            this.audioAttachmentSrc && (window.__CTRender("div", { class: "audio" },
                window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: this.audioAttachmentSrc, type: Models_1.SupportedAttachmentType.AUDIO, conversationId: this.conversation.id, stream: volume_control_1.VolumeStream.Alarm, volumeToPlayAt: this._config.alertVolume }))),
            this.imgAttachmentSrc && (window.__CTRender("div", { class: "image" },
                window.__CTRender(ctcl_attachment_handler_1.CTCLAttachmentHandler, { uri: this.imgAttachmentSrc, type: Models_1.SupportedAttachmentType.IMAGE, allowOpenImageInFullScreen: this._config.allowOpenInFullScreen, conversationId: this.conversation.id })))));
    }
    _renderFooter() {
        return (window.__CTRender("div", { class: "footer" },
            this._renderReplyTemplate(),
            renderUtils_1.renderIf(this._config.autoAlert && !this.muted && !this.isOnline, window.__CTRender(components_1.CTButton, { type: "none", disabled: this.disableMute, className: "mute", onClick: e => this.mute(), style: renderUtils_1.buildStyles({ backgroundColor: this._config.colorCode }) },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", color: "#FFF", icon: Models_2.Icons.ICOMOON.Mute })))));
    }
    _renderReplyTemplate() {
        let responseOptions;
        if (!this._config.alertResponseOptions || this._config.alertResponseOptions.length === 0) {
            responseOptions = Models_1.defaultAlertResponseOption;
        }
        else {
            responseOptions = this._config.alertResponseOptions[0];
        }
        const sheetButtons = responseOptions.options.map(x => ({
            primaryText: x.label,
            subtitleText: x.shortDescription,
            action: () => this._acknowledgeAndDismiss(x.value),
            disabled: !this.isOnline,
            color: this._config.colorCode
        }));
        return [window.__CTRender(ct_action_sheet_1.CTActionSheet, { buttons: sheetButtons, openSheetButtonText: "Respond", openSheetBackgroundColor: this._config.colorCode })];
    }
    _getConversationStarter() {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.layer.getUserByJid(this.conversation.instigator);
            return user.displayName || `${user.firstName}  ${user.lastName}`;
        });
    }
    _acknowledgeAndDismiss(value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.layer.clearPendingAlert(this.conversation);
            if (this._isExpired(this.conversation)) {
                yield this.emitEvent(Events_1.ChatEvents.PriorityConversationAcknowledged, new PriorityConversationAcknowledgedEventArgs_1.PriorityConversationAcknowledgedEventArgs(this.conversation, this.layer.getPendingAlertCount()));
                const alert = new Models.DefaultAlerts(this).AlertAcknowledge(this.translateI18nItem(I18nKeys.EXPIRED_PRIORITY_CONVERSATION), this.translateI18nItem(I18nKeys.EXPIRED_PRIORITY_CONVERSATION), 1, {
                    okay: () => __awaiter(this, void 0, void 0, function* () {
                        if (this.conversation.isClosed || this._config.shouldOpenConversationAfterResponded === false) {
                            this._resetAndClose();
                        }
                        else {
                            yield this._dismissAndGoToConversation();
                        }
                        yield this.layer.showConversationAlert(null, true);
                    })
                });
                yield this.emitEvent(Events_1.ChatEvents._Request_RaiseAlert, alert);
                return;
            }
            if (this.conversation.isClosed) {
                yield this.emitEvent(Events_1.ChatEvents.PriorityConversationAcknowledged, new PriorityConversationAcknowledgedEventArgs_1.PriorityConversationAcknowledgedEventArgs(this.conversation, this.layer.getPendingAlertCount()));
                const alert = new Models.DefaultAlerts(this).AlertAcknowledge(this.translateI18nItem(I18nKeys.CONVERSATION_IS_CLOSED), this.translateI18nItem(I18nKeys.CONVERSATION_IS_CLOSED), 1, {
                    okay: () => __awaiter(this, void 0, void 0, function* () {
                        yield this._resetAndClose();
                        yield this.layer.showConversationAlert(null, true);
                    })
                });
                yield this.emitEvent(Events_1.ChatEvents._Request_RaiseAlert, alert);
                return;
            }
            yield this.emitEvent(Events_1.ChatEvents.RemotelyStopAudioPlayer);
            yield this.layer.sendConversationAcknowledgement(this.conversation, value || "acknowledge");
            if (this._config.shouldOpenConversationAfterResponded) {
                yield this._dismissAndGoToConversation();
            }
            else {
                yield this._resetAndClose();
            }
            yield this.layer.showConversationAlert(null, true);
        });
    }
    _dismissAndGoToConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.layer.setCurrentConversation(this.conversation, false);
            this._goChatFunction && this._goChatFunction instanceof Function && this._goChatFunction();
            this.conversation = null;
            this._config = null;
            this.imgAttachmentSrc = "";
            this.audioAttachmentSrc = "";
            this.videoAttachmentSrc = "";
            yield this.dismiss();
        });
    }
    _isExpired(conversation) {
        const expiryTime = conversation.createdTime + (conversation.expiryTTL * 1000);
        return new Date().getTime() > expiryTime;
    }
    _resetAndClose() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.emitEvent(Events_1.ChatEvents.PriorityConversationAcknowledged, new PriorityConversationAcknowledgedEventArgs_1.PriorityConversationAcknowledgedEventArgs(this.conversation, this.layer.getPendingAlertCount()));
            this.conversation = null;
            this._config = null;
            this.imgAttachmentSrc = "";
            this.audioAttachmentSrc = "";
            this.videoAttachmentSrc = "";
            this.showing = false;
            yield utils_1.sleep(this.animate ? this._animationDuration : 0);
        });
    }
    dismiss() {
        return __awaiter(this, void 0, void 0, function* () {
            this.showing = false;
            yield utils_1.sleep(this.animate ? this._animationDuration : 0);
        });
    }
    _colorLuminance(hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, "");
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;
        // convert to decimal and change luminosity
        let rgb = "#", c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            const x = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00" + x).substr(x.length);
        }
        return rgb;
    }
    _renderPendingCount() {
        return (renderUtils_1.renderIf(this._config.autoAlert && this.layer.getPendingAlertCount() > 1, window.__CTRender("div", { id: "pending-count", class: "pending-count", style: renderUtils_1.buildStyles({ backgroundColor: this._config.colorCode }) }, this.layer.getPendingAlertCount() - 1)));
    }
    setShowChatFunction(goChatFunction) {
        this._goChatFunction = goChatFunction;
    }
    conversationClosed(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.conversation && this.conversation.roomJid === conversation.roomJid) {
                yield this.emitEvent(Events_1.ChatEvents.PriorityConversationAcknowledged, new PriorityConversationAcknowledgedEventArgs_1.PriorityConversationAcknowledgedEventArgs(this.conversation, this.layer.getPendingAlertCount()));
                this.conversation.isClosed = true;
            }
        });
    }
}
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTCLConversationAlert.prototype, "conversation", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: true })
], CTCLConversationAlert.prototype, "animate", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTCLConversationAlert.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLConversationAlert.prototype, "muted", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLConversationAlert.prototype, "imgAttachmentSrc", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLConversationAlert.prototype, "audioAttachmentSrc", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTCLConversationAlert.prototype, "videoAttachmentSrc", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLConversationAlert.prototype, "disableMute", void 0);
exports.CTCLConversationAlert = CTCLConversationAlert;
CTCLConversationAlert.register();


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const ct_xmpp_client_1 = __webpack_require__(21);
const components_1 = __webpack_require__(3);
const component_1 = __webpack_require__(15);
const Models_1 = __webpack_require__(5);
const models_1 = __webpack_require__(1);
const Base_1 = __webpack_require__(12);
const plugins_1 = __webpack_require__(27);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ADD_IMAGE_ATTACHMENT"] = "Add image attachment"] = "ADD_IMAGE_ATTACHMENT";
    I18nKeys[I18nKeys["NO_IMAGE"] = "No image attached"] = "NO_IMAGE";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLImageAttachment = class CTCLImageAttachment extends Base_1.CTCLComponent {
    constructor() {
        // === Attribute properties === //
        super(...arguments);
        this.fullImagePath = "";
        this.imgPreviewHeight = 122;
        this.imgPreviewWidth = 122;
        this.attachClick = () => __awaiter(this, void 0, void 0, function* () {
            const files = yield ct_xmpp_client_1.CtXmppClient.pickFile({ mimeTypes: this.fileTypes, encrypt: true });
            if (files && files.length) {
                this.isLoading = true;
                const base64 = yield plugins_1.getThumbnail(files[0], this.imgPreviewWidth, this.imgPreviewHeight, 100);
                this.imgSrc = base64;
                this.fullImagePath = files[0];
                this.isLoading = false;
                if (this.callback) {
                    this.callback(this.fullImagePath);
                }
            }
        });
        this.cameraClick = () => __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.layer.captureOrSelectMedia();
                this.isLoading = true;
                data.base64 = yield plugins_1.getThumbnail(data.path, this.imgPreviewWidth, this.imgPreviewHeight, 100);
                this.imgSrc = data.base64;
                this.fullImagePath = data.path;
                this.isLoading = false;
                if (this.callback) {
                    this.callback(this.fullImagePath);
                }
            }
            catch (ex) {
                // TODO: Do something here...?
                // tslint:disable-next-line no-console
                console.error(ex);
            }
        });
        this.removeImg = () => {
            this.imgSrc = "";
            this.fullImagePath = "";
        };
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() { }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("h4", null, this.translateI18nItem(I18nKeys.ADD_IMAGE_ATTACHMENT)),
            window.__CTRender("div", { class: "controls" },
                window.__CTRender("div", { class: `action ${this.imgSrc || this.isLoading ? "disabled" : ""}`, onClick: this.cameraClick },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Attachment })),
                window.__CTRender("div", { class: `action ${this.imgSrc || this.isLoading ? "disabled" : ""}`, onClick: this.attachClick },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Photo })),
                window.__CTRender("div", { class: "placeholder" }, this.isLoading
                    ? window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true })
                    : this.imgSrc
                        ? [
                            window.__CTRender("div", { class: "action", onClick: this.removeImg },
                                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.Cross })),
                            window.__CTRender("img", { src: this.imgSrc, height: this.imgPreviewHeight, width: this.imgPreviewWidth })
                        ]
                        : window.__CTRender("p", null, this.translateI18nItem(I18nKeys.NO_IMAGE))))));
    }
};
__decorate([
    base_1.prop({ type: Array, attribute: true, default: ["image/jpeg", "image/png"] })
], CTCLImageAttachment.prototype, "fileTypes", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTCLImageAttachment.prototype, "callback", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLImageAttachment.prototype, "isLoading", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTCLImageAttachment.prototype, "imgSrc", void 0);
CTCLImageAttachment = __decorate([
    component_1.component({ tag: "ct-cl-image-attachment", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host div.container{display:flex;padding:10px;flex-direction:column}:host div.container h4{margin-top:0;font-weight:normal;text-transform:uppercase;font-size:0.8em;color:var(--tertiary-placeholder-color, #212121)}:host div.container div.controls{display:flex}:host div.container div.controls div.action{display:flex;justify-content:center;align-items:center;flex:none;width:36px;height:36px;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border-radius:50%;cursor:pointer;margin-right:10px;transition:0.5s all ease-in}:host div.container div.controls div.action.disabled{background:var(--subtle-font-color, #828688);cursor:default}:host div.container div.controls div.placeholder{display:flex;flex:1}:host div.container div.controls div.placeholder div.action{margin-left:auto}:host div.container div.controls div.placeholder p{margin:auto 0;align-items:center;color:var(--subtle-font-color, #828688)}
    `], i18nKeys: I18nKeys })
], CTCLImageAttachment);
exports.CTCLImageAttachment = CTCLImageAttachment;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const ct_xmpp_client_1 = __webpack_require__(21);
const components_1 = __webpack_require__(3);
const component_1 = __webpack_require__(15);
const Models_1 = __webpack_require__(5);
const models_1 = __webpack_require__(1);
const Events_1 = __webpack_require__(4);
const ctcl_video_recorder_player_1 = __webpack_require__(51);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ADD_VIDEO_ATTACHMENT"] = "Add Video Attachment"] = "ADD_VIDEO_ATTACHMENT";
    I18nKeys[I18nKeys["NO_VIDEO_ATTACHED"] = "No video attached"] = "NO_VIDEO_ATTACHED";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
let CTCLVideoAttachment = class CTCLVideoAttachment extends base_1.CTLayerComponent {
    constructor() {
        // === Attribute properties === //
        super(...arguments);
        this._loadFromSource = false;
        this.attachClick = () => __awaiter(this, void 0, void 0, function* () {
            const files = yield ct_xmpp_client_1.CtXmppClient.pickFile({ mimeTypes: this.fileTypes });
            if (files && files.length) {
                this._loadFromSource = true;
                this.videoSrc = files[0];
                if (this.callback) {
                    this.callback(this.videoSrc);
                }
            }
        });
        this._recordClick = () => __awaiter(this, void 0, void 0, function* () {
            this._loadFromSource = false;
            this.videoSrc = "";
            this.recordVideo = !this.recordVideo;
        });
        this._onRecordFinished = (filepath) => {
            if (this.callback)
                this.callback(filepath);
        };
        this._onRecordingDeleted = () => {
            this.videoSrc = "";
            this._loadFromSource = false;
            if (this.callback)
                this.callback(this.videoSrc);
        };
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.addListener(Events_1.ChatEvents.AudioRecordingStarted, () => this.videoRecording = true);
        this.addListener(Events_1.ChatEvents.AudioRecordingStopped, () => this.videoRecording = false);
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "container" },
            window.__CTRender("h4", null, this.translateI18nItem(I18nKeys.ADD_VIDEO_ATTACHMENT)),
            window.__CTRender("div", { class: "controls" },
                window.__CTRender("div", { class: `action ${this.recordVideo || this.videoSrc ? "disabled" : ""}`, onClick: this.recordVideo || this.videoSrc ? null : this.attachClick },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.PickVideo })),
                window.__CTRender("div", { class: `action ${this.videoSrc || this.videoRecording ? "disabled" : ""}`, onClick: this.videoSrc || this.videoRecording ? null : this._recordClick },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.RecordVideo })),
                window.__CTRender("div", { class: "placeholder" }, this.isLoading
                    ? window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true })
                    : this.recordVideo || this.videoSrc
                        ? window.__CTRender(ctcl_video_recorder_player_1.CTCLVideoRecorderPlayer, { onRecordingFinished: this._onRecordFinished, onVideoRemoved: this._onRecordingDeleted })
                        : window.__CTRender("p", null, this.translateI18nItem(I18nKeys.NO_VIDEO_ATTACHED))))));
    }
};
__decorate([
    base_1.prop({ type: Array, attribute: true, default: ["video/mp4", "video/webm"] })
], CTCLVideoAttachment.prototype, "fileTypes", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTCLVideoAttachment.prototype, "callback", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLVideoAttachment.prototype, "isLoading", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTCLVideoAttachment.prototype, "videoSrc", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLVideoAttachment.prototype, "recordVideo", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLVideoAttachment.prototype, "videoRecording", void 0);
CTCLVideoAttachment = __decorate([
    component_1.component({ tag: "ct-cl-video-attachment", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host div.container{display:flex;padding:10px;flex-direction:column}:host div.container h4{margin-top:0;font-weight:normal;text-transform:uppercase;font-size:0.8em;color:var(--tertiary-placeholder-color, #212121)}:host div.container div.controls{display:flex}:host div.container div.controls div.action{display:flex;justify-content:center;align-items:center;flex:none;width:36px;height:36px;background:var(--primary-color, #22b1c8);color:var(--primary-font-color, #fff);border-radius:50%;cursor:pointer;margin-right:10px;transition:0.5s all ease-in}:host div.container div.controls div.action.disabled{background:var(--subtle-font-color, #828688);cursor:default}:host div.container div.controls div.placeholder{display:flex;flex:1}:host div.container div.controls div.placeholder ctcl-audio-player{flex:0}:host div.container div.controls div.placeholder div.action{margin-left:auto}:host div.container div.controls div.placeholder p{margin:auto 0;align-items:center;color:var(--subtle-font-color, #828688)}
    `], i18nKeys: I18nKeys })
], CTCLVideoAttachment);
exports.CTCLVideoAttachment = CTCLVideoAttachment;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultReplyTemplate = {
    id: "_default",
    name: "Acknowledge",
    options: [
        {
            name: "Acknowledge",
            type: "button",
            label: "Acknowledge",
            value: "Acknowledge"
        }
    ]
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(109));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class AttachmentDownloadComplete extends events_1.BaseEventArgs {
    constructor(filepath, conversationId, type) {
        super();
        this.filepath = filepath;
        this.type = type;
        this.conversationId = conversationId;
    }
}
exports.AttachmentDownloadComplete = AttachmentDownloadComplete;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class AudioAttachmentDownloadComplete extends events_1.BaseEventArgs {
    constructor(filepath, conversation) {
        super();
        this.filepath = filepath;
        this.conversation = conversation;
    }
}
exports.AudioAttachmentDownloadComplete = AudioAttachmentDownloadComplete;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const ChatEntryEventArgs_1 = __webpack_require__(53);
class ChatNotificationEventArgs extends ChatEntryEventArgs_1.ChatEntryEventArgs {
    constructor(chatEntry, conversationTitle, messagePreview, isForCurrentConversation) {
        super(chatEntry);
        this.conversationTitle = conversationTitle;
        this.messagePreview = messagePreview;
        this.isForCurrentConversation = isForCurrentConversation;
    }
}
exports.ChatNotificationEventArgs = ChatNotificationEventArgs;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const Events_1 = __webpack_require__(4);
class ConversationParticiantRoleEventArgs extends Events_1.ConversationEventArgs {
    constructor(conversation, participant, newRole) {
        super(conversation);
        this.participant = participant;
        this.newRole = newRole;
    }
}
exports.ConversationParticiantRoleEventArgs = ConversationParticiantRoleEventArgs;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const Events_1 = __webpack_require__(4);
class ConversationParticiantsEventArgs extends Events_1.ConversationEventArgs {
    constructor(conversation, participants) {
        super(conversation);
        this.participants = participants;
    }
}
exports.ConversationParticiantsEventArgs = ConversationParticiantsEventArgs;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const ConversationEventArgs_1 = __webpack_require__(54);
class ForceQuitConversationEventArgs extends ConversationEventArgs_1.ConversationEventArgs {
    constructor(conversation, instigator, reason) {
        super(conversation);
        this.instigator = instigator;
        this.reason = reason;
    }
}
exports.ForceQuitConversationEventArgs = ForceQuitConversationEventArgs;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class PriorityConversationNotificationEventArgs extends events_1.BaseEventArgs {
    constructor(conversation, alert, autoAlert, mustAcknowledge) {
        super();
        this.conversation = conversation;
        this.alert = alert;
        this.autoAlert = autoAlert;
        this.mustAcknowledge = mustAcknowledge;
    }
}
exports.PriorityConversationNotificationEventArgs = PriorityConversationNotificationEventArgs;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(32);
class ChatMessageType extends handlers_1.BaseMessageType {
}
// === IQ request messages === //
ChatMessageType.FetchConversations = "fetch-conversations";
ChatMessageType.CreateConversation = "create-conversation";
ChatMessageType.UpdateConversation = "update-conversation";
ChatMessageType.AddParticipants = "add-participants";
ChatMessageType.RemoveParticipants = "remove-participants";
ChatMessageType.ChangeParticipantRole = "change-participant-role";
ChatMessageType.LeaveConversation = "leave-conversation";
ChatMessageType.EndConversation = "end-conversation";
ChatMessageType.ReceivedConversation = "received-conversation";
ChatMessageType.AcknowledgeConversation = "acknowledge-conversation";
ChatMessageType.HideDirectConversation = "hide-before";
// === XMPP messages (room) === //
ChatMessageType.ConversationStarted = "conversationstarted";
ChatMessageType.ConversationUpdated = "conversationupdated";
ChatMessageType.ParticipantAdded = "participantadded";
ChatMessageType.ParticipantRemoved = "participantremoved";
ChatMessageType.ParticipantRoleChanged = "participantrolechanged";
ChatMessageType.ParticipantLeft = "participantleft";
ChatMessageType.ConversationEnded = "conversationended";
ChatMessageType.ParticipantReceived = "participantreceipt";
ChatMessageType.ParticipantAcknowledged = "participantacked";
// === XMPP messages (user) === //
ChatMessageType.User_ConversationStarted = "user_conversationstarted";
ChatMessageType.User_ConversationUpdated = "user_conversationupdated";
ChatMessageType.User_Added = "user_added";
ChatMessageType.User_Removed = "user_removed";
ChatMessageType.User_RoleChanged = "user_rolechanged";
ChatMessageType.User_Left = "user_left";
ChatMessageType.User_ConversationEnded = "user_conversationended";
ChatMessageType.User_DeleteDirectConversation = "user_hid_conv";
exports.ChatMessageType = ChatMessageType;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
const BaseChatHandler_1 = __webpack_require__(6);
const Keys_1 = __webpack_require__(20);
class CommsConnectionHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.eventType = [
            events_1.BaseEvents.LoginResult,
            events_1.BaseEvents._Request_Logout
        ];
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === events_1.BaseEvents.LoginResult) {
                const data = eventData;
                if (!data.success) {
                    const title = this.layer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.LOGIN_ERROR_TITLE));
                    const message = data.errorMessage || this.layer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.LOGIN_ERROR_GENERIC));
                    this.layer.error(title, message);
                }
            }
            if (eventType === events_1.BaseEvents._Request_Logout) {
                try {
                    yield this.layer.logout(true);
                }
                catch (ex) {
                    const title = this.layer.translateI18nItem(Keys_1.CommonMetadata.getI18nItem(Keys_1.CommonI18nKeys.LOGOUT_ERROR_TITLE));
                    this.layer.error(title, ex);
                }
            }
        });
    }
}
exports.CommsConnectionHandler = CommsConnectionHandler;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Events_1 = __webpack_require__(4);
class AttachmentDownloadedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.eventType = [
            Events_1.ChatEvents.AttachmentDownloadComplete
        ];
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.ChatEvents.AttachmentDownloadComplete) {
                const data = eventData;
                const conversation = yield this.layer.getConversationById(data.conversationId);
                if (conversation) {
                    const attachment = conversation.attachments.find(x => x.type === data.type);
                    if (attachment) {
                        attachment.local = data.filepath;
                        yield this.layer.updateConversation(conversation);
                    }
                }
            }
        });
    }
}
exports.AttachmentDownloadedHandler = AttachmentDownloadedHandler;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Events_1 = __webpack_require__(4);
class AutoReconnectedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.eventType = [
            Events_1.ChatEvents.AutoReconnected
        ];
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.ChatEvents.AutoReconnected) {
                if (window.cti && window.cti.store.state.currentPage === "Login") {
                    this.layer.comms.clearPostLoginTimeout();
                    window.cti.utils.callAction("go-to-page", { name: "Conversations" });
                }
            }
        });
    }
}
exports.AutoReconnectedHandler = AutoReconnectedHandler;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
const BaseChatHandler_1 = __webpack_require__(6);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const UserLookup_1 = __webpack_require__(26);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ChatEntryEventHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.eventType = [
            Events_1.ChatEvents.ChatEntryReceived
        ];
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.ChatEvents.ChatEntryReceived) {
                const data = eventData;
                const chatEntry = data.chatEntry;
                if (!chatEntry)
                    return;
                const currentUserJid = this.layer.getCurrentUserJid();
                const chatEntryConverastion = yield this.layer.getConversationByRoomJid(chatEntry.to);
                const currentConversation = yield this.layer.getCurrentConversation();
                const isForCurrentConversation = currentConversation && currentConversation.id === chatEntryConverastion.id || false;
                if (this._shouldRaiseNotification(chatEntry, currentUserJid, chatEntryConverastion, isForCurrentConversation)) {
                    const userLookup = new UserLookup_1.UserLookup(this.layer);
                    yield userLookup.populate([chatEntryConverastion]);
                    const title = ChatUtils_1.getConversationTitle(chatEntryConverastion, userLookup, currentUserJid, "");
                    const preview = this._getMessagePreview(chatEntry, userLookup, currentUserJid);
                    this.layer.emit(Events_1.ChatEvents.ChatNotification, new Events_1.ChatNotificationEventArgs(data.chatEntry, title, preview, isForCurrentConversation));
                }
            }
        });
    }
    // === Private functions === //
    _shouldRaiseNotification(chatEntry, currentUserJid, chatEntryConversation, isForCurrentConversation) {
        if (chatEntry.type === models_1.ChatEntryType.Chat && chatEntry.mine)
            return false;
        if (chatEntry.type === models_1.ChatEntryType.Meta && utils_1.jidsMatch(chatEntry.instigator, currentUserJid))
            return false;
        if (chatEntry.date <= (chatEntryConversation.hideBefore || chatEntryConversation.lastHideBefore))
            return false;
        // Don't play notifications if an alert window is currently being displayed or has received chat messages before being acknowledged.
        if (chatEntryConversation.instigator !== this.layer.getCurrentUserJid() && (chatEntryConversation.acknowledgements && !chatEntryConversation.acknowledgements.find(x => x.jid === this.layer.getCurrentUserJid())))
            return false;
        if (chatEntryConversation.instigator !== this.layer.getCurrentUserJid() && (chatEntryConversation.acknowledgements && chatEntry.date <= chatEntryConversation.acknowledgements.find(x => x.jid === this.layer.getCurrentUserJid()).ts))
            return false;
        const priority = this.layer.getConfiguredPriorityById(chatEntryConversation.priority);
        if (priority && priority.alert && chatEntryConversation.acknowledgements && !chatEntryConversation.acknowledgements.find(x => x.jid === this.layer.getCurrentUserJid()))
            return false;
        if (priority && priority.alert && chatEntryConversation.acknowledgements && chatEntry.date <= chatEntryConversation.acknowledgements.find(x => x.jid === this.layer.getCurrentUserJid()).ts)
            return false;
        if (isForCurrentConversation && (chatEntry.type !== models_1.ChatEntryType.Meta && chatEntry.action === Models_1.ChatMetaActivityType.ACK.toString()))
            return true;
        if (chatEntry.type === models_1.ChatEntryType.Chat)
            return true;
        if (chatEntry.type === models_1.ChatEntryType.Meta) {
            const chatMetaActivity = chatEntry;
            // don't raise a notification for direct conversation start messages as there will be an immediate chat message which will raise the notification instead
            if (chatMetaActivity.action === Models_1.ChatMetaActivityType.START.toString())
                return chatEntryConversation.type !== Models_1.ConversationType.Direct;
            // only raise a notifiction for ADD/REMOVE/CHANGEROLE actions which affect the current user
            const actionsToReportForUser = [
                Models_1.ChatMetaActivityType.ADD.toString(),
                Models_1.ChatMetaActivityType.REMOVE.toString(),
                Models_1.ChatMetaActivityType.CHANGEROLE.toString()
            ];
            if (actionsToReportForUser.includes(chatMetaActivity.action) && chatMetaActivity.subject === currentUserJid)
                return true;
        }
        return false;
    }
    _getMessagePreview(chatEntry, userLookup, currentUserJid) {
        if (chatEntry.type === models_1.ChatEntryType.Chat) {
            const chatMessage = chatEntry;
            return ChatUtils_1.getChatMessageTextForPreview(chatMessage, this.layer);
        }
        if (chatEntry.type === models_1.ChatEntryType.Meta) {
            const chatMetaActivity = chatEntry;
            return ChatUtils_1.getChatMetaActivitySummaryText(chatMetaActivity, userLookup, currentUserJid, this.layer, false);
        }
    }
}
exports.ChatEntryEventHandler = ChatEntryEventHandler;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Events_1 = __webpack_require__(4);
const ConversationConfigReader_1 = __webpack_require__(14);
const utils_1 = __webpack_require__(2);
const fixedAlert = "pager_responder_alert.m4a";
const win = window;
class RaiseDeviceNotificationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.eventType = [
            Events_1.ChatEvents.PriorityConversationNotification,
            Events_1.ChatEvents.PriorityConversationAcknowledged,
            Events_1.ChatEvents.MuteAlertToPlayOtherAudio,
            Events_1.ChatEvents.ResumeAlertAfterPlayingAudio,
            Events_1.ChatEvents.AudioAttachmentDownloadComplete,
            Events_1.ChatEvents.Mute
        ];
        this.currentlyAlerting = false;
        this.isMuted = false;
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.ChatEvents.PriorityConversationNotification) {
                if (!this.currentlyAlerting) {
                    this.currentlyAlerting = true;
                    const data = eventData;
                    if (win.cti) {
                        if (!win.cti.store.state.foreground &&
                            (win.PushNotification &&
                                win.PushNotification.bringToFront)) {
                            win.PushNotification.bringToFront();
                        }
                    }
                    if (win.cti) {
                        win.cti.store.variables.currently_alerting = true;
                    }
                    this.currentConversation = data.conversation;
                    this._playAlertSound(data.conversation);
                }
            }
            if (eventType === Events_1.ChatEvents.PriorityConversationAcknowledged) {
                this.isMuted = false;
                const data = eventData;
                if (data.instigator &&
                    data.instigator !== this.layer.getCurrentUserJid()) {
                    // Bomb out early if this isn't the current user acknowledging
                    return;
                }
                this.currentConversation = null;
                this.layer.emit(Events_1.ChatEvents.RemotelyStopAudioPlayer);
                if (data.pendingCount === 0) {
                    this.currentlyAlerting = false;
                    win.simpleAudioPlayer.stop(true);
                    win.simpleAudioPlayer.release();
                    win.vibrationController.stop();
                }
                else {
                    const nextConversation = this.layer.getNewestPendingAlert();
                    // this.currentConversation = nextConversation;
                    win.simpleAudioPlayer.release();
                    this._playAlertSound(nextConversation);
                }
            }
            if (eventType === Events_1.ChatEvents.MuteAlertToPlayOtherAudio ||
                eventType === Events_1.ChatEvents.Mute) {
                if (eventType === Events_1.ChatEvents.Mute) {
                    if (this.isMuted) {
                        win.simpleAudioPlayer.play();
                        this.isMuted = false;
                        return;
                    }
                    else {
                        this.isMuted = true;
                    }
                }
                if (this.layer.getPendingAlertCount() > 0) {
                    win.simpleAudioPlayer.stop(true);
                    win.vibrationController.stop();
                }
            }
            if (eventType === Events_1.ChatEvents.ResumeAlertAfterPlayingAudio) {
                this.isMuted = false;
                if (this.layer.getPendingAlertCount() > 0) {
                    win.simpleAudioPlayer.play();
                }
            }
            if (eventType === Events_1.ChatEvents.AudioAttachmentDownloadComplete) {
                const data = eventData;
                const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, this.currentConversation);
                if (config.automaticallyPlayAudioOnDownload) {
                    win.simpleAudioPlayer.stop(true);
                    setTimeout(() => this.layer.emit(Events_1.ChatEvents.RemotelyStartAudioPlayer), 1500);
                }
            }
        });
    }
    _playAlertSound(conversation) {
        const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, conversation);
        if (config.alert) {
            win.simpleAudioPlayer.setAudio(config.alertSoundFilename, config.alertSoundLoops, config.alertVolume, utils_1.enumFromString(config.alertAudioStream));
            win.simpleAudioPlayer.play();
            if (config.vibrate) {
                win.vibrationController.vibrate(config.vibrateDuration, 0, config.forceVibrate);
            }
        }
    }
}
exports.RaiseDeviceNotificationHandler = RaiseDeviceNotificationHandler;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class AcknowledgeConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.AcknowledgeConversation;
    }
    createIq(data) {
        return iqUtils_1.createIq("ack", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id,
            value: data.value
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_ACKNOWLEDGING_CONVERSATION));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.AcknowledgeConversationHandler = AcknowledgeConversationHandler;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class AddParticipantsHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.AddParticipants;
    }
    createIq(data) {
        return iqUtils_1.createIq("add", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id,
            participants: {
                item: data.participants.map(x => iqUtils_1.createIqNode({ jid: x.jid, affiliation: x.role.toString() }))
            }
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_ADDING_PARTICIPANTS_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.AddParticipantsHandler = AddParticipantsHandler;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class ChangeParticipantRoleHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ChangeParticipantRole;
    }
    createIq(data) {
        return iqUtils_1.createIq("changerole", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id,
            participant: iqUtils_1.createIqNode({ jid: data.participant.jid, affiliation: data.newRole.toString() })
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_CHANGING_PARTICIPANT_ROLE_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.ChangeParticipantRoleHandler = ChangeParticipantRoleHandler;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class CreateConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.CreateConversation;
    }
    createIq(data) {
        const request = iqUtils_1.createIq("create", this.layer.config.xmpp.iq.namespace, {
            type: data.type.toString(),
            participants: {
                item: data.participants.map(x => iqUtils_1.createIqNode({ jid: x.jid, affiliation: x.role.toString() }))
            }
        });
        if (data.config.behaviour.namedSettings) {
            request.create.title = data.subject || "";
            request.create.description = data.description || "";
        }
        if (data.priority) {
            request.create.priority = data.priority;
        }
        if (data.expiry_ttl) {
            request.create.expiry_ttl = `${data.expiry_ttl}`;
        }
        if (data.activity_ttl) {
            request.create.activity_ttl = `${data.activity_ttl}`;
        }
        request.create.reply_template = JSON.stringify(data.config);
        if (data.attachments && data.attachments.length) {
            request.create.attachments = {
                attachment: data.attachments.map(x => JSON.stringify(x))
            };
        }
        // if (isPagerEnabled(this.layer) && data.pageOptions) {
        //     request.create.reply_template = JSON.stringify(data.pageOptions.replyTemplate);
        //     request.create.disallow_reply = (!data.pageOptions.enableChat).toString();
        //     if (data.attachments && data.attachments.length) {
        //         request.create.attachments = {
        //             attachment: data.attachments.map(x => JSON.stringify(x))
        //         };
        //     }
        // }
        return request;
    }
    handleIqResponse(data, response) {
        return __awaiter(this, void 0, void 0, function* () {
            if ("created" in response) {
                const id = response.created && response.created.$attributes.id || null;
                return Object.assign({}, response, { data: {
                        newConversationId: id
                    } });
            }
            else if ("exists" in response) {
                return Object.assign({}, response, { data: {
                        exists: true
                    } });
            }
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_CREATING_CONVERSATION_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.CreateConversationHandler = CreateConversationHandler;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class DeleteDirectConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.HideDirectConversation;
    }
    createIq(data) {
        return iqUtils_1.createIq("hide_before", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id,
            timestamp: data.timestamp.toString()
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_DELETING_DIRECT_CONVERSATION));
            const errorCode = error.message.includes("connected") ? "E_NO_CONNECTION_DELETING_DIRECT" : error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.DeleteDirectConversationHandler = DeleteDirectConversationHandler;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class EndConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.EndConversation;
    }
    createIq(data) {
        return iqUtils_1.createIq("end", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_ENDING_CONVERSATION_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.EndConversationHandler = EndConversationHandler;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
const Logger_1 = __webpack_require__(17);
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const iqUtils_1 = __webpack_require__(16);
const utils_1 = __webpack_require__(2);
const ChatUtils_1 = __webpack_require__(10);
const Keys_1 = __webpack_require__(13);
const ConversationConfigReader_1 = __webpack_require__(14);
class FetchConversationsHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.FetchConversations;
    }
    createIq(data) {
        const operationName = "fetch";
        const request = iqUtils_1.createIq(operationName, this.layer.config.xmpp.iq.namespace, {
            max: data.max.toString()
        });
        if (data.timestamp)
            request[operationName].timestamp = data.timestamp.toString();
        return request;
    }
    handleIqResponse(data, response) {
        return __awaiter(this, void 0, void 0, function* () {
            this.layer.logger.log(Logger_1.LoggerTypes.Mam, `%c QUERYING SERVER FOR CONVERSATION UPDATES FOR USER: %c${this.layer.comms.username} (since ${data.timestamp})`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            const fetchResponse = JSON.parse(response.data.fetch);
            const conversations = (fetchResponse.conversations || []).map(x => this._convertToConversation(x));
            if (conversations.length > 0) {
                this.layer.logger.log(Logger_1.LoggerTypes.Mam, `%c ${conversations.length} CONVERSATION(S) UPDATED`, "color: #669; font-weight: bold;", fetchResponse.conversations);
                const stanzas = (fetchResponse.conversations || []).reduce((allMessages, conversation) => {
                    allMessages.push(...conversation.messages.map(message => message.xml));
                    return allMessages;
                }, []);
                // Take the XML stanzas under each conversation in the conversation fetch and convert them into actuall XMPP message objects via the XMPP clients processXmlStanzaStringsFromMam method
                const messages = yield this.layer.processXmlStanzaStringsFromMam(stanzas, false);
                const chatEntries = [];
                for (const message of messages) {
                    const entry = yield ChatUtils_1.convertToChatEntry(message, this.layer);
                    if (entry !== null) {
                        chatEntries.push(entry);
                    }
                }
                // const chatEntries: ChatEntry[] = await Promise.all(messages.map(async x => await convertToChatEntry(x, this.layer)));
                chatEntries.sort((a, b) => b.date - a.date);
                this.layer.logger.log(Logger_1.LoggerTypes.Mam, `%c ${chatEntries.length} CHAT ENTRIES(S) RECEIVED`, "color: #669; font-weight: bold;", chatEntries);
                // Calculate the most recent chat entry for each conversation and set it as the preview entry for the conversation
                const conversationChatEntryMappings = new WeakMap();
                chatEntries.forEach(x => {
                    if (!x.to)
                        return;
                    const conversation = conversations.find(y => y.roomJid === x.to);
                    if (!conversation)
                        return;
                    const entries = conversationChatEntryMappings.get(conversation) || [];
                    entries.push(x);
                    conversationChatEntryMappings.set(conversation, entries);
                });
                // Flag to determine if a notification is required
                let requiresNotification = false;
                // Get the current user to detect if it has already been acked
                const currentUserJid = this.layer.getCurrentUserJid();
                // Use a for loop so we can use await for the priorityAlert method
                for (const idx in conversations) {
                    // Grab the individual conversation
                    const x = conversations[idx];
                    const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, x);
                    // Get the entries for the conversation
                    const entries = conversationChatEntryMappings.get(x);
                    if (entries && entries.length > 0) {
                        // Check if we're allowed to see other responses as a preview
                        // If not, we create a hard coded started at placeholder
                        const me = x.participants.find(p => p.jid === this.layer.getCurrentUserJid() && p.role === models_1.ChatRole.Participant);
                        if ((config.alert && config.participantAlertResponsesVisible === false) && me) {
                            x.preview = this._createBackupStartPreview(x);
                        }
                        else {
                            x.preview = entries[0];
                        }
                        // Mark the conversation as unread if needed
                        if (data.timestamp)
                            x.hasUnread = true;
                    }
                    else {
                        x.preview = this._createBackupStartPreview(x);
                    }
                    // When doing a conversation fetch we also need to ensure any alerts get displayed
                    // So for each conversation display an alert if needed
                    if (config.alert) {
                        // Ensure that the current user hasn't already acknowledged the alert
                        if (!x.acknowledgements || !x.acknowledgements.find(a => a.jid === currentUserJid)) {
                            const displayNotification = yield this.layer.priorityAlert(x);
                            if (!requiresNotification) {
                                requiresNotification = (displayNotification === true);
                            }
                        }
                    }
                    else {
                        // By default display a notification
                        requiresNotification = true;
                    }
                }
                // If the flag is set then ensure a notification gets displayed
                if (requiresNotification) {
                    const message = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.YOU_HAVE_NEW_NOTIFICATIONS));
                    this.layer.emit(Events_1.ChatEvents.ChatNotification, new Events_1.ChatNotificationEventArgs(null, "", message, false));
                }
            }
            else {
                this.layer.logger.log(Logger_1.LoggerTypes.Mam, `%c NO NEW UPDATES`, "color: #669; font-weight: bold;");
            }
            return Object.assign({}, response, { data: {
                    conversations,
                    lastIdentifier: parseInt(fetchResponse.timestamp, 10)
                } });
        });
    }
    // === Private functions === //
    _convertToConversation(conversationData) {
        const id = conversationData.name;
        const type = utils_1.enumFromString(conversationData.type);
        const roomJid = conversationData.jid;
        const participants = conversationData.participants;
        const subject = type === Models_1.ConversationType.Named ? conversationData.title : null;
        const description = type === Models_1.ConversationType.Named ? conversationData.desc || "" : null;
        const started = conversationData.started;
        const recs = conversationData.receipts;
        const acks = conversationData.responses;
        const instigator = conversationData.started_by;
        const hideBefore = parseInt(conversationData.hide_before) || 0;
        const replyTemplate = conversationData.reply_template;
        const attachments = conversationData.attachments;
        const priority = conversationData.priority ? this.layer.getConfiguredPriorityById(conversationData.priority) : null;
        const expiryTTL = conversationData.expiry_ttl;
        const activityTTL = conversationData.activity_ttl;
        return ChatUtils_1.createConversation(id, type, roomJid, participants, subject, description, started, priority ? priority.id : null, expiryTTL, activityTTL, recs, acks, instigator, hideBefore, replyTemplate, attachments);
    }
    _createBackupStartPreview(conversation) {
        return {
            id: "fake",
            action: "start",
            type: models_1.ChatEntryType.Meta,
            instigator: conversation.instigator,
            date: conversation.createdTime,
            to: "fake"
        };
    }
}
exports.FetchConversationsHandler = FetchConversationsHandler;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class LeaveConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.LeaveConversation;
    }
    createIq(data) {
        return iqUtils_1.createIq("leave", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_LEAVING_CONVERSATION_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.LeaveConversationHandler = LeaveConversationHandler;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class ReceivedConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ReceivedConversation;
    }
    createIq(data) {
        return iqUtils_1.createIq("rec", this.layer.config.xmpp.iq.namespace, {
            roomid: data.id
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_RECEIVING_CONVERSATION));
            this.layer.logger.error("Could not mark conversation as received:", error);
            return null;
        });
    }
}
exports.ReceivedConversationHandler = ReceivedConversationHandler;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class RemoveParticipantsHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.RemoveParticipants;
    }
    createIq(data) {
        return iqUtils_1.createIq("remove", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id,
            participants: {
                item: data.participants.map(x => iqUtils_1.createIqNode({ jid: x.jid }))
            }
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_REMOVING_PARTICIPANTS_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.RemoveParticipantsHandler = RemoveParticipantsHandler;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const iqUtils_1 = __webpack_require__(16);
class UpdateConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.UpdateConversation;
    }
    createIq(data) {
        return iqUtils_1.createIq("update", this.layer.config.xmpp.iq.namespace, {
            roomid: data.conversation.id,
            title: data.newSubject,
            description: data.newDescription
        });
    }
    handleIqErrorResponse(data, error) {
        return __awaiter(this, void 0, void 0, function* () {
            const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ERROR_UPDATING_CONVERSATION_TITLE));
            const errorCode = error.message;
            const message = Errors_1.getErrorMessage(errorCode, this.layer);
            this.layer.error(title, message);
            return null;
        });
    }
}
exports.UpdateConversationHandler = UpdateConversationHandler;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ct_xmpp_client_1 = __webpack_require__(21);
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ChatMessageHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.XmppChat;
        this.DEBOUNCE_PURGE_NAME = "purge";
        this.DEBOUNCE_DURATION = 2000;
        this._debouncers = {};
        // === Private functions === //
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message) || this.isInjectedMessage(message))
                return;
            const chatEntry = yield this.convert(message);
            const conversation = yield this.layer.getConversationByRoomJid(chatEntry.to);
            if (!conversation || conversation.isClosed)
                return null;
            if (chatEntry.date <= (conversation.hideBefore || conversation.lastHideBefore))
                return null;
            const updateOptions = {};
            if (chatEntry.date > (conversation.hideBefore || conversation.lastHideBefore)) {
                updateOptions.preview = chatEntry;
            }
            yield this.layer.updateConversation(conversation, { preview: chatEntry });
            // Purge the conversation that the new chat entry relates too. To handle messages coming through in quick succession debounce this.
            this.debounce(this.DEBOUNCE_PURGE_NAME, () => this.layer.purgeConversation(conversation), this.DEBOUNCE_DURATION);
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(chatEntry));
        });
    }
    debounce(name, action, duration = 100) {
        clearTimeout(this._debouncers[name]);
        this._debouncers[name] = setTimeout(() => {
            action();
            delete this._debouncers[name];
        }, duration);
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const chatEntry = yield this.convert(message);
            const conversation = yield this.layer.getConversationByRoomJid(chatEntry.to);
            if (!conversation || conversation.isClosed)
                return null;
            if (chatEntry.date <= (conversation.hideBefore || conversation.lastHideBefore))
                return null;
            this.layer.emit(Events_1.ChatEvents.ChatEntryUpdated, new Events_1.ChatEntryEventArgs(chatEntry));
        });
    }
    convert(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const date = message.ts;
            const currentUserJid = this.layer.getCurrentUserJid();
            const fromJid = this.isInjectedMessage(message)
                ? message.sender_id
                : message.mine
                    ? currentUserJid
                    : `${message.sender_resource}@${this.layer.config.xmpp.user.domain}`;
            const toJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            const body = (typeof (message.body) === "string")
                ? message.body
                : "";
            const attachments = (message.attachments instanceof Array)
                ? message.attachments.map(x => ({
                    remote: x.get,
                    local: x.path
                }))
                : [];
            const receivedBy = [];
            const readBy = [];
            (message.state && message.state.markers || []).forEach(marker => {
                const chatMessageMarker = {
                    jid: `${marker.sender_resource}@${this.layer.config.xmpp.user.domain}`,
                    date: marker.ts
                };
                if (marker.type === ct_xmpp_client_1.CtXmppClient.MARKER_TYPES.RECEIVED) {
                    receivedBy.push(chatMessageMarker);
                }
                if (marker.type === ct_xmpp_client_1.CtXmppClient.MARKER_TYPES.READ) {
                    readBy.push(chatMessageMarker);
                }
            });
            return ChatUtils_1.createChatMessage(id, date, currentUserJid, fromJid, toJid, body, attachments, receivedBy, readBy, message.placeholder);
        });
    }
}
exports.ChatMessageHandler = ChatMessageHandler;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
class ConversationEndedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ConversationEnded;
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // do nothing; this message type is for auditing in the MAM
        });
    }
}
exports.ConversationEndedHandler = ConversationEndedHandler;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
const ConversationConfigReader_1 = __webpack_require__(14);
class ConversationStartedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ConversationStarted;
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            let conversation = yield this.layer.getConversationById(data.id);
            if (conversation !== null)
                return; // we already know about this conversation - we cannot start it again
            const type = utils_1.enumFromString(data.type);
            conversation = ChatUtils_1.createConversation(data.id, type, data.roomJid, data.participants, data.title, data.description, data.date, data.priority, data.expiry_ttl, data.activity_ttl, [], [], data.instigator, undefined, data.reply_template, data.attachments);
            const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, conversation);
            const metaActivity = yield this.convert(message, data);
            yield this.layer.addConversation(conversation, metaActivity);
            let alertSound = true;
            if (config.alert) {
                alertSound = yield this.layer.priorityAlert(conversation);
            }
            if (alertSound) {
                this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
            }
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.START, data.instigator);
        });
    }
}
exports.ConversationStartedHandler = ConversationStartedHandler;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ConversationUpdatedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ConversationUpdated;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            conversation.subject = data.title;
            conversation.description = data.description;
            const metaActivity = yield this.convert(message, data);
            yield this.layer.updateConversation(conversation, { preview: metaActivity });
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.UPDATE, data.instigator, null, data.title);
        });
    }
}
exports.ConversationUpdatedHandler = ConversationUpdatedHandler;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
const PriorityConversationAcknowledgedEventArgs_1 = __webpack_require__(55);
const ConversationConfigReader_1 = __webpack_require__(14);
class ParticipantAcknowledgedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ParticipantAcknowledged;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, conversation);
            let alreadyAcknowledged = false;
            if (!conversation.acknowledgements) {
                conversation.acknowledgements = [];
            }
            // Check if our own acknowledgement is already there
            if (!conversation.acknowledgements.find(x => x.jid === this.layer.getCurrentUserJid())) {
                conversation.acknowledgements.push({
                    jid: data.instigator,
                    ts: parseInt(data.date),
                    value: data.value
                });
            }
            else {
                alreadyAcknowledged = true;
            }
            // Check if we have this acknowledgement is already there from another user
            if (!conversation.acknowledgements.find(x => x.jid === data.instigator) &&
                (config.autoIncludeMembersInRoles.length && config.autoIncludeMembersInRoles.includes(this.layer.getCurrentUser().group))) {
                conversation.acknowledgements.push({
                    jid: data.instigator,
                    ts: parseInt(data.date),
                    value: data.value
                });
                return;
            }
            const metaActivity = yield this.convert(message, data);
            let overrideUnread = false;
            if (data.instigator === this.layer.getCurrentUserJid() && config.shouldOpenConversationAfterResponded === false) {
                conversation.hasUnread = false;
                overrideUnread = true;
            }
            if (conversation.participants.filter(x => x.role === models_1.ChatRole.Owner).find(x => x.jid === this.layer.getCurrentUserJid()) ||
                config.participantAlertResponsesVisible) {
                yield this.layer.updateConversation(conversation, { preview: metaActivity, isParticipantChange: false, overrideHasUnread: overrideUnread });
            }
            else {
                yield this.layer.updateConversation(conversation);
            }
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
            if (data.instigator === this.layer.getCurrentUserJid()) {
                // tslint:disable-next-line no-any
                const win = window;
                if (win.PushNotification) {
                    win.PushNotification.addToIgnoreList && win.PushNotification.addToIgnoreList(() => { }, () => { }, conversation.createdTime);
                    win.PushNotification.cancelAtFront && win.PushNotification.cancelAtFront(() => { }, () => { });
                }
            }
            if (data.instigator === this.layer.getCurrentUserJid() && alreadyAcknowledged) {
                this.layer.emit(Events_1.ChatEvents.PriorityConversationAcknowledgedOnAnotherDevice);
            }
            else {
                this.layer.emit(Events_1.ChatEvents.PriorityConversationAcknowledged, new PriorityConversationAcknowledgedEventArgs_1.PriorityConversationAcknowledgedEventArgs(conversation, this.layer.getPendingAlertCount(), data.instigator));
            }
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.ACK, data.instigator, data.value);
        });
    }
}
exports.ParticipantAcknowledgedHandler = ParticipantAcknowledgedHandler;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ParticipantAddedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ParticipantAdded;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            const newParticipants = [
                ...conversation.participants,
                data.participant
            ];
            conversation.participants = utils_1.uniqueArrayItems(newParticipants, x => x.jid);
            const metaActivity = yield this.convert(message, data);
            yield this.layer.updateConversation(conversation, { preview: metaActivity, isParticipantChange: true });
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.ADD, data.instigator, data.participant.jid);
        });
    }
}
exports.ParticipantAddedHandler = ParticipantAddedHandler;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ParticipantLeftHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ParticipantLeft;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            conversation.participants = conversation.participants.filter(x => !utils_1.jidsMatch(x.jid, data.instigator));
            const metaActivity = yield this.convert(message, data);
            yield this.layer.updateConversation(conversation, { preview: metaActivity, isParticipantChange: true });
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.LEFT, data.instigator);
        });
    }
}
exports.ParticipantLeftHandler = ParticipantLeftHandler;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Models_1 = __webpack_require__(5);
const Events_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(2);
const ChatUtils_1 = __webpack_require__(10);
class ParticipantReceivedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ParticipantReceived;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data.participantreceipt;
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            let alreadyReceived = false;
            if (!conversation.receivedList) {
                conversation.receivedList = [];
            }
            if (!conversation.receivedList.find(x => x.jid === this.layer.getCurrentUserJid())) {
                conversation.receivedList.push({
                    jid: data.instigator,
                    ts: parseInt(data.ts),
                    value: ""
                });
                alreadyReceived = true;
            }
            yield this.layer.updateConversation(conversation);
            const currentConversation = yield this.layer.getCurrentConversation();
            if (currentConversation && (currentConversation.id === conversation.id)) {
                this.layer.emit(Events_1.ChatEvents.CurrentConversationChanged);
            }
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.RECEIVED, data.instigator, "received");
        });
    }
}
exports.ParticipantReceivedHandler = ParticipantReceivedHandler;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ParticipantRemovedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ParticipantRemoved;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            conversation.participants = conversation.participants.filter(x => !utils_1.jidsMatch(x.jid, data.participant.jid));
            const metaActivity = yield this.convert(message, data);
            yield this.layer.updateConversation(conversation, { preview: metaActivity, isParticipantChange: true });
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.REMOVE, data.instigator, data.participant.jid);
        });
    }
}
exports.ParticipantRemovedHandler = ParticipantRemovedHandler;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
class ParticipantRoleChangedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.ParticipantRoleChanged;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMamMessage(message))
                return;
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            const conversationParticipant = conversation.participants.find(x => utils_1.jidsMatch(x.jid, data.participant.jid));
            if (!conversationParticipant) {
                // LR: Remove this error to prevent the user getting the error modal for the race condition where a user gets removed from a conversation just before
                // they get updated.
                // tslint:disable-next-line
                console.error(" Unable to find participant in conversation");
                return;
                // throw new Error("Unable to find participant in conversation");
            }
            conversationParticipant.role = data.participant.role;
            const metaActivity = yield this.convert(message, data);
            yield this.layer.updateConversation(conversation, { preview: metaActivity, isParticipantChange: true });
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
        });
    }
    convert(message, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = message._id;
            const roomJid = utils_1.findRoomJidInMessage(message, this.layer.config.xmpp.mucHost);
            return ChatUtils_1.createMetaEntry(id, data.date, roomJid, Models_1.ChatMetaActivityType.CHANGEROLE, data.instigator, data.participant.jid, data.participant.role.toString());
        });
    }
}
exports.ParticipantRoleChangedHandler = ParticipantRoleChangedHandler;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(2);
const ConversationConfigReader_1 = __webpack_require__(14);
class UserAddedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.User_Added;
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            let conversation = yield this.layer.getConversationById(data.id);
            if (conversation === null && this.isMamMessage(message))
                return; // don't need to create conversations from MAM queries, the "fetch" query will have handled that
            if (conversation !== null && !conversation.isClosed)
                return; // we already know about this conversation - we cannot create it again
            const config = new ConversationConfigReader_1.ConversationConfigReader(this.layer, conversation);
            const currentUserJid = this.layer.getCurrentUserJid();
            const metaActivity = ChatUtils_1.createMetaEntry(message._id, data.date, data.roomJid, Models_1.ChatMetaActivityType.ADD, data.instigator, currentUserJid);
            if (conversation && conversation.isClosed) {
                yield this.layer.reopenConversation(conversation, data.participants, metaActivity);
            }
            else {
                const type = utils_1.enumFromString(data.type);
                conversation = ChatUtils_1.createConversation(data.id, type, data.roomJid, data.participants, data.title, data.description, data.started, data.priority, data.expiry_ttl, data.activity_ttl, data.receipts, data.responses, data.started_by);
                yield this.layer.addConversation(conversation, metaActivity);
            }
            let alertSound = true;
            if (config.alert) {
                alertSound = yield this.layer.priorityAlert(conversation);
            }
            if (alertSound) {
                this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
            }
        });
    }
}
exports.UserAddedHandler = UserAddedHandler;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const Keys_1 = __webpack_require__(13);
class UserConversationEndedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.User_ConversationEnded;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            const currentConversation = yield this.layer.getCurrentConversation();
            const isCurrentConversation = currentConversation && currentConversation.id === conversation.id;
            const currentUserJid = this.layer.getCurrentUserJid();
            const instigatedByCurrentUser = currentUserJid === data.instigator;
            if (isCurrentConversation && !instigatedByCurrentUser) {
                const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ENDED_TITLE));
                const message = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.ENDED_MESSAGE)).replace("{{subject}}", conversation.subject);
                this.layer.emit(Events_1.ChatEvents.ForceQuitConversation, new Events_1.ForceQuitConversationEventArgs(conversation, data.instigator, Models_1.ChatMetaActivityType.END));
                // Added a small delay here for a slightly nicer user experience
                setTimeout(() => this.layer.emit(Events_1.ChatEvents._Request_RaiseAlert, new models_1.DefaultAlerts(this.layer).AlertAcknowledge(title, message, 1, {}), true), 1000);
            }
            const metaActivity = ChatUtils_1.createMetaEntry(message._id, data.date, conversation.roomJid, Models_1.ChatMetaActivityType.END, data.instigator);
            yield this.layer.closeConversation(conversation, metaActivity);
            if (data.state === "expired") {
                yield this.layer.removeConversationById(conversation.id);
            }
        });
    }
}
exports.UserConversationEndedHandler = UserConversationEndedHandler;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
class UserDeleteDirectConversationHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.User_DeleteDirectConversation;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            if (this.layer.getCurrentUser().id.toLowerCase() === data.instigator.toLowerCase()) {
                const conversation = yield this.layer.getConversationById(data.id);
                if (!conversation)
                    return _super("handleConversationNotFound").call(this, message, data.id);
                // If the conversation has newer messages than the hide_before timestamp,
                // we mark the conversation as not hidden so it shows within the conversation list.
                // We also keep track of the last hide_before timestamp with the lastHidebefore prop.
                if (conversation.preview && conversation.preview.date > parseInt(data.hide_before)) {
                    if (conversation.hideBefore) {
                        conversation.lastHideBefore = conversation.hideBefore;
                        conversation.hideBefore = 0;
                    }
                    yield this.layer.updateConversation(conversation);
                }
                else {
                    const currentConversation = yield this.layer.getCurrentConversation();
                    const isCurrentConversation = currentConversation && currentConversation.id === conversation.id;
                    if (isCurrentConversation) {
                        currentConversation.hideBefore = parseInt(data.hide_before);
                        yield this.layer.comms.clearStoredConversationMessages(currentConversation);
                        yield this.layer.updateConversation(currentConversation);
                        yield this.layer.clearCurrentConversation();
                        this.layer.emit(Events_1.ChatEvents.ConversationDeleted);
                    }
                    else {
                        const conversation = yield this.layer.getConversationById(data.id);
                        conversation.hideBefore = parseInt(data.hide_before);
                        yield this.layer.comms.clearStoredConversationMessages(conversation);
                        yield this.layer.updateConversation(conversation);
                    }
                }
                this.layer.dismissWaitingMessage();
            }
        });
    }
}
exports.UserDeleteDirectConversationHandler = UserDeleteDirectConversationHandler;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
class UserLeftHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.User_Left;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            const currentUserJid = this.layer.getCurrentUserJid();
            const metaActivity = ChatUtils_1.createMetaEntry(message._id, data.date, conversation.roomJid, Models_1.ChatMetaActivityType.LEFT, currentUserJid);
            yield this.layer.closeConversation(conversation, metaActivity);
        });
    }
}
exports.UserLeftHandler = UserLeftHandler;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = __webpack_require__(1);
const BaseChatHandler_1 = __webpack_require__(6);
const Handlers_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(4);
const Models_1 = __webpack_require__(5);
const ChatUtils_1 = __webpack_require__(10);
const Keys_1 = __webpack_require__(13);
class UserRemovedHandler extends BaseChatHandler_1.BaseChatHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.ChatMessageType.User_Removed;
    }
    handleMessage(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            const conversation = yield this.layer.getConversationById(data.id);
            if (!conversation)
                return _super("handleConversationNotFound").call(this, message, data.id);
            const currentConversation = yield this.layer.getCurrentConversation();
            const isCurrentConversation = currentConversation && currentConversation.id === conversation.id;
            const currentUserJid = this.layer.getCurrentUserJid();
            const instigatedByCurrentUser = currentUserJid === data.instigator;
            if (isCurrentConversation && !instigatedByCurrentUser) {
                const title = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.REMOVED_TITLE));
                const message = this.layer.translateI18nItem(Keys_1.ChatCommonMetadata.getI18nItem(Keys_1.ChatCommonI18nKeys.REMOVED_MESSAGE)).replace("{{subject}}", conversation.subject);
                this.layer.emit(Events_1.ChatEvents._Request_RaiseAlert, new models_1.DefaultAlerts(this.layer).AlertAcknowledge(title, message, 1, {}));
                this.layer.emit(Events_1.ChatEvents.ForceQuitConversation, new Events_1.ConversationEventArgs(conversation));
            }
            const metaActivity = ChatUtils_1.createMetaEntry(message._id, data.date, conversation.roomJid, Models_1.ChatMetaActivityType.REMOVE, data.instigator, currentUserJid);
            yield this.layer.closeConversation(conversation, metaActivity);
            this.layer.emit(Events_1.ChatEvents.ChatEntryReceived, new Events_1.ChatEntryEventArgs(metaActivity));
        });
    }
}
exports.UserRemovedHandler = UserRemovedHandler;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(151));


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Config_1 = __webpack_require__(110);
/**
 * Determines if the pager functionality has been enabled for this CM app.
 *
 * @param layer ChatLayerComponentInterface layer with config to check against.
 */
function isPagerEnabled(layer) {
    if (layer.config && (layer.config.pagerSettings && layer.config.pagerSettings.enabled !== false)) {
        return true;
    }
    else {
        return false;
    }
}
exports.isPagerEnabled = isPagerEnabled;
/**
 * Gets the specified pager configuration setting from the layer config. Will return null if no
 * setting is found.
 *
 * @param layer ChatLayerComponentInterface layer with config to check against.
 */
function getPagerConfigSetting(layer, prop) {
    if (!isPagerEnabled(layer))
        return null;
    if (layer.config && layer.config.pagerSettings) {
        return layer.config.pagerSettings[prop] || null;
    }
    return null;
}
exports.getPagerConfigSetting = getPagerConfigSetting;
/**
 * Gets the settings to determine if pager attachments are enabled or not.
 *
 * @param layer ChatLayerComponentInterface layer with config to check against.
 */
function getAttachmentSettings(layer) {
    if (!isPagerEnabled(layer))
        return null;
    return getPagerConfigSetting(layer, "attachments");
}
exports.getAttachmentSettings = getAttachmentSettings;
/**
 * Gets the configured pager reply templates and combines with the pre-configured default template.
 *
 * @param layer ChatLayerComponentInterface layer with config to check against.
 */
function getReplyTemplates(layer) {
    if (!isPagerEnabled(layer))
        return [];
    const configReplies = getPagerConfigSetting(layer, "replyTemplates");
    const defaultReply = Config_1.defaultReplyTemplate;
    if (configReplies && configReplies instanceof Array) {
        return [
            defaultReply,
            ...configReplies.sort((a, b) => a.id > b.id ? 1 : b.id > a.id ? -1 : 0)
        ];
    }
    else {
        return [defaultReply];
    }
}
exports.getReplyTemplates = getReplyTemplates;
/**
 * Generates a new page object with defaults specified.
 */
function generateDefaultNewPage() {
    return {
        replyTemplate: Config_1.defaultReplyTemplate,
        imgSrc: "",
        audioSrc: "",
        enableChat: true
    };
}
exports.generateDefaultNewPage = generateDefaultNewPage;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const file_1 = __webpack_require__(30);
const utils_1 = __webpack_require__(2);
const plugin_1 = __webpack_require__(22);
const importedMedia = plugin_1.getSource("Media");
var AudioRecorderError;
(function (AudioRecorderError) {
    AudioRecorderError[AudioRecorderError["NoAudioDevicesFound"] = 1] = "NoAudioDevicesFound";
})(AudioRecorderError = exports.AudioRecorderError || (exports.AudioRecorderError = {}));
class SimpleAudioRecorder {
    constructor(callback, error) {
        // === Private === //
        this._onDataAvailable = (e) => {
            // tslint:disable-next-line no-any
            this._chunks.push(e.data);
        };
        this._onStopRecording = (e) => __awaiter(this, void 0, void 0, function* () {
            this._stream.stop();
            const blob = new Blob(this._chunks);
            // const decoded: Blob = await this._encodeToMp3(blob);
            try {
                const file = yield this._encodeToMp3(blob);
                if (this._onFinishedCallback) {
                    this._onFinishedCallback(file);
                }
            }
            catch (ex) {
                if (this._onFinishedCallback) {
                    this._onFinishedCallback(null);
                }
            }
        });
        this._mediaError = () => {
        };
        this._mediaStatusUpdate = (e) => {
        };
        this._isMobile = utils_1.isMobile();
        this._onFinishedCallback = callback;
        this._errorCallback = error;
    }
    _encodeToMp3(blob) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const tempFilePath = yield file_1.saveFileToDisk(blob, "recording.webm");
            const newFile = this._workOutPath(tempFilePath);
            // tslint:disable-next-line no-any
            const ffmpeg = window.require("easy-ffmpeg");
            ffmpeg(tempFilePath)
                .output(newFile)
                .on("end", () => {
                // tslint:disable-next-line no-any
                const fs = window.require("fs");
                fs.unlink(tempFilePath, () => {
                    resolve(newFile);
                });
            })
                .on("error", (e) => {
                // tslint:disable-next-line no-console
                console.error("Encoding error:", e);
                reject(e);
            })
                .run();
        }));
    }
    _workOutPath(tempFilePath) {
        const win = window;
        if (win.process && win.process.platform === "win32") {
            const dir = `${tempFilePath.substring(0, tempFilePath.lastIndexOf("\\"))}`;
            return `${dir}\\${new Date().valueOf()}_recording.mp3`;
        }
        else {
            const dir = `${tempFilePath.substring(0, tempFilePath.lastIndexOf("/"))}`;
            return `${dir}/${new Date().valueOf()}_recording.mp3`;
        }
    }
    // === Public === //
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isMobile) {
                let filepath = yield file_1.getStorageLocation();
                if (filepath.indexOf("file://") === 0)
                    filepath = filepath.replace("file://", "");
                const filename = `${filepath}${new Date().getTime()}.m4a`;
                this._media = new importedMedia(filename, () => { }, this._mediaError, this._mediaStatusUpdate);
                this._media.startRecordWithCompression({
                    SampleRate: 44100,
                    NumberOfChannels: 1
                });
            }
            else {
                try {
                    this._chunks = [];
                    this._stream = yield navigator.mediaDevices.getUserMedia({ audio: true });
                    this._recorder = new MediaRecorder(this._stream);
                    this._recorder.addEventListener("dataavailable", this._onDataAvailable);
                    this._recorder.addEventListener("stop", this._onStopRecording);
                    this._recorder.start();
                }
                catch (ex) {
                    // tslint:disable-next-line no-console
                    console.error("NK:", ex);
                    if (ex.name && ex.name === "DevicesNotFoundError") {
                        if (this._errorCallback) {
                            this._errorCallback(AudioRecorderError.NoAudioDevicesFound);
                        }
                    }
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isMobile) {
                this._media.stopRecord();
                this._media.release();
                if (this._onFinishedCallback)
                    this._onFinishedCallback(this._media.src);
            }
            else {
                if (this._recorder && this._recorder.stop) {
                    this._recorder.stop();
                }
            }
        });
    }
}
exports.SimpleAudioRecorder = SimpleAudioRecorder;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const file_1 = __webpack_require__(30);
class SimpleVideoRecorder {
    constructor(video, onFinishedCallback) {
        this._constraints = {
            audio: true,
            video: {
                width: 640,
                height: 480,
                frameRate: 24
            }
        };
        // === Private === //
        this._onDataAvailable = (e) => {
            // tslint:disable-next-line no-any
            this._chunks.push(e.data);
        };
        this._onStopRecording = (e) => __awaiter(this, void 0, void 0, function* () {
            const blob = new Blob(this._chunks);
            try {
                // const filepath: string = await this._encodeToMp4(blob);
                const filepath = yield file_1.saveFileToDisk(blob, "video.webm");
                if (this._onFinishedCallback) {
                    this._onFinishedCallback(filepath);
                }
            }
            catch (ex) {
                // tslint:disable-next-line no-console
                console.error("NK: File saving error", ex);
            }
        });
        this._video = video;
        this._onFinishedCallback = onFinishedCallback;
    }
    _encodeToMp4(blob) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const tempFilePath = yield file_1.saveFileToDisk(blob, "video.webm");
            const dir = `${tempFilePath.substring(0, tempFilePath.lastIndexOf("/"))}`;
            const newFile = `${dir}/${new Date().valueOf()}_video.mp4`;
            // tslint:disable-next-line no-any
            const ffmpeg = window.require("easy-ffmpeg");
            ffmpeg(tempFilePath)
                .output(newFile)
                .on("end", () => {
                // tslint:disable-next-line no-any
                const fs = window.require("fs");
                fs.unlink(tempFilePath, () => {
                    resolve(newFile);
                });
            })
                .on("error", (e) => {
                // tslint:disable-next-line no-console
                console.error("Encoding error:", e);
                reject(e);
            })
                .run();
        }));
    }
    // === Public === //
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this._chunks = [];
            this._stream = yield navigator.mediaDevices.getUserMedia(this._constraints);
            this._video.onloadedmetadata = () => this._video.play();
            this._video.muted = true;
            this._video.srcObject = this._stream;
            this._recorder = new MediaRecorder(this._stream);
            this._recorder.addEventListener("dataavailable", this._onDataAvailable);
            this._recorder.addEventListener("stop", this._onStopRecording);
            this._recorder.start();
        });
    }
    stop() {
        this._recorder.stop();
        this._stream.getTracks().forEach(x => x.stop());
        this._video.srcObject = null;
    }
}
exports.SimpleVideoRecorder = SimpleVideoRecorder;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(2);
var Platform;
(function (Platform) {
    Platform[Platform["iOS"] = 1] = "iOS";
    Platform[Platform["Android"] = 2] = "Android";
    Platform[Platform["Desktop"] = 3] = "Desktop";
})(Platform || (Platform = {}));
class VibrationController {
    constructor() {
        this._iterations = 0;
        const win = window;
        if (win.cti) {
            this._platform = win.cti.store.env.platform.name === "android"
                ? Platform.Android
                : Platform.iOS;
        }
        else {
            this._platform = Platform.Desktop;
        }
    }
    _vibrate(duration = 100, force = false) {
        if (!utils_1.isDesktop()) {
            const vib = navigator.vibrate;
            vib(duration, force);
        }
        else {
            navigator.vibrate(duration);
        }
    }
    // === Public === //
    vibrate(duration = 100, iterations = 1, force = false) {
        clearInterval(this._timer);
        const delay = duration + 500;
        if (duration === 0) {
            if (this._platform === Platform.iOS) {
                this._vibrate(duration, force);
                this._timer = setInterval(() => this._vibrate(duration, force), delay);
            }
            else if (this._platform === Platform.Android) {
                this._vibrate(86400000, force);
            }
        }
        else {
            this._vibrate(duration, force);
            if (this._iterations === 0) {
                this._timer = setInterval(() => this._vibrate(duration, force), delay);
            }
            else {
                this._iterations = iterations - 1;
                this._timer = setInterval(() => {
                    if (this._iterations > 0) {
                        this._iterations--;
                        this._vibrate(duration, force);
                    }
                    else {
                        this.stop();
                    }
                }, delay);
            }
        }
    }
    vibrateWithPattern(pattern, iterations = 1, force = false) {
        clearInterval(this._timer);
        this._iterations = 0;
        if (this._platform === Platform.Android) {
            const duration = pattern.reduce((acc, cur) => acc += cur, 0) + 500;
            this._vibrate(pattern, force);
            this._iterations--;
            if (iterations === 0) {
                this._timer = setInterval(() => this._vibrate(pattern, force), duration);
            }
            else {
                this._timer = setInterval(() => {
                    if (this._iterations > 0) {
                        this._iterations--;
                        this._vibrate(pattern, force);
                    }
                    else {
                        this.stop();
                    }
                }, duration);
            }
        }
    }
    stop() {
        this._iterations = 0;
        clearInterval(this._timer);
        delete this._timer;
        this._vibrate(0);
    }
}
exports.VibrationController = VibrationController;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const Errors_1 = __webpack_require__(18);
const Keys_1 = __webpack_require__(13);
const ct_cl_add_conversation_contacts_1 = __webpack_require__(36);
const ct_cl_chat_message_list_1 = __webpack_require__(37);
const ct_cl_contact_info_1 = __webpack_require__(38);
const ct_cl_conversation_info_1 = __webpack_require__(39);
const ct_cl_conversation_list_1 = __webpack_require__(40);
const ct_cl_header_1 = __webpack_require__(29);
const ct_cl_new_conversation_1 = __webpack_require__(41);
const ct_cl_conversation_alert_1 = __webpack_require__(106);
const win = window;
function getChatI18nKeys(fullyQualified = false, ...scopes) {
    if (scopes.length === 0)
        scopes = [...win.translationData.keys()]; // if no scopes supplied, all scopes apply
    const keys = scopes.reduce((acc, cur) => acc.concat(getScopedI18nKeys(fullyQualified, cur)), []);
    return keys
        .filter((key, idx, arr) => {
        return arr.indexOf(key) === idx;
    })
        .sort();
}
exports.getChatI18nKeys = getChatI18nKeys;
function getScopedI18nKeys(fullyQualified, scope) {
    if (scope !== null && !win.translationData.has(scope))
        return [];
    return win.translationData.get(scope).getUniqueI18Keys(fullyQualified) || [];
}
// This can eventually be removed once all components are upgraded to use the new decorator for initalisation...
win.translationData.set("CTCLConversationAlert", ct_cl_conversation_alert_1.CTCLConversationAlertMetadata.instance);
win.translationData.set("CTCLAddConversationContacts", ct_cl_add_conversation_contacts_1.CTCLAddConversationContactsMetadata.instance);
win.translationData.set("CTCLChatMessageList", ct_cl_chat_message_list_1.CTCLChatMessageListMetadata.instance);
win.translationData.set("CTCLContactInfo", ct_cl_contact_info_1.CTCLContactInfoMetadata.instance);
win.translationData.set("CTCLConversationInfo", ct_cl_conversation_info_1.CTCLConversationInfoMetadata.instance);
win.translationData.set("CTCLConversationList", ct_cl_conversation_list_1.CTCLConversationListMetadata.instance);
win.translationData.set("CTCLHeader", ct_cl_header_1.CTCLHeaderMetadata.instance);
win.translationData.set("CTCLNewConversation", ct_cl_new_conversation_1.CTCLNewConversationMetadata.instance);
win.translationData.set("ChatErrors", Errors_1.ChatErrorsMetadata);
win.translationData.set("ChatCommon", Keys_1.ChatCommonMetadata);
// TODO: Add some stuff here


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SupportedAttachmentType;
(function (SupportedAttachmentType) {
    // tslint:disable no-any
    SupportedAttachmentType[SupportedAttachmentType["AUDIO"] = "audio"] = "AUDIO";
    SupportedAttachmentType[SupportedAttachmentType["IMAGE"] = "image"] = "IMAGE";
    SupportedAttachmentType[SupportedAttachmentType["VIDEO"] = "video"] = "VIDEO";
    // tslint:enable no-any
})(SupportedAttachmentType = exports.SupportedAttachmentType || (exports.SupportedAttachmentType = {}));


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ChatMetaActivityType;
(function (ChatMetaActivityType) {
    // tslint:disable no-any
    ChatMetaActivityType[ChatMetaActivityType["START"] = "start"] = "START";
    ChatMetaActivityType[ChatMetaActivityType["UPDATE"] = "update"] = "UPDATE";
    ChatMetaActivityType[ChatMetaActivityType["ADD"] = "add"] = "ADD";
    ChatMetaActivityType[ChatMetaActivityType["REMOVE"] = "remove"] = "REMOVE";
    ChatMetaActivityType[ChatMetaActivityType["CHANGEROLE"] = "changerole"] = "CHANGEROLE";
    ChatMetaActivityType[ChatMetaActivityType["LEFT"] = "left"] = "LEFT";
    ChatMetaActivityType[ChatMetaActivityType["END"] = "end"] = "END";
    ChatMetaActivityType[ChatMetaActivityType["ACK"] = "acknowledge"] = "ACK";
    ChatMetaActivityType[ChatMetaActivityType["RECEIVED"] = "received"] = "RECEIVED";
    // tslint:enable no-any
})(ChatMetaActivityType = exports.ChatMetaActivityType || (exports.ChatMetaActivityType = {}));


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ConversationType;
(function (ConversationType) {
    // tslint:disable no-any
    ConversationType[ConversationType["Direct"] = "direct"] = "Direct";
    ConversationType[ConversationType["Named"] = "named"] = "Named";
    // tslint:enable no-any
})(ConversationType = exports.ConversationType || (exports.ConversationType = {}));


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var Icons;
(function (Icons) {
    Icons.UI = {
        Pencil: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M732.458 3.542l-572.458 572.458-160 448 447.666-160 572.792-572.458c32-128-160-320-288-288zM288 704l-64-64 544-544 64 64-544 544z"
            ]
        },
        Attachment: {
            viewBox: "0 0 1097 1024",
            paths: [
                "M548.571 384c90.857 0 164.571 73.714 164.571 164.571s-73.714 164.571-164.571 164.571-164.571-73.714-164.571-164.571 73.714-164.571 164.571-164.571zM950.857 146.286c80.571 0 146.286 65.714 146.286 146.286v512c0 80.571-65.714 146.286-146.286 146.286h-804.571c-80.571 0-146.286-65.714-146.286-146.286v-512c0-80.571 65.714-146.286 146.286-146.286h128l29.143-77.714c14.286-37.714 58.857-68.571 98.857-68.571h292.571c40 0 84.571 30.857 98.857 68.571l29.143 77.714h128zM548.571 804.571c141.143 0 256-114.857 256-256s-114.857-256-256-256-256 114.857-256 256 114.857 256 256 256z"
            ]
        },
        Error: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 96c-111.118 0-215.584 43.272-294.156 121.844s-121.844 183.038-121.844 294.156c0 111.118 43.272 215.584 121.844 294.156s183.038 121.844 294.156 121.844c111.118 0 215.584-43.272 294.156-121.844s121.844-183.038 121.844-294.156c0-111.118-43.272-215.584-121.844-294.156s-183.038-121.844-294.156-121.844zM512 0v0c282.77 0 512 229.23 512 512s-229.23 512-512 512c-282.77 0-512-229.23-512-512s229.23-512 512-512zM448 704h128v128h-128zM448 192h128v384h-128z"
            ]
        },
        SendMessage: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M448 704l393.636 140.488 182.364-797.356zM320 659.908l704-612.776-1024 506.462zM448 771.954v252.046l185.752-185.752z"
            ]
        },
        Reconnect: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z"
            ]
        },
        Download: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M576 576h-128v192h-160l224 224 224-224h-160z",
                "M892.216 514.542c2.49-11.29 3.784-22.87 3.784-34.542 0-88.224-71.776-160-160-160-13.956 0-27.796 1.83-41.164 5.378-24.838-77.286-97.404-133.378-182.836-133.378-86.654 0-160.886 58.042-184.312 138.118-22.982-6.66-47.052-10.118-71.688-10.118-141.158 0-256 114.84-256 256 0 61.986 22.444 121.798 63.2 168.42 40.354 46.164 95.852 76.346 156.266 84.988 1.538 0.218 3.064 0.326 4.572 0.326 15.666 0 29.354-11.514 31.638-27.472 2.502-17.496-9.652-33.708-27.146-36.208-45.262-6.474-86.864-29.116-117.144-63.754-30.558-34.956-47.386-79.81-47.386-126.3 0-105.87 86.13-192 192-192 52.024 0 100.73 20.466 137.146 57.63 12.368 12.624 32.63 12.83 45.252 0.458 12.624-12.37 12.83-32.628 0.458-45.252-15.676-15.998-33.070-29.66-51.76-40.848 12.84-57.42 64.304-99.988 124.904-99.988 70.58 0 128 57.42 128 128 0 8.706-0.876 17.398-2.602 25.832-3.542 17.316 7.624 34.222 24.938 37.764 2.164 0.444 4.32 0.656 6.448 0.656 14.884 0 28.218-10.442 31.318-25.592 2.218-10.854 3.494-21.972 3.812-33.126 10.244-3.624 21.096-5.534 32.086-5.534 52.936 0 96 43.066 96 96 0 10.964-1.88 21.784-5.484 32h-26.516c-17.674 0-32 14.326-32 32s14.326 32 32 32h64c52.934 0 96 43.066 96 96s-43.066 96-96 96h-64c-17.674 0-32 14.326-32 32s14.326 32 32 32h64c88.224 0 160-71.776 160-160 0-78.594-56.976-144.086-131.784-157.458z"
            ]
        },
        ScrollToBottom: {
            viewBox: "0 0 1024 1024",
            nodes: [
                {
                    name: "mask",
                    attributes: { id: "ScrollToBottom-Mask" },
                    children: [
                        { name: "rect", attributes: { width: "100%", height: "100%", fill: "white" } },
                        { name: "path", attributes: { d: "M512 684l150-350-300 0z", fill: "black" } }
                    ]
                },
                {
                    name: "path",
                    attributes: { d: "M512 64c282.77 0 512 186.25 512 416 0 229.752-229.23 416-512 416-27.156 0-53.81-1.734-79.824-5.044-109.978 109.978-241.25 129.7-368.176 132.596v-26.916c68.536-33.578 128-94.74 128-164.636 0-9.754-0.758-19.33-2.164-28.696-115.796-76.264-189.836-192.754-189.836-323.304 0-229.75 229.23-416 512-416z", mask: "url(#ScrollToBottom-Mask)" }
                }
            ]
        },
        Plus: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M992 384h-352v-352c0-17.672-14.328-32-32-32h-192c-17.672 0-32 14.328-32 32v352h-352c-17.672 0-32 14.328-32 32v192c0 17.672 14.328 32 32 32h352v352c0 17.672 14.328 32 32 32h192c17.672 0 32-14.328 32-32v-352h352c17.672 0 32-14.328 32-32v-192c0-17.672-14.328-32-32-32z"
            ]
        },
        Photo: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M959.884 128c0.040 0.034 0.082 0.076 0.116 0.116v767.77c-0.034 0.040-0.076 0.082-0.116 0.116h-895.77c-0.040-0.034-0.082-0.076-0.114-0.116v-767.772c0.034-0.040 0.076-0.082 0.114-0.114h895.77zM960 64h-896c-35.2 0-64 28.8-64 64v768c0 35.2 28.8 64 64 64h896c35.2 0 64-28.8 64-64v-768c0-35.2-28.8-64-64-64v0z",
                "M832 288c0 53.020-42.98 96-96 96s-96-42.98-96-96 42.98-96 96-96 96 42.98 96 96z",
                "M896 832h-768v-128l224-384 256 320h64l224-192z"
            ]
        },
        Cross: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M893.254 221.254l-90.508-90.508-290.746 290.744-290.746-290.744-90.508 90.506 290.746 290.748-290.746 290.746 90.508 90.508 290.746-290.746 290.746 290.746 90.508-90.51-290.744-290.744z"
            ]
        },
        MusicalNote: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M812.158 294.412c-87.050-122.21-78.88-35.914-163.208-279.684l-89.178-14.728-99.218 732.95c-223.632-127.958-364.672 3.468-328.984 168.886 18.92 87.712 161.432 170.274 301.8 88.78 66.342-39.89 87.672-104.22 96.14-149.838l70.876-543.852c252.89 222.974 172.142 357.892 119.85 513.244 107.498-44.334 275.88-239.888 91.922-515.758z"
            ]
        },
        Microphone: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 448c0-6.26-0.152-12.59-0.454-18.812-1.278-26.478-23.746-46.918-50.256-45.632-26.478 1.278-46.908 23.778-45.63 50.256 0.224 4.688 0.34 9.46 0.34 14.186 0 158.894-129.196 288.166-288 288.166s-288-129.272-288-288.166c0-4.692 0.114-9.438 0.336-14.106 1.27-26.48-19.166-48.974-45.644-50.246-26.46-1.26-48.974 19.166-50.244 45.646-0.298 6.196-0.448 12.49-0.448 18.708 0 190.018 138.622 348.226 320 378.8v133.2c0 35.346 28.654 64 64 64s64-28.654 64-64v-133.2c181.378-30.574 320-188.782 320-378.8z",
                "M512 0c-106.040 0-192 85.96-192 192v256c0 106.040 85.96 192 192 192s192-85.96 192-192v-256c0-106.040-85.96-192-192-192z"
            ]
        },
        CheckboxChecked: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 0h-768c-70.4 0-128 57.6-128 128v768c0 70.4 57.6 128 128 128h768c70.4 0 128-57.6 128-128v-768c0-70.4-57.6-128-128-128zM448 794.51l-237.254-237.256 90.51-90.508 146.744 146.744 306.746-306.746 90.508 90.51-397.254 397.256z"
            ]
        },
        CheckboxUnchecked: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 0h-768c-70.4 0-128 57.6-128 128v768c0 70.4 57.6 128 128 128h768c70.4 0 128-57.6 128-128v-768c0-70.4-57.6-128-128-128zM896 896h-768v-768h768v768z"
            ]
        },
        SquareFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M128 128h768v768h-768z"
            ]
        },
        CircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M0 512c0-282.77 229.23-512 512-512s512 229.23 512 512c0 282.77-229.23 512-512 512s-512-229.23-512-512z"
            ]
        },
        Play: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M192 128l640 384-640 384z"
            ]
        },
        Pause: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M128 128h320v768h-320zM576 128h320v768h-320z"
            ]
        },
        AlertBell: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1024 832c-106.042 0-192-85.96-192-192v-285.090c0-140.738-109.942-258.128-256-285.084v-69.826h-128v69.824c-146.064 26.958-256 144.346-256 285.084v285.092c0 106.040-85.962 192-192 192v64h429.598c-5.208 11.424-8.11 24.118-8.11 37.49 0 49.986 40.524 90.51 90.512 90.51 49.984 0 90.51-40.524 90.51-90.51 0-13.376-2.902-26.066-8.112-37.49h429.602v-64z"
            ]
        },
        AlertBellRinging: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1024 832c-106.042 0-192-85.96-192-192v-285.090c0-140.738-109.942-258.128-256-285.084v-69.826h-128v69.824c-146.064 26.958-256 144.346-256 285.084v285.092c0 106.040-85.962 192-192 192v64h429.598c-5.208 11.424-8.11 24.118-8.11 37.49 0 49.986 40.524 90.51 90.512 90.51 49.984 0 90.51-40.524 90.51-90.51 0-13.376-2.9-26.066-8.112-37.49h429.602v-64z",
                "M990.92 384c-16.714 0-30.786-12.98-31.9-29.9-7.526-114.362-58.112-220.42-142.44-298.638-12.958-12.018-13.718-32.264-1.7-45.222 12.020-12.956 32.266-13.716 45.222-1.7 96.366 89.384 154.174 210.614 162.78 341.358 1.16 17.634-12.196 32.872-29.83 34.032-0.714 0.048-1.428 0.070-2.132 0.070z",
                "M33.082 384c-0.708 0-1.416-0.022-2.132-0.070-17.636-1.16-30.99-16.398-29.83-34.032 8.606-130.75 66.416-251.982 162.778-341.36 12.96-12.018 33.206-11.254 45.224 1.702 12.018 12.958 11.256 33.204-1.702 45.222-84.326 78.214-134.912 184.272-142.44 298.64-1.112 16.92-15.186 29.898-31.898 29.898z"
            ]
        },
        PickVideo: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M78.302 262.54l865.444-231.884 49.69 185.452-865.444 231.884zM128 448v576h896v-576h-896zM448 896v-320l256 160-256 160z"
            ]
        },
        RecordVideo: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M978.84 256.252c-10.588 0-21.458 3.722-31.436 10.766l-179.404 126.614v-105.632c0-52.8-43.2-96-96-96h-576c-52.8 0-96 43.2-96 96v448c0 52.8 43.2 96 96 96h576c52.8 0 96-43.2 96-96v-105.63l179.402 126.614c9.978 7.042 20.848 10.764 31.434 10.766 0.002 0 0.002 0 0.006 0 14.088 0 26.954-6.496 35.292-17.822 6.456-8.77 9.868-20.054 9.868-32.636v-410.582c-0.002-33.126-22.72-50.458-45.162-50.458z"
            ]
        }
    };
})(Icons = exports.Icons || (exports.Icons = {}));


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// DEFAULT ACKNOWLEDGE RESPONSE TEMPLATE
exports.defaultAlertResponseOption = {
    id: "_default",
    name: "Acknowledge",
    options: [
        {
            name: "Acknowledge",
            type: "button",
            label: "Acknowledge",
            value: "Acknowledge"
        }
    ]
};
// DIRECT CONVERSATION
exports.directConversationConfig = {
    id: "1",
    sortOrder: 1,
    name: "Direct",
    shortDescription: "A personal conversation with you and one or more participants.",
    colorCode: "",
    displayGroup: "normal",
    behaviour: {
        chatAvailable: true,
        canSendAttachmentsWithinConversation: true
    }
};
// NAMED CONVERSATION
exports.namedConversationConfig = {
    id: "2",
    sortOrder: 2,
    name: "Named",
    shortDescription: "A converstion with a subject and context.",
    colorCode: "",
    displayGroup: "normal",
    behaviour: {
        chatAvailable: true,
        namedSettings: {
            subjectRequired: true,
            descriptionRequired: true
        },
        participantCanLeave: true,
        ownerCanEditAfterSend: true,
        ownerCanCloseEarly: true,
        ownerCanAddAdditionalContacts: true,
        canSendAttachmentsWithinConversation: true
    }
};
// PAGE
exports.page = {
    id: "3",
    sortOrder: 3,
    name: "Page",
    shortDescription: "A single page that requires a prompted response from the participants.",
    colorCode: "",
    displayGroup: "normal",
    behaviour: {
        warnWhenNoContacts: true,
        chatAvailable: false,
        namedSettings: {
            subjectRequired: true,
            subjectFieldLabel: "Title",
            descriptionRequired: true,
            descriptionFieldLabel: "Description"
        },
        participantCanLeave: false,
        ownerCanEditAfterSend: false,
        ownerCanCloseEarly: false,
        canSendAttachmentsWithinConversation: false,
        autoRemoveOnClose: true,
        alert: {
            autoAlert: true,
            alertResponseOptions: [exports.defaultAlertResponseOption],
            shouldOpenConversationAfterResponded: false,
            participantAlertResponsesVisible: false
        },
        attachments: {
            image: true,
            audio: true
        }
    }
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseStore_1 = __webpack_require__(102);
const Logger_1 = __webpack_require__(17);
class Store extends BaseStore_1.BaseStore {
    constructor(name, logger, config) {
        super(name, logger);
        this.SCHEMA_VERSION = 1;
        this._config = config;
    }
    init() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("init").call(this);
            if (this.state.schemaVersion === this.SCHEMA_VERSION) {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cSTATE IS USING EXPECTED SCHEMA VERSION: %c${this.state.schemaVersion}`, "color: #606; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            else if (this.state.schemaVersion < this.SCHEMA_VERSION) {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cSTATE IS USING OLD SCHEMA VERSION:`, "color: #C00; font-weight: bold;", { current: this.state.schemaVersion, expected: this.SCHEMA_VERSION });
            }
            else {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cSTATE IS NEWER THAN EXPECTED SCHEMA VERSION:`, "color: #C00; font-weight: bold;", { current: this.state.schemaVersion, expected: this.SCHEMA_VERSION });
            }
        });
    }
    getLatestIdentifier() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.latestIdentifier;
        });
    }
    updateLatestIdentifier(identifier) {
        return __awaiter(this, void 0, void 0, function* () {
            if (identifier > this.state.latestIdentifier) {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, ` %cSTORING latestIdentifier '${identifier}':`, "color: #C00; font-weight: bold;");
                this.state.latestIdentifier = identifier;
                yield this.saveToPersistent();
            }
        });
    }
    loadConversations() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.conversations || [];
        });
    }
    saveConversations(conversations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.conversations = conversations;
            yield this.saveToPersistent();
        });
    }
    clearChatData() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.latestIdentifier = 0;
            this.state.conversations = [];
            yield this.saveToPersistent();
        });
    }
    addToPendingAlerts(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.state.pendingAlerts) {
                this.state.pendingAlerts = [];
            }
            if (!this.state.pendingAlerts.includes(conversation.id)) {
                this.state.pendingAlerts = [
                    conversation.id,
                    ...this.state.pendingAlerts
                ];
                yield this.saveToPersistent();
            }
        });
    }
    getPendingAlerts() {
        if (this.state.pendingAlerts) {
            return this.state.pendingAlerts.reduce((acc, cur) => {
                const conversation = this.getConversationById(cur);
                if (conversation) {
                    return [...acc, conversation];
                }
                else {
                    return acc;
                }
            }, []);
        }
        else {
            return [];
        }
    }
    clearPendingAlert(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state.pendingAlerts && conversation) {
                const idx = this.state.pendingAlerts.indexOf(conversation.id);
                this.state.pendingAlerts.splice(idx, 1);
                yield this.saveToPersistent();
            }
        });
    }
    getConversationById(id) {
        return this.state.conversations.find(c => c.id === id);
    }
    // === Abstract function implementations === //
    generateInitialState() {
        return {
            _id: this.name,
            _rev: "",
            schemaVersion: this.SCHEMA_VERSION,
            latestIdentifier: 0,
            conversations: [],
            pendingAlerts: []
        };
    }
}
exports.Store = Store;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const plugins_1 = __webpack_require__(27);
const Base_1 = __webpack_require__(12);
const metadata_1 = __webpack_require__(11);
const ct_cl_header_1 = __webpack_require__(19);
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const Models_1 = __webpack_require__(5);
const models_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(2);
const Events_1 = __webpack_require__(4);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["LOADING_IMAGE"] = "Loading image..."] = "LOADING_IMAGE";
    I18nKeys[I18nKeys["IMAGE_REFETCH"] = "Download image"] = "IMAGE_REFETCH";
    I18nKeys[I18nKeys["IMAGE_ERROR"] = "Image unable to download, press to retry"] = "IMAGE_ERROR";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTCLThumbnailMetadata {
    static _create() {
        return new metadata_1.Metadata(ct_cl_header_1.CTCLHeader, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTCLThumbnailMetadata._instance = null;
exports.CTCLThumbnailMetadata = CTCLThumbnailMetadata;
class CTCLThumbnail extends Base_1.CTCLComponent {
    constructor() {
        super();
        this._onMediaError = (e) => {
            this._errorIcon = models_1.Icons.COMMON.AlertWarning;
            this._errorMessage = this.translateI18nItem(I18nKeys.IMAGE_ERROR);
            this.hasError = true;
        };
        this._onClickMedia = (e) => __awaiter(this, void 0, void 0, function* () {
            e.stopPropagation();
            yield this.layer.showMediaFullscreen(this.attachment.local);
        });
        this._errorOnClick = () => {
            if (utils_1.isDesktop()) {
                // tslint:disable-next-line no-console
                console.error("Attachments unavailable on desktop.");
                return;
            }
            this.isLoading = true;
            this.hasError = false;
            this._downloadRemoteImage();
        };
        this.setMetadata(CTCLThumbnailMetadata.instance);
    }
    static get is() {
        return "ct-cl-thumbnail";
    }
    connectedCallback() {
        super.connectedCallback();
        this.initialize();
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.attachment && this.chatMessage) {
                if (this.attachment && !this.attachment.local) {
                    this._downloadRemoteImage();
                }
                if (this.attachment && this.attachment.local) {
                    this._loadImageFromSource();
                }
            }
        });
    }
    setupListeners() {
        this.addListener(Events_1.ChatEvents.ChatEntryUpdated, (detail) => __awaiter(this, void 0, void 0, function* () {
            if ((yield this.layer.belongsToCurrentConversation(detail.chatEntry)) && detail.chatEntry.id === this.chatMessage.id) {
                if (!this._finalImageSrc && !this._isGettingBase64) {
                    this.attachment = detail.chatEntry.attachments[0];
                    this._loadImageFromSource();
                }
                else if (this._finalImageSrc) {
                    this.removeEventListener(Events_1.ChatEvents.ChatEntryUpdated);
                }
            }
        }));
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;font-size:1em}:host .attachment{display:block}:host .attachment .loading,:host .attachment .error{display:flex;flex-direction:column;justify-content:center;align-items:center;width:160px;height:100px;color:var(--chat-message-bubble-received-text, #212121)}:host .attachment .loading.mine,:host .attachment .error.mine{color:var(--chat-message-bubble-sent-text, #fff)}:host .attachment .loading.hidden,:host .attachment .error.hidden{display:none}:host .attachment .loading .message,:host .attachment .error .message{display:flex;flex-direction:row;margin:5px 0 0 0}:host .attachment .loading .message .icon,:host .attachment .error .message .icon{margin:0 5px 0 0}:host .attachment .error{cursor:pointer}:host .attachment .image{display:block;margin:0 auto;max-width:200px;border-radius:3px}:host .attachment .image.interactive{cursor:pointer}:host .attachment .image.hidden{display:none}:host .attachment+.content{margin:5px 0 0 0}
        `;
    }
    generateComponentMarkup() {
        if (!this.chatMessage || !this.attachment)
            return null;
        const canInteract = this.layer.hasMediaFullscreenHandler();
        return (window.__CTRender("div", { class: "attachment" },
            this.isLoading
                ? (window.__CTRender("div", { class: `loading ${this.chatMessage.mine ? "mine" : ""}` },
                    window.__CTRender(components_1.CTIcon, { class: "icon", width: "32", height: "32", icon: Models_1.Icons.UI.Attachment }),
                    window.__CTRender("div", { class: "message" },
                        window.__CTRender(components_1.CTIcon, { class: "icon", width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }),
                        this.translateI18nItem(I18nKeys.LOADING_IMAGE))))
                : null,
            this.hasError
                ? (window.__CTRender("div", { class: `error ${this.chatMessage.mine ? "mine" : ""}`, onClick: this._errorOnClick },
                    window.__CTRender(components_1.CTIcon, { class: "icon", width: "32", height: "32", icon: this._errorIcon }),
                    window.__CTRender("div", { class: "message" }, this._errorMessage)))
                : null,
            !this.isLoading && !this.hasError
                ? (window.__CTRender("img", { class: `image ${canInteract ? "interactive" : ""}`, src: this._finalImageSrc, onError: this._onMediaError, onClick: this._onClickMedia }))
                : null));
    }
    // === Event handlers === //
    // === Private functions === //
    _downloadRemoteImage() {
        this.layer.downloadMessageAttachments(this.chatMessage).catch(() => {
            this._errorIcon = models_1.Icons.COMMON.AlertWarning;
            this._errorMessage = this.translateI18nItem(I18nKeys.IMAGE_ERROR);
            this.hasError = true;
            this.isLoading = false;
        });
    }
    _loadImageFromSource() {
        if (!this.attachment || !this.attachment.local) {
            this.isLoading = true;
        }
        else {
            if (utils_1.isDesktop()) {
                this._finalImageSrc = this.attachment.local;
                this.isLoading = false;
                this.onRenderComplete(() => this.emitEvent(Events_1.ChatEvents.ThumbnailLoaded, this.chatMessage), true);
            }
            else {
                this._getBase64();
            }
        }
    }
    _getBase64() {
        return __awaiter(this, void 0, void 0, function* () {
            this._isGettingBase64 = true;
            try {
                this._finalImageSrc = yield plugins_1.getThumbnail(this.attachment.local, 200, 200, 100);
                this.hasError = false;
                this.onRenderComplete(() => this.emitEvent(Events_1.ChatEvents.ThumbnailLoaded, this.chatMessage), true);
            }
            catch (ex) {
                this._errorIcon = models_1.Icons.COMMON.AlertWarning;
                this._errorMessage = this.translateI18nItem(I18nKeys.IMAGE_ERROR);
                this.hasError = true;
            }
            finally {
                this.isLoading = false;
                this._isGettingBase64 = false;
            }
        });
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTCLThumbnail.prototype, "isLoading", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLThumbnail.prototype, "hasError", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: true, default: null })
], CTCLThumbnail.prototype, "chatMessage", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: true, default: null })
], CTCLThumbnail.prototype, "attachment", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTCLThumbnail.prototype, "isLastEntry", void 0);
exports.CTCLThumbnail = CTCLThumbnail;
CTCLThumbnail.register();


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class BasePageEventArgs extends events_1.BaseEventArgs {
    constructor(messageId) {
        super();
        this.messageId = messageId;
    }
}
exports.BasePageEventArgs = BasePageEventArgs;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class ReadPageDetailEventArgs extends events_1.BaseEventArgs {
    constructor(page) {
        super();
        this.page = page;
    }
}
exports.ReadPageDetailEventArgs = ReadPageDetailEventArgs;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class SendNewPageEventArgs extends events_1.BaseEventArgs {
    constructor(page) {
        super();
        this.page = page;
    }
}
exports.SendNewPageEventArgs = SendNewPageEventArgs;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
class SendPageResponseEventArgs extends events_1.BaseEventArgs {
    constructor(pageId, response, sender, isTestPage = false) {
        super();
        this.response = response;
        this.pageId = pageId;
        this.sender = sender;
        this.isTestPage = isTestPage;
    }
}
exports.SendPageResponseEventArgs = SendPageResponseEventArgs;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(9);
var BasePageEventArgs_1 = __webpack_require__(163);
exports.BasePageEventArgs = BasePageEventArgs_1.BasePageEventArgs;
var ReadPageDetailEventArgs_1 = __webpack_require__(164);
exports.ReadPageDetailEventArgs = ReadPageDetailEventArgs_1.ReadPageDetailEventArgs;
var SendNewPageEventArgs_1 = __webpack_require__(165);
exports.SendNewPageEventArgs = SendNewPageEventArgs_1.SendNewPageEventArgs;
var SendPageResponseEventArgs_1 = __webpack_require__(166);
exports.SendPageResponseEventArgs = SendPageResponseEventArgs_1.SendPageResponseEventArgs;
class PagerEvents extends events_1.BaseEvents {
}
// === Events to request actions to be invoked or messages to be sent === //
PagerEvents._Request_SendNewPage = "request-send-new-page";
PagerEvents._Request_ReadPageDetail = "request-read-page-detail";
PagerEvents._Request_OpenClientReadModal = "request-open-client-read-modal";
PagerEvents._Request_OpenBroadcasterReadModal = "request-open-broadcaster-read-modal";
PagerEvents._Request_CheckForPendingPages = "request-check-for-pending-pages";
PagerEvents._Request_CloseSendNewPageModal = "request-close-send-new-page-modal";
// === Events to be handled === //
PagerEvents.NewPageReceived = "new-page-received";
PagerEvents.PageUpdate = "page-update";
PagerEvents.PageResponse = "page-response";
PagerEvents.SendingPageError = "sending-page-error";
PagerEvents.ProcessMamMessages = "process-mam-messages";
PagerEvents.ProcessMamPages = "process-mam-pages";
PagerEvents.RespondedToPage = "responded-to-page";
PagerEvents.RespondedToAllPages = "responded-to-all-pages";
PagerEvents.LogoutRequestConfirmed = "logout-request-confirmed";
PagerEvents.Mute = "mute"; // request to mute sound and stop vibration
exports.PagerEvents = PagerEvents;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ContactResponseType;
(function (ContactResponseType) {
    // tslint:disable no-any
    ContactResponseType[ContactResponseType["Received"] = "received"] = "Received";
    ContactResponseType[ContactResponseType["Response"] = "response"] = "Response";
    // tslint:enable no-any
})(ContactResponseType = exports.ContactResponseType || (exports.ContactResponseType = {}));


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var DeviceType;
(function (DeviceType) {
    // tslint:disable no-any
    DeviceType[DeviceType["Android"] = "android"] = "Android";
    DeviceType[DeviceType["Electron"] = "electon"] = "Electron";
    DeviceType[DeviceType["iOS"] = "ios"] = "iOS";
    // tslint:enable no-any
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var FilterType;
(function (FilterType) {
    // tslint:disable no-any
    FilterType[FilterType["Exclude"] = "exclude"] = "Exclude";
    FilterType[FilterType["Include"] = "get"] = "Include";
    // tslint:enable no-any
})(FilterType = exports.FilterType || (exports.FilterType = {}));


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var Icons;
(function (Icons) {
    Icons.ICOMOON = {
        CheckBoxEmpty: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 0h-768c-70.4 0-128 57.6-128 128v768c0 70.4 57.6 128 128 128h768c70.4 0 128-57.6 128-128v-768c0-70.4-57.6-128-128-128zM896 896h-768v-768h768v768z"
            ]
        },
        CheckBoxChecked: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 0h-768c-70.4 0-128 57.6-128 128v768c0 70.4 57.6 128 128 128h768c70.4 0 128-57.6 128-128v-768c0-70.4-57.6-128-128-128zM448 794.51l-237.254-237.256 90.51-90.508 146.744 146.744 306.746-306.746 90.508 90.51-397.254 397.256z"
            ]
        },
        CheckCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M733.714 419.429q0-16-10.286-26.286l-52-51.429q-10.857-10.857-25.714-10.857t-25.714 10.857l-233.143 232.571-129.143-129.143q-10.857-10.857-25.714-10.857t-25.714 10.857l-52 51.429q-10.286 10.286-10.286 26.286 0 15.429 10.286 25.714l206.857 206.857q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l310.286-310.286q10.286-10.286 10.286-25.714zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        CrossCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M656.571 641.143q0-14.857-10.857-25.714l-103.429-103.429 103.429-103.429q10.857-10.857 10.857-25.714 0-15.429-10.857-26.286l-51.429-51.429q-10.857-10.857-26.286-10.857-14.857 0-25.714 10.857l-103.429 103.429-103.429-103.429q-10.857-10.857-25.714-10.857-15.429 0-26.286 10.857l-51.429 51.429q-10.857 10.857-10.857 26.286 0 14.857 10.857 25.714l103.429 103.429-103.429 103.429q-10.857 10.857-10.857 25.714 0 15.429 10.857 26.286l51.429 51.429q10.857 10.857 26.286 10.857 14.857 0 25.714-10.857l103.429-103.429 103.429 103.429q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l51.429-51.429q10.857-10.857 10.857-26.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        ExclamationCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 0c-282.77 0-512 229.23-512 512s229.23 512 512 512 512-229.23 512-512-229.23-512-512-512zM576 832h-128v-128h128v128zM576 576h-128v-384h128v384z"
            ]
        },
        QuestionCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 0c-282.77 0-512 229.23-512 512s229.23 512 512 512 512-229.23 512-512-229.23-512-512-512zM512 832c-35.346 0-64-28.654-64-64s28.654-64 64-64 64 28.654 64 64-28.654 64-64 64zM617.538 504.158c-39.112 24.57-57.538 38.114-57.538 56.092v32c0 26.51-21.49 48-48 48s-48-21.49-48-48v-32c0-33.618 12.964-63.854 38.532-89.87 18.864-19.194 41.778-33.59 63.936-47.512 45.564-28.624 65.532-43.978 65.532-70.868 0-29.252-16.88-48.788-31.042-60.026-22.734-18.040-54.328-27.974-88.958-27.974-52.534 0-99.792 35.082-114.924 85.314-7.648 25.382-34.422 39.758-59.806 32.114-25.382-7.648-39.76-34.422-32.114-59.806 13.112-43.52 40.398-82.63 76.832-110.124 37.71-28.456 82.668-43.498 130.012-43.498 56.208 0 108.994 17.322 148.63 48.776 43.444 34.474 67.37 82.496 67.37 135.224 0 82.76-63.846 122.872-110.462 152.158z"
            ]
        },
        Mute: {
            viewBox: "0 0 16 16",
            paths: [
                "M0 5h3l5-5v16l-5-5h-3v-6zM14.326 8l1.674 1.674v1.326h-1.326l-1.674-1.674-1.674 1.674h-1.326v-1.326l1.674-1.674-1.674-1.674v-1.326h1.326l1.674 1.674 1.674-1.674h1.326v1.326l-1.674 1.674z"
            ]
        }
    };
    Icons.FONTAWESOME = {
        BellFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M521.143 969.143c0-5.143-4-9.143-9.143-9.143-45.143 0-82.286-37.143-82.286-82.286 0-5.143-4-9.143-9.143-9.143s-9.143 4-9.143 9.143c0 55.429 45.143 100.571 100.571 100.571 5.143 0 9.143-4 9.143-9.143zM987.429 804.571c0 40-33.143 73.143-73.143 73.143h-256c0 80.571-65.714 146.286-146.286 146.286s-146.286-65.714-146.286-146.286h-256c-40 0-73.143-33.143-73.143-73.143 84.571-71.429 182.857-199.429 182.857-475.429 0-109.714 90.857-229.714 242.286-252-2.857-6.857-4.571-14.286-4.571-22.286 0-30.286 24.571-54.857 54.857-54.857s54.857 24.571 54.857 54.857c0 8-1.714 15.429-4.571 22.286 151.429 22.286 242.286 142.286 242.286 252 0 276 98.286 404 182.857 475.429z"
            ]
        },
        CircleNotch: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1005.714 512c0 272.571-221.143 493.714-493.714 493.714s-493.714-221.143-493.714-493.714c0-248 182.857-453.143 420.571-488.571v130.286c-166.857 33.714-292.571 181.714-292.571 358.286 0 201.714 164 365.714 365.714 365.714s365.714-164 365.714-365.714c0-176.571-125.714-324.571-292.571-358.286v-130.286c237.714 35.429 420.571 240.571 420.571 488.571z"
            ]
        },
        CheckBoxEmpty: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M640 146.286h-475.429q-37.714 0-64.571 26.857t-26.857 64.571v475.429q0 37.714 26.857 64.571t64.571 26.857h475.429q37.714 0 64.571-26.857t26.857-64.571v-475.429q0-37.714-26.857-64.571t-64.571-26.857zM804.571 237.714v475.429q0 68-48.286 116.286t-116.286 48.286h-475.429q-68 0-116.286-48.286t-48.286-116.286v-475.429q0-68 48.286-116.286t116.286-48.286h475.429q68 0 116.286 48.286t48.286 116.286z"
            ]
        },
        CheckBoxChecked: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M391.429 742.286l350.857-350.857q10.857-10.857 10.857-25.714t-10.857-25.714l-58.286-58.286q-10.857-10.857-25.714-10.857t-25.714 10.857l-266.857 266.857-120.571-120.571q-10.857-10.857-25.714-10.857t-25.714 10.857l-58.286 58.286q-10.857 10.857-10.857 25.714t10.857 25.714l204.571 204.571q10.857 10.857 25.714 10.857t25.714-10.857zM877.714 237.714v548.571q0 68-48.286 116.286t-116.286 48.286h-548.571q-68 0-116.286-48.286t-48.286-116.286v-548.571q0-68 48.286-116.286t116.286-48.286h548.571q68 0 116.286 48.286t48.286 116.286z"
            ]
        },
        CheckCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M733.714 419.429q0-16-10.286-26.286l-52-51.429q-10.857-10.857-25.714-10.857t-25.714 10.857l-233.143 232.571-129.143-129.143q-10.857-10.857-25.714-10.857t-25.714 10.857l-52 51.429q-10.286 10.286-10.286 26.286 0 15.429 10.286 25.714l206.857 206.857q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l310.286-310.286q10.286-10.286 10.286-25.714zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        ChevronLeft: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M669.143 172l-303.429 303.429 303.429 303.429q10.857 10.857 10.857 25.714t-10.857 25.714l-94.857 94.857q-10.857 10.857-25.714 10.857t-25.714-10.857l-424-424q-10.857-10.857-10.857-25.714t10.857-25.714l424-424q10.857-10.857 25.714-10.857t25.714 10.857l94.857 94.857q10.857 10.857 10.857 25.714t-10.857 25.714z"
            ]
        },
        Cross: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M741.714 755.429q0 22.857-16 38.857l-77.714 77.714q-16 16-38.857 16t-38.857-16l-168-168-168 168q-16 16-38.857 16t-38.857-16l-77.714-77.714q-16-16-16-38.857t16-38.857l168-168-168-168q-16-16-16-38.857t16-38.857l77.714-77.714q16-16 38.857-16t38.857 16l168 168 168-168q16-16 38.857-16t38.857 16l77.714 77.714q16 16 16 38.857t-16 38.857l-168 168 168 168q16 16 16 38.857z"
            ]
        },
        CrossCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M656.571 641.143q0-14.857-10.857-25.714l-103.429-103.429 103.429-103.429q10.857-10.857 10.857-25.714 0-15.429-10.857-26.286l-51.429-51.429q-10.857-10.857-26.286-10.857-14.857 0-25.714 10.857l-103.429 103.429-103.429-103.429q-10.857-10.857-25.714-10.857-15.429 0-26.286 10.857l-51.429 51.429q-10.857 10.857-10.857 26.286 0 14.857 10.857 25.714l103.429 103.429-103.429 103.429q-10.857 10.857-10.857 25.714 0 15.429 10.857 26.286l51.429 51.429q10.857 10.857 26.286 10.857 14.857 0 25.714-10.857l103.429-103.429 103.429 103.429q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l51.429-51.429q10.857-10.857 10.857-26.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        Ellipsis: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M219.429 420.571v109.714c0 30.286-24.571 54.857-54.857 54.857h-109.714c-30.286 0-54.857-24.571-54.857-54.857v-109.714c0-30.286 24.571-54.857 54.857-54.857h109.714c30.286 0 54.857 24.571 54.857 54.857zM512 420.571v109.714c0 30.286-24.571 54.857-54.857 54.857h-109.714c-30.286 0-54.857-24.571-54.857-54.857v-109.714c0-30.286 24.571-54.857 54.857-54.857h109.714c30.286 0 54.857 24.571 54.857 54.857zM804.571 420.571v109.714c0 30.286-24.571 54.857-54.857 54.857h-109.714c-30.286 0-54.857-24.571-54.857-54.857v-109.714c0-30.286 24.571-54.857 54.857-54.857h109.714c30.286 0 54.857 24.571 54.857 54.857z"
            ]
        },
        ExclamationCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M438.857 73.143q119.429 0 220.286 58.857t159.714 159.714 58.857 220.286-58.857 220.286-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857zM512 785.714v-108.571q0-8-5.143-13.429t-12.571-5.429h-109.714q-7.429 0-13.143 5.714t-5.714 13.143v108.571q0 7.429 5.714 13.143t13.143 5.714h109.714q7.429 0 12.571-5.429t5.143-13.429zM510.857 589.143l10.286-354.857q0-6.857-5.714-10.286-5.714-4.571-13.714-4.571h-125.714q-8 0-13.714 4.571-5.714 3.429-5.714 10.286l9.714 354.857q0 5.714 5.714 10t13.714 4.286h105.714q8 0 13.429-4.286t6-10z"
            ]
        },
        InfoCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 786.286v-91.429c0-10.286-8-18.286-18.286-18.286h-54.857v-292.571c0-10.286-8-18.286-18.286-18.286h-182.857c-10.286 0-18.286 8-18.286 18.286v91.429c0 10.286 8 18.286 18.286 18.286h54.857v182.857h-54.857c-10.286 0-18.286 8-18.286 18.286v91.429c0 10.286 8 18.286 18.286 18.286h256c10.286 0 18.286-8 18.286-18.286zM512 274.286v-91.429c0-10.286-8-18.286-18.286-18.286h-109.714c-10.286 0-18.286 8-18.286 18.286v91.429c0 10.286 8 18.286 18.286 18.286h109.714c10.286 0 18.286-8 18.286-18.286zM877.714 512c0 242.286-196.571 438.857-438.857 438.857s-438.857-196.571-438.857-438.857 196.571-438.857 438.857-438.857 438.857 196.571 438.857 438.857z"
            ]
        },
        Paperclip: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M802.286 791.429q0 66.857-45.143 112t-112 45.143q-77.143 0-134.286-57.143l-444-443.429q-64.571-65.714-64.571-154.857 0-90.857 62.857-154.286t153.714-63.429q90.286 0 156 64.571l345.714 346.286q5.714 5.714 5.714 12.571 0 9.143-17.429 26.571t-26.571 17.429q-7.429 0-13.143-5.714l-346.286-346.857q-45.143-44-103.429-44-60.571 0-102.286 42.857t-41.714 103.429q0 60 43.429 103.429l443.429 444q36 36 82.857 36 36.571 0 60.571-24t24-60.571q0-46.857-36-82.857l-332-332q-14.857-13.714-34.286-13.714-16.571 0-27.429 10.857t-10.857 27.429q0 18.286 14.286 33.714l234.286 234.286q5.714 5.714 5.714 12.571 0 9.143-17.714 26.857t-26.857 17.714q-6.857 0-12.571-5.714l-234.286-234.286q-36-34.857-36-85.143 0-46.857 32.571-79.429t79.429-32.571q50.286 0 85.143 36l332 332q57.143 56 57.143 134.286z"
            ]
        },
        PlusSign: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M804.571 420.571v109.714q0 22.857-16 38.857t-38.857 16h-237.714v237.714q0 22.857-16 38.857t-38.857 16h-109.714q-22.857 0-38.857-16t-16-38.857v-237.714h-237.714q-22.857 0-38.857-16t-16-38.857v-109.714q0-22.857 16-38.857t38.857-16h237.714v-237.714q0-22.857 16-38.857t38.857-16h109.714q22.857 0 38.857 16t16 38.857v237.714h237.714q22.857 0 38.857 16t16 38.857z"
            ]
        },
        QuestionCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 786.286v-109.714q0-8-5.143-13.143t-13.143-5.143h-109.714q-8 0-13.143 5.143t-5.143 13.143v109.714q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143zM658.286 402.286q0-50.286-31.714-93.143t-79.143-66.286-97.143-23.429q-138.857 0-212 121.714-8.571 13.714 4.571 24l75.429 57.143q4 3.429 10.857 3.429 9.143 0 14.286-6.857 30.286-38.857 49.143-52.571 19.429-13.714 49.143-13.714 27.429 0 48.857 14.857t21.429 33.714q0 21.714-11.429 34.857t-38.857 25.714q-36 16-66 49.429t-30 71.714v20.571q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143q0-10.857 12.286-28.286t31.143-28.286q18.286-10.286 28-16.286t26.286-20 25.429-27.429 16-34.571 7.143-46.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        TrashCan: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M292.571 420.571v329.143q0 8-5.143 13.143t-13.143 5.143h-36.571q-8 0-13.143-5.143t-5.143-13.143v-329.143q0-8 5.143-13.143t13.143-5.143h36.571q8 0 13.143 5.143t5.143 13.143zM438.857 420.571v329.143q0 8-5.143 13.143t-13.143 5.143h-36.571q-8 0-13.143-5.143t-5.143-13.143v-329.143q0-8 5.143-13.143t13.143-5.143h36.571q8 0 13.143 5.143t5.143 13.143zM585.143 420.571v329.143q0 8-5.143 13.143t-13.143 5.143h-36.571q-8 0-13.143-5.143t-5.143-13.143v-329.143q0-8 5.143-13.143t13.143-5.143h36.571q8 0 13.143 5.143t5.143 13.143zM658.286 834.286v-541.714h-512v541.714q0 12.571 4 23.143t8.286 15.429 6 4.857h475.429q1.714 0 6-4.857t8.286-15.429 4-23.143zM274.286 219.429h256l-27.429-66.857q-4-5.143-9.714-6.286h-181.143q-5.714 1.143-9.714 6.286zM804.571 237.714v36.571q0 8-5.143 13.143t-13.143 5.143h-54.857v541.714q0 47.429-26.857 82t-64.571 34.571h-475.429q-37.714 0-64.571-33.429t-26.857-80.857v-544h-54.857q-8 0-13.143-5.143t-5.143-13.143v-36.571q0-8 5.143-13.143t13.143-5.143h176.571l40-95.429q8.571-21.143 30.857-36t45.143-14.857h182.857q22.857 0 45.143 14.857t30.857 36l40 95.429h176.571q8 0 13.143 5.143t5.143 13.143z"
            ]
        },
        WarningTriangle: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 785.714v-108.571c0-10.286-8-18.857-18.286-18.857h-109.714c-10.286 0-18.286 8.571-18.286 18.857v108.571c0 10.286 8 18.857 18.286 18.857h109.714c10.286 0 18.286-8.571 18.286-18.857zM584 572l10.286-262.286c0-3.429-1.714-8-5.714-10.857-3.429-2.857-8.571-6.286-13.714-6.286h-125.714c-5.143 0-10.286 3.429-13.714 6.286-4 2.857-5.714 8.571-5.714 12l9.714 261.143c0 7.429 8.571 13.143 19.429 13.143h105.714c10.286 0 18.857-5.714 19.429-13.143zM576 38.286l438.857 804.571c12.571 22.286 12 49.714-1.143 72s-37.143 36-62.857 36h-877.714c-25.714 0-49.714-13.714-62.857-36s-13.714-49.714-1.143-72l438.857-804.571c12.571-23.429 37.143-38.286 64-38.286s51.429 14.857 64 38.286z"
            ]
        },
        Wifi: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 870.286c-14.857 0-94.857-80-94.857-95.429 0-28 73.143-43.429 94.857-43.429s94.857 15.429 94.857 43.429c0 15.429-80 95.429-94.857 95.429zM739.429 715.429c-8 0-70.286-57.143-154.286-57.143-84.571 0-145.714 57.143-154.286 57.143-13.714 0-96.571-82.286-96.571-96 0-5.143 2.286-9.714 5.714-13.143 61.143-60.571 160.571-94.286 245.143-94.286s184 33.714 245.143 94.286c3.429 3.429 5.714 8 5.714 13.143 0 13.714-82.857 96-96.571 96zM895.429 560c-4.571 0-9.714-2.286-13.143-4.571-94.286-73.143-173.714-116.571-297.143-116.571-172.571 0-304 121.143-310.286 121.143-13.143 0-95.429-82.286-95.429-96 0-4.571 2.286-9.143 5.714-12.571 102.286-102.286 256.571-158.857 400-158.857s297.714 56.571 400 158.857c3.429 3.429 5.714 8 5.714 12.571 0 13.714-82.286 96-95.429 96zM1050.286 405.143c-4.571 0-9.143-2.286-12.571-5.143-132-116-274.286-180.571-452.571-180.571s-320.571 64.571-452.571 180.571c-3.429 2.857-8 5.143-12.571 5.143-13.143 0-96-82.286-96-96 0-5.143 2.286-9.714 5.714-13.143 144.571-143.429 353.143-222.857 555.429-222.857s410.857 79.429 555.429 222.857c3.429 3.429 5.714 8 5.714 13.143 0 13.714-82.857 96-96 96z"
            ]
        }
    };
})(Icons = exports.Icons || (exports.Icons = {}));


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var ResponseStatus;
(function (ResponseStatus) {
    // tslint:disable no-any
    ResponseStatus[ResponseStatus["NotReceivedNotification"] = "not-received"] = "NotReceivedNotification";
    ResponseStatus[ResponseStatus["Received"] = "received"] = "Received";
    ResponseStatus[ResponseStatus["Displayed"] = "displayed"] = "Displayed";
    ResponseStatus[ResponseStatus["Unable"] = "unable"] = "Unable";
    ResponseStatus[ResponseStatus["Attending"] = "attending"] = "Attending";
    ResponseStatus[ResponseStatus["Acknowledged"] = "acknowledged"] = "Acknowledged";
    ResponseStatus[ResponseStatus["AutoDismissed"] = "auto-dismissed"] = "AutoDismissed";
    // tslint:enable no-any
})(ResponseStatus = exports.ResponseStatus || (exports.ResponseStatus = {}));


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
var DeviceType_1 = __webpack_require__(169);
exports.DeviceType = DeviceType_1.DeviceType;
var Icons_1 = __webpack_require__(171);
exports.Icons = Icons_1.Icons;
var ResponseStatus_1 = __webpack_require__(172);
exports.ResponseStatus = ResponseStatus_1.ResponseStatus;
var Contacts_1 = __webpack_require__(168);
exports.ContactResponseType = Contacts_1.ContactResponseType;
var FilterType_1 = __webpack_require__(170);
exports.FilterType = FilterType_1.FilterType;
// tslint:disable no-any
var TimerDirection;
(function (TimerDirection) {
    TimerDirection[TimerDirection["Up"] = "Up"] = "Up";
    TimerDirection[TimerDirection["Down"] = "Down"] = "Down";
})(TimerDirection = exports.TimerDirection || (exports.TimerDirection = {}));


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const events_1 = __webpack_require__(9);
const components_1 = __webpack_require__(3);
class CTAlertModalManager extends base_1.CTLayerComponent {
    static get is() {
        return "ct-alert-modal-manager";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents._Request_RaiseAlert, (e) => this.raiseAlert(e));
        this.addListener(events_1.BaseEvents._Request_CloseAlert, (e) => this.dismissAlertById(e));
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:none;width:100%;height:100%;background:var(--modal-overlay, rgba(0,0,0,0.5));position:fixed;top:0;z-index:99999;padding:20px;overflow:auto}:host .alerts{display:flex;width:100%;max-width:420px;margin:auto;position:relative}:host([alerts-to-show]){display:flex}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "alerts" }, this.alerts.map((alert, idx) => window.__CTRender(components_1.CTAlertModal, { id: alert.id || this.defaultAlerts.generateId(), raisedOn: alert.raisedOn, priority: alert.priority, type: alert.type, title: alert.title, body: alert.body, buttons: alert.buttons, remaining: this.alerts.length, positionInStack: idx, showLoadingAnimation: alert.showLoadingAnimation }))));
    }
    // === Public functions === //
    raiseAlert(alert) {
        if (!alert)
            return;
        if (alert.buttons) {
            for (const b of alert.buttons) {
                if (!b.action) {
                    b.action = () => this.dismissAlert();
                }
                else {
                    const buttonAction = b.action.bind(this);
                    b.action = (e) => {
                        buttonAction(e);
                        this.dismissAlert();
                    };
                }
            }
        }
        this.alerts = [...this.alerts, alert];
        this.alertsToShow = true;
    }
    dismissAlert(index = 0) {
        this.alerts.splice(index, 1);
        if (this.alerts.length === 0)
            this.alertsToShow = false;
        else {
            this.alerts = this.alerts.map((alert, idx) => {
                alert.remaining = this.alerts.length;
                return alert;
            });
        }
    }
    dismissAlertById(id) {
        const idx = this.alerts.findIndex(x => x.id === id);
        if (idx !== -1) {
            this.dismissAlert(idx);
        }
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTAlertModalManager.prototype, "alertsToShow", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTAlertModalManager.prototype, "alerts", void 0);
exports.CTAlertModalManager = CTAlertModalManager;
CTAlertModalManager.register();


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const Icons_1 = __webpack_require__(47);
const components_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(8);
class CTAlertModal extends base_1.CTLayerComponent {
    static get is() {
        return "ct-alert-modal";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:none;width:100%;height:100%;flex-direction:column;background-color:var(--modal-bg, #fff)}:host .alert-dialog{overflow:hidden}:host .alert-dialog .remaining{position:absolute;width:35px;height:35px;background-color:red;border-radius:50%;text-align:center;line-height:35px;color:white;right:-5%;top:-5%}:host .alert-dialog .title{display:flex;justify-content:center;text-align:center;font-size:1em;text-transform:uppercase;margin:0 auto;padding:10px}:host .alert-dialog .body{display:flex;justify-content:center;text-align:center;align-items:flex-start;font-size:1.333em;font-weight:300;padding:50px}:host .alert-dialog .body ct-icon{flex:none;margin:3px 10px 0 0}:host .alert-dialog .buttons{padding:10px 5px;flex:none;display:flex;flex-wrap:wrap;flex-direction:row;justify-content:space-between}:host .alert-dialog .buttons ct-button{flex:1;margin:0 5px;border-radius:0}:host .alert-dialog .buttons ct-button.overflex{flex-basis:100%}:host .alert-dialog .buttons ct-button.overflex+ct-button{margin-top:10px}:host .alert-dialog.error .title{background-color:var(--alert-error-bg, #c80031);color:var(--alert-error-text, #fff)}:host .alert-dialog.info .title{background-color:var(--alert-info-bg, #22b1c8);color:var(--alert-info-text, #fff)}:host .alert-dialog.question .title{background-color:var(--alert-question-bg, #22b1c8);color:var(--alert-question-text, #fff)}:host .alert-dialog.success .title{background-color:var(--alert-success-bg, #22b1c8);color:var(--alert-success-text, #fff)}:host([showing]){display:flex;z-index:10}:host([stacked]){display:flex;position:absolute;bottom:5px;right:5px;z-index:1}:host([stacked]):before{content:'';display:block;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.25)}
        `;
    }
    generateComponentMarkup() {
        const loadingSpinnerIcon = Icons_1.Icons.COMMON.LoadingSpinner;
        const offset = (this.positionInStack * 5);
        this.style.right = `${offset}px`;
        this.style.bottom = `${offset}px`;
        this.style.zIndex = `${this.remaining - this.positionInStack}`;
        if (this.positionInStack === 0)
            this.showing = true;
        else
            this.stacked = true;
        return (window.__CTRender("div", { "alert-id": this.id, class: `alert-dialog ${this.type}` },
            this.remaining > 1 && this.showing
                ? window.__CTRender("div", { class: "remaining" }, this.remaining)
                : null,
            window.__CTRender("div", { class: "title" }, this.renderHtml(this.title)),
            window.__CTRender("div", { class: "body" },
                renderUtils_1.renderIf(this.showLoadingAnimation, window.__CTRender(components_1.CTIcon, { class: "loading", width: "18", height: "18", spin: true, icon: loadingSpinnerIcon })),
                window.__CTRender("div", { class: "message" }, this.renderHtml(this.body))),
            renderUtils_1.renderIf(!!this.buttons && this.buttons.length > 0, (window.__CTRender("div", { class: "buttons" }, this.buttons.map((btn, idx) => (window.__CTRender(components_1.CTButton, { type: btn.type, class: `${this.buttons.length > 2 ? "overflex" : ""} ${this.buttons.length === 2 && idx === 0 ? "right-border" : ""}`, onClick: e => btn.action(e.target.textContent) }, btn.text))))))));
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTAlertModal.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: 0 })
], CTAlertModal.prototype, "id", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "raisedOn", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "priority", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "info" })
], CTAlertModal.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTAlertModal.prototype, "title", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTAlertModal.prototype, "body", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTAlertModal.prototype, "buttons", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "remaining", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "positionInStack", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTAlertModal.prototype, "showLoadingAnimation", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTAlertModal.prototype, "stacked", void 0);
exports.CTAlertModal = CTAlertModal;
CTAlertModal.register();


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
class CTAvatarTile extends base_1.CTLayerComponent {
    static get is() {
        return "ct-avatar-tile";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host .avatar-tile{position:relative;display:flex;align-items:center;padding:var(--avatar-tile-padding, 6px 10px);color:var(--default-font-color, #212121);background-color:var(--list-item-bg, #fff);border-bottom:var(--list-item-border, 1px solid #ddd)}:host .avatar-tile .avatar{flex:none;display:flex;flex-direction:column;justify-content:center;align-items:center}:host .avatar-tile .avatar ::slotted(*){margin:0 10px 0 0}@media only screen and (min-width: 960px){:host .avatar-tile .avatar{flex:0 0 10%;justify-content:flex-start;flex-direction:row;flex-basis:6vw}}:host .avatar-tile .detail{flex:1 1 auto;display:flex;flex-direction:column;overflow:hidden}@media only screen and (min-width: 960px){:host .avatar-tile .detail{flex-direction:row}:host .avatar-tile .detail slot{display:flex;flex:1}:host .avatar-tile .detail slot::slotted(.name){flex:1 1 20% !important;align-items:center;margin:auto 0}:host .avatar-tile .detail slot::slotted(.job-title),:host .avatar-tile .detail slot::slotted(.group){display:flex;flex:1 0 35%;align-items:center}}:host .avatar-tile.hatched{background-size:5px 5px;background-image:linear-gradient(45deg, rgba(0,0,0,0) 46%, #d8d8d8 49%, #d8d8d8 51%, rgba(0,0,0,0) 55%)}
        `;
    }
    generateComponentMarkup() {
        const classes = [
            "avatar-tile"
        ];
        if (this.hatched)
            classes.push("hatched");
        const styles = renderUtils_1.buildStyles({
            height: this.height || "auto"
        });
        return (window.__CTRender("div", { class: classes.join(" "), style: styles },
            window.__CTRender("div", { class: "avatar" },
                window.__CTRender("slot", { name: "avatar" })),
            window.__CTRender("div", { class: "detail", style: this.detailStyle },
                window.__CTRender("slot", null)),
            window.__CTRender("slot", { name: "additional" })));
    }
}
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTAvatarTile.prototype, "height", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTAvatarTile.prototype, "hatched", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: {} })
], CTAvatarTile.prototype, "detailStyle", void 0);
exports.CTAvatarTile = CTAvatarTile;
CTAvatarTile.register();


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const Logger_1 = __webpack_require__(17);
class CTDebugger extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        // === Attribute properties === //
        // === End properties === //
        this.ALL_LOGGERS_TOKEN = "_all_";
        this._loggingTypes = Object.values(Logger_1.LoggerTypes).filter((x, idx) => idx % 2 === 0);
        this._selectedLoggingTypes = [];
    }
    static get is() {
        return "ct-debugger";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._selectedLoggingTypes = this.layer.logger.getTypes();
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host .debugger .section{border:1px dotted var(--default-border-color, #ddd);border-radius:8px;padding:10px}:host .debugger .section .heading{font-size:1.333em;font-weight:600;margin:0 0 10px 0}:host .debugger .section .buttons{display:flex;margin:10px 0}:host .debugger .section .buttons .button+.button{margin:0 0 0 5px}:host .debugger .section.logging .options{display:flex;flex-wrap:wrap}:host .debugger .section.logging .options .option{width:160px}:host .debugger .section+.section{margin:10px 0 0 0}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "debugger" },
            this._renderLoggingOptions(),
            this._renderResetOptions()));
    }
    _renderLoggingOptions() {
        const hasInitialTypes = this.layer.logger.hasInitialTypes();
        return (window.__CTRender("div", { class: "section logging" },
            window.__CTRender("div", { class: "heading" }, "Logging"),
            window.__CTRender("div", { class: "buttons" },
                window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", onClick: this._enableAllLogging.bind(this) }, "All"),
                window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", onClick: this._disableAllLogging.bind(this) }, "None"),
                hasInitialTypes && window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", onClick: this._resetAllLogging.bind(this) }, "Reset")),
            window.__CTRender("div", { class: "options" }, this._loggingTypes.map(x => {
                const isSelected = this._selectedLoggingTypes.includes(x) || this._selectedLoggingTypes.includes(this.ALL_LOGGERS_TOKEN);
                return (window.__CTRender("div", { key: x, class: "option" },
                    window.__CTRender("label", { htmlFor: x },
                        window.__CTRender("input", { type: "checkbox", id: x, checked: isSelected, onChange: () => this._onChangeLoggingType(x) }),
                        " ",
                        x)));
            }))));
    }
    _renderResetOptions() {
        return (window.__CTRender("div", { class: "section reset" },
            window.__CTRender("div", { class: "heading" }, "App reset"),
            window.__CTRender("div", { class: "buttons" },
                window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", onClick: this._reloadApp.bind(this) }, "Reload"),
                window.__CTRender(components_1.CTButton, { class: "button", type: "secondary", width: "auto", onClick: this._clearAllAppData.bind(this) }, "Clear local data"))));
    }
    // === Event handlers === //
    _enableAllLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.layer.setSupportLoggingTypes([...this._loggingTypes]);
            this._updateLoggers();
        });
    }
    _disableAllLogging() {
        this.layer.setSupportLoggingTypes([]);
        this._updateLoggers();
    }
    _resetAllLogging() {
        this.layer.resetSupportLogging();
        this._updateLoggers();
    }
    _onChangeLoggingType(type) {
        if (this._selectedLoggingTypes.includes(this.ALL_LOGGERS_TOKEN)) {
            this._selectedLoggingTypes = [...this._loggingTypes];
        }
        const newTypes = this._selectedLoggingTypes.includes(type)
            ? this._selectedLoggingTypes.filter(x => x !== type)
            : [...this._selectedLoggingTypes, type];
        this.layer.setSupportLoggingTypes(newTypes);
        this._updateLoggers();
    }
    _reloadApp() {
        this.layer.showWaitingMessage("Reloading...");
        window.location.reload();
    }
    _clearAllAppData() {
        this.layer.showWaitingMessage("Clearing all data...");
        this.layer.clearAllData()
            .then(() => {
            window.location.reload();
        });
    }
    // === Private functions === //
    _updateLoggers() {
        this._selectedLoggingTypes = this.layer.logger.getTypes();
        this.forceRedraw();
    }
}
exports.CTDebugger = CTDebugger;
CTDebugger.register();


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const ct_xmpp_client_1 = __webpack_require__(21);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
class CTFilePicker extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.btnClick = () => __awaiter(this, void 0, void 0, function* () {
            const files = yield ct_xmpp_client_1.CtXmppClient.pickFile({ mimeTypes: this.fileTypes });
            if (this.callback) {
                this.callback(files);
            }
        });
    }
    static get is() {
        return "ct-file-picker";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return ``;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", null,
            window.__CTRender(components_1.CTButton, { icon: models_1.Icons.COMMON.PlusSign, iconColor: "#fff", onClick: this.btnClick })));
    }
}
__decorate([
    base_1.prop({ type: Array, attribute: true, default: ["image/jpeg", "image/png", "image/gif"] })
], CTFilePicker.prototype, "fileTypes", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTFilePicker.prototype, "callback", void 0);
exports.CTFilePicker = CTFilePicker;
CTFilePicker.register();


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const metadata_1 = __webpack_require__(11);
const ct_group_avatar_1 = __webpack_require__(60);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["MEMBERS"] = "Members: "] = "MEMBERS";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTGroupTileMetadata {
    static _create() {
        return new metadata_1.Metadata(CTGroupTile, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTGroupTileMetadata._instance = null;
exports.CTGroupTileMetadata = CTGroupTileMetadata;
class CTGroupTile extends base_1.CTLayerComponent {
    // === End properties === //
    constructor() {
        super();
        this.setMetadata(CTGroupTileMetadata.instance);
    }
    static get is() {
        return "ct-group-tile";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host .name{flex:1 1 auto;font-size:1.333em;color:var(--default-font-color, #212121);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}:host .job-title,:host .group{color:var(--subtle-font-color, #828688);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}:host .group{font-style:italic}:host .empty{color:#E1E1E1}
        `;
    }
    generateComponentMarkup() {
        if (!this.group)
            return;
        return (window.__CTRender(components_1.CTAvatarTile, { height: this.height, showAvatar: false, detailStyle: this.detailStyle },
            this.showIcon && (window.__CTRender(ct_group_avatar_1.CTGroupAvatar, { slot: "avatar", size: 40 })),
            window.__CTRender("div", { class: "name" }, this.group.name),
            window.__CTRender("slot", { name: "additional" })));
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: true })
], CTGroupTile.prototype, "showIcon", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false })
], CTGroupTile.prototype, "group", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTGroupTile.prototype, "height", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: {} })
], CTGroupTile.prototype, "detailStyle", void 0);
exports.CTGroupTile = CTGroupTile;
CTGroupTile.register();


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
class CTGrowingTextbox extends base_1.CTLayerComponent {
    // === End properties === //
    constructor() {
        super();
        this._textbox = null;
        this._sizeTest = null;
        this._htmlStripper = null;
        this._messageContent = "";
        this._sizeTestContent = "";
        this._isMaxSizeMessageTextBox = false;
        this._setupResizeWatcher();
    }
    static get is() {
        return "ct-growing-textbox";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.onRenderComplete(() => this._updateTextboxHeight(), true);
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex}:host .growing-textbox{display:flex;flex-direction:column;flex:1 1 auto;background-color:var(--default-bg-color-light, #fff);overflow:hidden;border:var(--secondary-border, 1px solid #ddd);border-radius:10px}:host .growing-textbox .textbox{flex:1 1 auto;font-family:inherit;font-size:inherit;font-weight:inherit;min-height:32px;overflow:hidden;padding:6px 10px;resize:none;outline:none;border:var(--secondary-border, 1px solid #ddd);will-change:transform;color:var(--tertiary-font-color, inherit)}:host .growing-textbox .textbox.animate-height{transition:height 0.1s ease-out}:host .growing-textbox .textbox.transparent{background:transparent;border:0;padding:7px 10px}:host .growing-textbox .textbox.max-size{overflow:auto}:host .growing-textbox .textbox.size-test{position:fixed;top:-10000px;left:-10000px;height:auto;white-space:pre-wrap}:host .growing-textbox .textbox::placeholder{color:var(--select-placeholder-color, #828688)}:host .growing-textbox .textbox::-webkit-input-placeholder{color:var(--select-placeholder-color, #828688)}
        `;
    }
    generateComponentMarkup() {
        const textareaClasses = [
            "textbox",
            "animate-height"
        ];
        if (this.transparent)
            textareaClasses.push("transparent");
        if (this._isMaxSizeMessageTextBox)
            textareaClasses.push("max-size");
        const textareaStyles = renderUtils_1.buildStyles({
            "max-height": `${this.maxHeight || 200}px`
        });
        if (this.height !== null)
            textareaStyles.height = `${this.height}px`;
        return (window.__CTRender("div", { class: "growing-textbox" },
            window.__CTRender("textarea", { id: "textbox", class: textareaClasses.join(" "), style: textareaStyles, rows: 1, value: this.value, placeholder: this.placeholder, disabled: this.disabled, maxLength: this.maxLength, onFocus: this._onFocus.bind(this), onInput: this._onChange.bind(this), onKeydown: e => this._onKeyDown(e) }),
            window.__CTRender("div", { id: "size-test", class: "textbox size-test" }, this.renderHtml(this._sizeTestContent))));
    }
    // === Event handlers === //
    _onFocus() {
        if (typeof (this.onFocus) === "function")
            this.onFocus();
    }
    _onChange() {
        this._updateTextboxHeight();
        if (typeof (this.onChange) === "function")
            this.onChange();
    }
    _onKeyDown(e) {
        if (e.keyCode === 13 && e.shiftKey) {
            e.preventDefault();
            if (typeof (this.onSubmit) === "function")
                this.onSubmit();
        }
    }
    // === Public functions === //
    focus() {
        this._getDomNodes();
        if (!this._textbox)
            return;
        this._textbox.focus();
    }
    getValue() {
        this._getDomNodes();
        if (!this._textbox)
            return "";
        return this._textbox.value;
    }
    clear() {
        this._getDomNodes();
        if (!this._textbox)
            return;
        this.value = "";
        this._textbox.value = "";
        this._updateTextboxHeight();
    }
    // === Private functions === //
    _getDomNodes() {
        const root = this.shadowRoot;
        this._textbox = this._textbox || root.querySelector("#textbox");
        this._sizeTest = this._sizeTest || root.querySelector("#size-test");
        this._htmlStripper = this._htmlStripper || document.createElement("div");
    }
    _setupResizeWatcher() {
        window.addEventListener("resize", this._updateTextboxHeight.bind(this));
    }
    _updateTextboxHeight() {
        this._getDomNodes();
        if (!this._textbox)
            return;
        if (!this._sizeTest)
            return;
        const message = this._textbox.value;
        this._sizeTest.style.width = `${this._textbox.offsetWidth}px`;
        this._messageContent = message;
        this._htmlStripper.innerHTML = message;
        const htmlStrippedValue = this._htmlStripper.textContent.replace(/\n/g, "<br/>");
        this._sizeTestContent = htmlStrippedValue;
        this._sizeTest.innerHTML = htmlStrippedValue + "&nbsp";
        this.height = this._sizeTest.offsetHeight;
        const isMaxSize = (this.height || 0) >= this.maxHeight;
        if (isMaxSize !== this._isMaxSizeMessageTextBox) {
            this._isMaxSizeMessageTextBox = isMaxSize;
            this.forceRedraw();
        }
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "" })
], CTGrowingTextbox.prototype, "value", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "" })
], CTGrowingTextbox.prototype, "placeholder", void 0);
__decorate([
    base_1.prop({ type: base_1.NullableNumber, attribute: true, default: null })
], CTGrowingTextbox.prototype, "height", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: true, default: 200 })
], CTGrowingTextbox.prototype, "maxHeight", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTGrowingTextbox.prototype, "transparent", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTGrowingTextbox.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: true, default: false })
], CTGrowingTextbox.prototype, "maxLength", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTGrowingTextbox.prototype, "onFocus", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTGrowingTextbox.prototype, "onChange", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTGrowingTextbox.prototype, "onSubmit", void 0);
exports.CTGrowingTextbox = CTGrowingTextbox;
CTGrowingTextbox.register();


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
class CTIcon extends base_1.CTLayerComponent {
    static get is() {
        return "ct-icon";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex}:host svg{margin:auto}:host([spin]) svg{animation:spin 1s infinite linear;transform-origin:50% 50%}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
        `;
    }
    generateComponentMarkup() {
        if (!this.icon)
            return null;
        // not sure about this...
        // but this will get the font colour of the parent element
        // and apply this to the icon
        const styles = renderUtils_1.buildStyles({
            fill: this.color !== "auto"
                ? this.color
                : window.getComputedStyle(this.parentElement).color,
            width: this.width,
            height: this.height
        });
        const viewBox = this.icon.viewBox || "0 0 1024 1024";
        const svgNodes = (this.icon.nodes || []);
        const svgPaths = (this.icon.paths || []);
        if (svgNodes.length) {
            return this._drawFromNodes(viewBox, svgNodes, styles);
        }
        else {
            return this._drawFromPaths(viewBox, svgPaths, styles);
        }
    }
    _drawFromPaths(viewBox, svgPaths, styles) {
        return (window.__CTRender("svg", { width: this.width, height: this.height, viewBox: viewBox, style: styles }, svgPaths.map(path => (window.__CTRender("path", { d: path })))));
    }
    _drawFromNodes(viewBox, svgNodes, styles) {
        return (window.__CTRender("svg", { width: this.width, height: this.height, viewBox: viewBox, style: styles }, svgNodes.map(node => this._drawNode(node))));
    }
    _drawNode(svgNode) {
        return (window.__CTRender(svgNode.name, Object.assign({}, svgNode.attributes), (svgNode.children || []).map(child => this._drawNode(child))));
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTIcon.prototype, "width", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTIcon.prototype, "height", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "auto" })
], CTIcon.prototype, "color", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTIcon.prototype, "spin", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTIcon.prototype, "icon", void 0);
exports.CTIcon = CTIcon;
CTIcon.register();


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const events_1 = __webpack_require__(9);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["USERNAME"] = "Username"] = "USERNAME";
    I18nKeys[I18nKeys["PASSWORD"] = "Password"] = "PASSWORD";
    I18nKeys[I18nKeys["LOG_IN"] = "Log In"] = "LOG_IN";
    I18nKeys[I18nKeys["LOG_OUT"] = "Log Out"] = "LOG_OUT";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTLoginFormMetadata {
    static _create() {
        return new metadata_1.Metadata(CTLoginForm, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTLoginFormMetadata._instance = null;
exports.CTLoginFormMetadata = CTLoginFormMetadata;
class CTLoginForm extends base_1.CTLayerComponent {
    // === End properties === //
    constructor() {
        super();
        this.setMetadata(CTLoginFormMetadata.instance);
    }
    static get is() {
        return "ct-login-form";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._resetFields();
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            switch (detail.status) {
                case models_1.ConnectionStatus.Connected:
                    this.userLoggedIn = true;
                    break;
                case models_1.ConnectionStatus.Connecting:
                    this.isWaiting = true;
                    break;
                default:
                    this.isWaiting = false;
                    this.userLoggedIn = false;
                    break;
            }
        }, { dontSuppress: true });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;width:100%;margin:auto}:host .form{display:flex;flex-direction:column;width:100%}:host .form .form-field,:host .form .form-buttons{margin:5px 0}:host .form.theme-light .form-buttons .button{--button-primary-bg: transparent;--button-primary-text: #ffffff;--button-primary-border: 1px solid #ffffff}
        `;
    }
    generateComponentMarkup() {
        return this.userLoggedIn
            ? this._renderLogoutForm()
            : this._renderLoginForm();
    }
    _renderLoginForm() {
        const classes = [
            "form"
        ];
        if (this.theme)
            classes.push(`theme-${this.theme}`);
        const usernameStyles = renderUtils_1.buildStyles({
            display: this.hideUsername
                ? "none"
                : "block"
        });
        const dynamicProps = {};
        if (this.theme)
            dynamicProps[`theme-${this.theme}`] = true;
        return (window.__CTRender("div", { class: classes.join(" ") },
            window.__CTRender("div", { class: "form-field", style: usernameStyles },
                window.__CTRender(components_1.CTTextbox, Object.assign({ type: "text", placeholder: this.translateI18nItem(I18nKeys.USERNAME), name: "username", defaultValue: this._username, disabled: this.disableUsername || this.isWaiting }, dynamicProps, { callback: e => this._onChange(e), returnKeypress: e => this._login(), forceTransparency: true }))),
            window.__CTRender("div", { class: "form-field" },
                window.__CTRender(components_1.CTTextbox, Object.assign({ type: "password", placeholder: this.translateI18nItem(I18nKeys.PASSWORD), name: "password", defaultValue: this._password }, dynamicProps, { callback: e => this._onChange(e), disabled: this.isWaiting, returnKeypress: e => this._login(), forceTransparency: true }))),
            window.__CTRender("div", { class: "form-buttons" },
                window.__CTRender(components_1.CTButton, { class: "button", type: "primary", disabled: this.disabled, onClick: e => this._login(), isWaiting: this.isWaiting }, this.logInLabel || this.translateI18nItem(I18nKeys.LOG_IN)))));
    }
    _renderLogoutForm() {
        let currentUserJid = this.layer.getCurrentUserJid();
        if (this.autoAppendDomainName) {
            currentUserJid = currentUserJid.split("@").shift();
        }
        const dynamicProps = {};
        if (this.theme)
            dynamicProps[`theme-${this.theme}`] = true;
        return (window.__CTRender("div", { class: "form", style: renderUtils_1.buildStyles({ display: "flex" }) },
            window.__CTRender("div", { class: "form-field" },
                window.__CTRender(components_1.CTTextbox, Object.assign({ type: "text", name: "username", defaultValue: currentUserJid }, dynamicProps, { disabled: true }))),
            window.__CTRender("div", { class: "form-buttons" },
                window.__CTRender(components_1.CTButton, { type: "primary", disabled: false, onClick: e => this._logout(), isWaiting: this.isWaiting }, this.translateI18nItem(I18nKeys.LOG_OUT)))));
    }
    // === Private functions === //
    _onChange(e) {
        if (e && e.key === "username") {
            this._username = e.value;
        }
        if (e && e.key === "password") {
            this._password = e.value;
        }
        this.disabled = (!this._username || !this._password);
    }
    _resetFields() {
        this._username = this.username || "";
        this._password = "";
        this.disabled = true;
    }
    _login() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._username && this._password) {
                this.isWaiting = true;
                let username = this.autoAppendDomainName
                    ? `${this._username.trim()}@${this.layer.config.xmpp.user.domain}`
                    : this._username.trim();
                if (this.layer.config.xmpp.user && this.layer.config.xmpp.user.forceLowercaseJid === true) {
                    username = username.toLowerCase();
                }
                try {
                    yield this.layer.login(username, this._password);
                    this.emitComponentEvent(events_1.BaseEvents.LoginFormResult, new events_1.CommsEventArgs(true));
                    this.isWaiting = false;
                    this._resetFields();
                }
                catch (ex) {
                    this.emitComponentEvent(events_1.BaseEvents.LoginFormResult, new events_1.CommsEventArgs(false, `Could not log in as ${username}`));
                    this.isWaiting = false;
                    this._password = "";
                    this._onChange();
                    document.activeElement.blur();
                }
            }
            return;
        });
    }
    _logout() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isWaiting = true;
            try {
                yield this.layer.logout();
                this.isWaiting = false;
                this._resetFields();
            }
            catch (ex) {
                this.emitComponentEvent(events_1.BaseEvents.LoginFormResult, new events_1.CommsEventArgs(false, `There was an error logging out. Please try again.`));
                this.isWaiting = false;
                document.activeElement.blur();
            }
        });
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "" })
], CTLoginForm.prototype, "theme", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTLoginForm.prototype, "autoAppendDomainName", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "" })
], CTLoginForm.prototype, "username", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTLoginForm.prototype, "hideUsername", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTLoginForm.prototype, "disableUsername", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: null })
], CTLoginForm.prototype, "logInLabel", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTLoginForm.prototype, "isWaiting", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTLoginForm.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTLoginForm.prototype, "userLoggedIn", void 0);
exports.CTLoginForm = CTLoginForm;
CTLoginForm.register();


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(1);
const components_1 = __webpack_require__(3);
class CTMenu extends base_1.CTLayerComponent {
    constructor() {
        super();
        // === End properties === //
        this._open = false;
        this._setUpEventHandlers();
    }
    static get is() {
        return "ct-menu";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:inline-block;color:inherit}:host .menu-container{position:relative}:host .menu-container .button{cursor:pointer}:host .menu-container .menu{position:absolute;top:25px;right:0;min-width:80px;background:var(--list-bg);color:var(--default-font-color, #212121);border:var(--list-item-border);z-index:99999;box-shadow:0 2px 5px rgba(0,0,0,0.5)}:host .menu-container .menu .menu-item{border-bottom:var(--list-item-border);padding:10px;cursor:pointer;white-space:nowrap}:host .menu-container .menu .menu-item.disabled{opacity:0.5}:host .menu-container .menu .menu-item:hover:not(.disabled){background:var(--secondary-color, #efefef)}:host .menu-container .menu .menu-item:last-child{border-bottom:0}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "menu-container" },
            window.__CTRender("div", { class: "button", onClick: e => this._toggleMenu(e) },
                window.__CTRender(components_1.CTIcon, { width: "20", height: "20", icon: models_1.Icons.COMMON.MenuDots })),
            this._open && (window.__CTRender("div", { class: "menu" }, this.menuItems.map(x => this._renderMenuItem(x))))));
    }
    _renderMenuItem(menuItem) {
        const cssClasses = ["menu-item"];
        if (menuItem.disabled)
            cssClasses.push("disabled");
        if (menuItem.className)
            cssClasses.push(menuItem.className);
        return (window.__CTRender("div", { class: cssClasses.join(" "), onClick: () => this._performAction(menuItem) }, menuItem.label));
    }
    // === Event handlers === //
    _toggleMenu(e) {
        e.stopPropagation();
        this._setMenuState(!this._open);
    }
    _performAction(menuItem) {
        if (!menuItem || !menuItem.action)
            return;
        if (menuItem.disabled)
            return;
        this._setMenuState(false);
        menuItem.action();
    }
    // === Private functions === //
    _setUpEventHandlers() {
        const handler = this._handleDocumentInteraction.bind(this);
        document.addEventListener("click", handler);
        window.addEventListener("resize", handler);
    }
    _setMenuState(state = !this._open) {
        this._open = state;
        this.forceRedraw();
    }
    _handleDocumentInteraction() {
        if (this._open)
            this._setMenuState(false);
    }
}
__decorate([
    base_1.prop({ type: Array, attribute: true, default: [] })
], CTMenu.prototype, "menuItems", void 0);
exports.CTMenu = CTMenu;
class MenuItem {
    constructor(label, action, disabled = false, className = null) {
        this.label = label;
        this.action = action;
        this.disabled = disabled;
        this.className = className;
    }
}
exports.MenuItem = MenuItem;
CTMenu.register();


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const events_1 = __webpack_require__(9);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
const ct_button_1 = __webpack_require__(59);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["ONLINE"] = "Online"] = "ONLINE";
    I18nKeys[I18nKeys["OFFLINE"] = "Offline"] = "OFFLINE";
    I18nKeys[I18nKeys["RECONNECTING"] = "Reconnecting"] = "RECONNECTING";
    I18nKeys[I18nKeys["RECONNECT"] = "Reconnect"] = "RECONNECT";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTOnlineIndicatorMetadata {
    static _create() {
        return new metadata_1.Metadata(CTOnlineIndicator, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTOnlineIndicatorMetadata._instance = null;
exports.CTOnlineIndicatorMetadata = CTOnlineIndicatorMetadata;
class CTOnlineIndicator extends base_1.CTLayerComponent {
    // === End properties === //
    constructor() {
        super();
        this.attemptCount = 0;
        this.setMetadata(CTOnlineIndicatorMetadata.instance);
    }
    static get is() {
        return "ct-online-indicator";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.status = this.layer.getConnectionStatus();
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            this.status = detail.status;
            this.reconnectTime = detail.reconnectTime;
            this.allowReconnect = (detail.status === models_1.ConnectionStatus.Disconnected);
            clearInterval(this.timeoutId);
            if (detail.reconnectTime) {
                this.timeoutId = setInterval(() => {
                    this.reconnectTime -= 1000;
                }, 1000);
            }
        }, { dontSuppress: true });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:inline-flex;font-size:inherit;font-weight:inherit;color:inherit}:host .online-indicator{display:flex;align-items:center}:host .online-indicator .icon{flex:none;margin:0 5px 0 0}:host .online-indicator .label{display:flex;align-items:center;flex:1 1}:host .online-indicator .label .reconnect-detail{display:flex;align-items:center}:host .online-indicator .label .reconnect-detail .countdown{width:40px;padding:0 5px}
        `;
    }
    generateComponentMarkup() {
        const classes = [
            "online-indicator",
            (this.status === models_1.ConnectionStatus.Connected)
                ? "online"
                : "offline"
        ];
        const icon = (this.status === models_1.ConnectionStatus.Connecting)
            ? models_1.Icons.COMMON.LoadingSpinner
            : (this.status === models_1.ConnectionStatus.Connected)
                ? models_1.Icons.COMMON.StatusOnline
                : models_1.Icons.COMMON.StatusOffline;
        return (window.__CTRender("div", { class: classes.join(" ") },
            renderUtils_1.renderIf(this.showIcon, (window.__CTRender("div", { class: "icon" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: icon, spin: this.status === models_1.ConnectionStatus.Connecting })))),
            renderUtils_1.renderIf(this.showText, (window.__CTRender("div", { class: "label" },
                window.__CTRender("span", { class: "status" }, this._getStatusLabel()),
                renderUtils_1.renderIf(this.status === models_1.ConnectionStatus.Disconnected && this.reconnectTime !== undefined && this.reconnectTime > 0, (window.__CTRender("span", { class: "reconnect-detail" },
                    window.__CTRender("span", { class: "countdown" }, this._getCountdownLabel()),
                    window.__CTRender(ct_button_1.CTButton, { type: "invert-secondary", disabled: !this.allowReconnect, onClick: e => this._tryLoginNow(e) }, this.translateI18nItem(I18nKeys.RECONNECT))))))))));
    }
    // === Private functions === //
    _getStatusLabel() {
        switch (this.status) {
            case models_1.ConnectionStatus.Connected:
                return this.translateI18nItem(I18nKeys.ONLINE);
            case models_1.ConnectionStatus.Connecting:
                return this.translateI18nItem(I18nKeys.RECONNECTING);
            case models_1.ConnectionStatus.Disconnecting:
            case models_1.ConnectionStatus.Disconnected:
                return this.translateI18nItem(I18nKeys.OFFLINE);
        }
    }
    _getCountdownLabel() {
        return `(${this.reconnectTime / 1000}s)`;
    }
    _tryLoginNow(e) {
        if (this.allowReconnect === false)
            return;
        this.allowReconnect = false;
        this.status = models_1.ConnectionStatus.Connecting;
        this.layer.attemptReconnect();
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTOnlineIndicator.prototype, "showIcon", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTOnlineIndicator.prototype, "showText", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: models_1.ConnectionStatus.Disconnected })
], CTOnlineIndicator.prototype, "status", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTOnlineIndicator.prototype, "reconnectTime", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTOnlineIndicator.prototype, "allowReconnect", void 0);
exports.CTOnlineIndicator = CTOnlineIndicator;
CTOnlineIndicator.register();


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
class CTSearchbox extends base_1.CTLayerComponent {
    static get is() {
        return "ct-searchbox";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host .search-box{position:relative;color:var(--subtle-font-color, #828688)}:host .search-box input{width:100%;height:30px;font-family:inherit;font-size:14px;font-weight:inherit;padding:4px 26px;border-radius:15px;background:#ffffff;color:var(--default-font-color, #212121);border:var(--secondary-border, 1px solid #ddd);outline:none}:host .search-box input::placeholder{text-align:center;color:var(--subtle-font-color, #828688)}:host .search-box input::-webkit-input-placeholder{text-align:center;color:var(--subtle-font-color, #828688)}:host .search-box .icon{position:absolute;top:0;left:0;height:100%;padding:0 7px}:host .search-box .clear{position:absolute;top:0;right:0;height:100%;padding:0 7px;cursor:pointer}
        `;
    }
    generateComponentMarkup() {
        let icon = models_1.Icons.COMMON.Search;
        if (this.type === "filter") {
            icon = models_1.Icons.COMMON.Filter;
        }
        return (window.__CTRender("div", { class: "search-box" },
            window.__CTRender("input", { type: "text", placeholder: this.placeholder, oninput: e => this._onChange(e.target.value), onblur: e => this._onBlur() }),
            window.__CTRender(components_1.CTIcon, { class: "icon", width: "16", height: "16", icon: icon }),
            this.allowClear && this.showClear && window.__CTRender(components_1.CTIcon, { class: "clear", width: "12", height: "12", icon: models_1.Icons.COMMON.CircleCross, onClick: this._clear.bind(this) })));
    }
    // === Event handlers === //
    _onChange(searchTerm) {
        const isEmpty = searchTerm.length === 0;
        if (isEmpty) {
            this.cancelDebounce("search");
            this.showClear = false;
            this.value = "";
            this.onSearch("");
        }
        else {
            this.showClear = true;
            this.debounce("search", () => {
                this.value = searchTerm;
                if (typeof (this.onSearch) === "function") {
                    this.onSearch(searchTerm);
                }
            }, this.delay);
        }
    }
    _clear(refocus = true) {
        if (!this.allowClear)
            return;
        const input = this.shadowRoot.querySelector("input");
        input.value = "";
        if (refocus)
            input.focus();
        this._onChange("");
    }
    _onBlur() {
        if (this.onBlur)
            this.onBlur();
    }
    // === Public functions === //
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            this._clear(false);
        });
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "search" })
], CTSearchbox.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "" })
], CTSearchbox.prototype, "placeholder", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: true, default: 200 })
], CTSearchbox.prototype, "delay", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTSearchbox.prototype, "allowClear", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTSearchbox.prototype, "onSearch", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTSearchbox.prototype, "onBlur", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTSearchbox.prototype, "showClear", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTSearchbox.prototype, "value", void 0);
exports.CTSearchbox = CTSearchbox;
CTSearchbox.register();


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(8);
const models_1 = __webpack_require__(1);
class CTSelectionList extends base_1.CTLayerComponent {
    static get is() {
        return "ct-selection-list";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof (this.onSelect) === "function") {
                this.onSelect(this.options[this.selected].key);
            }
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;width:100%}:host .selection-list{display:flex;flex-direction:row;flex-wrap:wrap;color:var(--default-bg-color-light-font, #212121)}:host .selection-list label{margin:10px 0 5px;text-transform:uppercase;font-size:0.8em;color:var(--tertiary-placeholder-color, #212121)}:host .selection-list .dropdown-contanier{flex:1 1 100%;position:relative}:host .selection-list .dropdown-contanier select{width:100%;height:30px;font-size:1em;outline:none;background-color:var(--default-bg-color-light, #fff);border:1px solid var(--select-border-color, #ddd);color:inherit;-webkit-appearance:none;padding:0.3em;border-radius:0}:host .selection-list .dropdown-contanier ct-icon.select-icon{pointer-events:none;position:absolute;top:0;right:0;height:100%;padding:0 7px;cursor:pointer}:host .selection-list .button-container{position:relative;flex:0 1 50%}:host .selection-list .button-container:nth-child(2n-1){padding:10px 5px 0 0}:host .selection-list .button-container:nth-child(2n-2){padding:10px 0 0 5px}:host .selection-list .button-container:nth-child(1),:host .selection-list .button-container:nth-child(2){padding-top:0}:host .selection-list.button-list{display:block}:host .selection-list.button-list .button-container{display:block;padding:0 0 1px 0}:host .selection-list.button-list .button-container:last-child{padding:0}
        `;
    }
    generateComponentMarkup() {
        const maxButtonOptions = 4;
        const showAsButtons = this.forceDropdown ? false : (this.buttonList || (this.options.length <= maxButtonOptions));
        const cssClasses = [
            "selection-list"
        ];
        if (this.buttonList) {
            cssClasses.push("button-list");
        }
        return (window.__CTRender("div", { class: cssClasses.join(" ") },
            window.__CTRender("label", null, "Response Options"),
            renderUtils_1.renderIfElse(showAsButtons, this._renderButtons(), this._renderDropDown())));
    }
    _renderDropDown() {
        return (window.__CTRender("div", { class: "dropdown-contanier" },
            window.__CTRender("select", { onChange: e => this._onMakeSelection(e), value: this.selected.toString() }, this.options.map(opt => (window.__CTRender("option", { "data-key": opt.key, value: opt.key.toString(), defaultSelected: this.selected === opt.key }, opt.value)))),
            window.__CTRender(components_1.CTIcon, { class: "select-icon", width: "12", height: "12", icon: models_1.Icons.COMMON.ChevronDown })));
    }
    _renderButtons() {
        return this.options.map(opt => (window.__CTRender("div", { class: "button-container" },
            window.__CTRender(components_1.CTButton, { "data-key": opt.key, type: "secondary", selected: this.selected === opt.key, onClick: e => this._onMakeSelection(e) }, opt.value))));
    }
    // === Event handlers === //
    _onMakeSelection(e) {
        const target = e.target;
        if (!target)
            return;
        let selection = null;
        switch (target.nodeName) {
            case "CT-BUTTON":
                selection = parseInt(target.getAttribute("data-key"));
                break;
            case "SELECT":
                selection = parseInt(target.value);
                break;
        }
        if (isNaN(selection))
            return;
        const selectedOption = this.options.find(x => x.key === selection);
        if (!selectedOption)
            return;
        this._makeSelection(selectedOption.key);
        this.selected = selectedOption.key;
    }
    // === Private functions === //
    _makeSelection(selection) {
        if (typeof (this.onSelect) === "function") {
            this.onSelect(selection);
        }
    }
}
__decorate([
    base_1.prop({ type: Number, attribute: true, default: Number.MIN_VALUE })
], CTSelectionList.prototype, "selected", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTSelectionList.prototype, "buttonList", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTSelectionList.prototype, "forceDropdown", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: true })
], CTSelectionList.prototype, "onSelect", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTSelectionList.prototype, "options", void 0);
exports.CTSelectionList = CTSelectionList;
CTSelectionList.register();


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(3);
const component_1 = __webpack_require__(15);
const Models_1 = __webpack_require__(5);
let CTSingleCheckbox = class CTSingleCheckbox extends base_1.CTLayerComponent {
    constructor() {
        // === Non-attribute properties === //
        super(...arguments);
        this._toggle = () => {
            this.value = !this.value;
            if (this.callback) {
                this.callback(this.value);
            }
        };
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "container", onClick: this._toggle },
            window.__CTRender("p", null, this.label),
            this.value
                ? window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.CheckboxChecked })
                : window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: Models_1.Icons.UI.CheckboxUnchecked })));
    }
};
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTSingleCheckbox.prototype, "callback", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTSingleCheckbox.prototype, "value", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTSingleCheckbox.prototype, "label", void 0);
CTSingleCheckbox = __decorate([
    component_1.component({ tag: "ct-single-checkbox", styles: [`/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block}:host div.container{display:flex;margin:5px 0;padding:0 5px;justify-content:space-between;cursor:pointer;color:var(--primary-color, #22b1c8)}:host div.container p{color:var(--default-font-color, #212121)}
    `] })
], CTSingleCheckbox);
exports.CTSingleCheckbox = CTSingleCheckbox;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
class CTSlidePanel extends base_1.CTLayerComponent {
    static get is() {
        return "ct-slide-panel";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;color:inherit}@keyframes fadein{0%{opacity:0;transform:translateX(-100%)}1%{opacity:0;transform:translateX(0)}100%{opacity:1;transform:translateX(0)}}@keyframes fadeout{0%{opacity:1;transform:translateX(0)}99%{opacity:0;transform:translateX(0)}100%{opacity:0;transform:translateX(-100%)}}@keyframes slidein{0%{transform:translateX(-200%)}1%{transform:translateX(-100%)}100%{transform:translateX(0)}}@keyframes slideout{0%{transform:translateX(0)}99%{transform:translateX(-100%)}100%{transform:translateX(-200%)}}:host .slide-panel{display:flex;justify-content:center;align-items:center;height:100%}:host .slide-panel .button{display:block;z-index:99999;cursor:pointer}:host .slide-panel .blocker{position:fixed;top:0;left:0;width:100%;height:100%;transform:translateX(-200%);background:rgba(0,0,0,0.5);z-index:99997;will-change:transform}:host .slide-panel .slide-panel-menu{position:fixed;top:0;left:0;height:100%;transform:translateX(-200%);background:transparent;color:#212121;z-index:99998;will-change:transform}:host .slide-panel.open .blocker{animation:fadein var(--animation-fast, .3s) 1 ease-out normal forwards}:host .slide-panel.open .slide-panel-menu{animation:slidein var(--animation-fast, .3s) 1 ease-out normal forwards}:host .slide-panel.closed .blocker{animation:fadeout var(--animation-fast, .3s) 1 ease-out normal forwards}:host .slide-panel.closed .slide-panel-menu{animation:slideout var(--animation-fast, .3s) 1 ease-out normal forwards}
        `;
    }
    generateComponentMarkup() {
        const classes = [
            "slide-panel",
            this.state
        ];
        const menuStyle = renderUtils_1.buildStyles({
            width: (this.menuWidth || "300px")
        });
        return (window.__CTRender("div", { class: classes.join(" ") },
            window.__CTRender("div", { class: "button", onClick: this._toggleMenu.bind(this) },
                window.__CTRender(components_1.CTIcon, { width: "20", height: "20", icon: models_1.Icons.COMMON.Menu })),
            window.__CTRender("div", { class: "blocker", onClick: this._closeMenu.bind(this) }),
            window.__CTRender("div", { class: "slide-panel-menu", style: menuStyle },
                window.__CTRender("slot", null))));
    }
    // === Event handlers === //
    _toggleMenu() {
        if (!this.state || this.state === "closed") {
            this.state = "open";
        }
        else {
            this.state = "closed";
        }
    }
    _closeMenu() {
        this.state = "closed";
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "300px" })
], CTSlidePanel.prototype, "menuWidth", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTSlidePanel.prototype, "state", void 0);
exports.CTSlidePanel = CTSlidePanel;
CTSlidePanel.register();


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
const models_1 = __webpack_require__(1);
class CTTextbox extends base_1.CTLayerComponent {
    static get is() {
        return "ct-textbox";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._value = this.defaultValue || "";
            this._isPasswordField = (this.type && this.type.toLowerCase() === "password");
            if (this._isPasswordField) {
                this._watchPasswordField();
            }
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host label{color:var(--default-font-color, #212121)}:host div div.input{position:relative;display:flex;flex-direction:row;margin:0 0 5px 0;border-bottom:1px solid var(--default-border-color, #ddd)}:host div div.input.focus{border-color:var(--login-form-border-color, green)}:host div div.input input,:host div div.input textarea{flex:1 1;font-family:inherit;font-size:inherit;font-weight:inherit;background-color:var(--default-bg-color-light, transparent);border:none;padding:0.3em;margin:auto;outline:none;resize:none;color:var(--login-form-font-color, inherit)}:host div div.input input.transparent,:host div div.input textarea.transparent{background-color:transparent}:host div div.input input:focus,:host div div.input textarea:focus{border:none;outline-offset:0}:host div div.input input:focus:not(:placeholder-shown) ~ .clear-value,:host div div.input textarea:focus:not(:placeholder-shown) ~ .clear-value{opacity:0.5;cursor:pointer}:host div div.input input:focus:not(:placeholder-shown) ~ .required,:host div div.input textarea:focus:not(:placeholder-shown) ~ .required{visibility:hidden}:host div div.input input:valid ~ .required,:host div div.input textarea:valid ~ .required{visibility:hidden}:host div div.input ct-icon{flex:0 0 20px;text-align:center}:host div div.input ct-icon.show-password{opacity:0.5}:host div div.input ct-icon.show-password.show-password-enabled{opacity:1}:host div div.input ct-icon.required{position:absolute;right:5px;top:0;height:100%}:host div div.input ct-icon.clear-value{opacity:0}:host div div.input ct-icon+ct-icon{margin:0 0 0 5px}:host div div.input .validation{margin-bottom:1%;color:red}:host div.disabled div.input{border-bottom:none}:host([full-border]) div div.input{background-color:var(--default-bg-color-light, #fff);border:1px solid var(--select-border-color, #ddd);color:var(--default-bg-color-light-font, #212121)}:host([full-border]) div div.input input::placeholder,:host([full-border]) div div.input textarea::placeholder{color:var(--select-placeholder-color, #828688)}:host([full-border]) div div.input input::-webkit-input-placeholder,:host([full-border]) div div.input textarea::-webkit-input-placeholder{color:var(--select-placeholder-color, #828688)}:host([theme-light]) label{color:#ffffff}:host([theme-light]) div div.input{border-bottom:1px solid rgba(255,255,255,0.6);color:#ffffff}:host([theme-light]) div div.input input,:host([theme-light]) div div.input textarea{color:#ffffff}:host([theme-light]) div div.input input::placeholder,:host([theme-light]) div div.input textarea::placeholder{color:rgba(255,255,255,0.6)}:host([theme-light]) div div.input input::-webkit-input-placeholder,:host([theme-light]) div div.input textarea::-webkit-input-placeholder{color:rgba(255,255,255,0.6)}:host([theme-light]) div div.input.focus{border-color:#ffffff}
        `;
    }
    generateComponentMarkup() {
        const dynamicProps = {};
        if (this.max)
            dynamicProps["maxlength"] = this.max;
        return (window.__CTRender("div", { class: this.disabled ? "disabled" : "" },
            renderUtils_1.renderIf(this.label !== undefined, window.__CTRender("label", { htmlFor: this.name }, this.label)),
            window.__CTRender("div", { class: "input" },
                renderUtils_1.renderIfElse(this.type === "textarea", window.__CTRender("textarea", Object.assign({ class: `${this.forceTransparency ? "transparent" : ""}`, placeholder: this.placeholder, name: this.name, onFocus: e => this._toggleFocus(true), onBlur: e => this._toggleFocus(false), onInput: e => this._updateValue({ key: e.target.name, value: e.target.value }), onkeydown: this._keydown.bind(this), value: this.defaultValue, disabled: this.disabled, required: this.required, rows: 5 }, dynamicProps)), window.__CTRender("input", Object.assign({ class: `${this.forceTransparency ? "transparent" : ""}`, type: this.type, placeholder: this.placeholder, name: this.name, onFocus: e => this._toggleFocus(true), onBlur: e => this._toggleFocus(false), onInput: e => this._updateValue({ key: e.target.name, value: e.target.value }), onkeydown: this._keydown.bind(this), value: this.defaultValue, disabled: this.disabled, required: this.required }, dynamicProps))),
                renderUtils_1.renderIf(this.required, window.__CTRender(components_1.CTIcon, { class: "required", width: "8", height: "8", color: "#a91a49", icon: models_1.Icons.COMMON.RequiredField })),
                renderUtils_1.renderIf(this.showClearOptions && !this._isPasswordField, window.__CTRender(components_1.CTIcon, { class: "clear-value", width: "12", height: "12", icon: models_1.Icons.COMMON.ClearTextbox, onClick: e => this._clear() })),
                renderUtils_1.renderIf(this._isPasswordField, window.__CTRender(components_1.CTIcon, { class: `show-password ${this.type === "text" ? "show-password-enabled" : ""}`, width: "20", height: "20", icon: models_1.Icons.COMMON.ShowPassword, onClick: e => this._togglePasswordFieldType() })))));
    }
    // === Event handlers === //
    _toggleFocus(focused) {
        const container = this.shadowRoot.querySelector(".input");
        const input = (this.type === "textarea")
            ? container.querySelector("textarea")
            : container.querySelector("input");
        if (focused) {
            container.classList.add("focus");
            if ("scrollIntoViewIfNeeded" in input) {
                // tslint:disable-next-line no-any
                input.scrollIntoViewIfNeeded(); // non-standard, but better when it's available
            }
            else if ("scrollIntoView" in input) {
                input.scrollIntoView();
            }
        }
        else {
            container.classList.remove("focus");
        }
    }
    _keydown(e) {
        e.keyCode === 13 && this.returnKeypress
            ? this.returnKeypress()
            : null;
    }
    _updateValue(e) {
        this._value = e.value;
        if (typeof (this.callback) === "function") {
            this.callback({
                key: e.key,
                value: e.value,
                validated: this.validated
            });
        }
    }
    // === Private functions === //
    _clear() {
        let input;
        if (this.type !== "textarea") {
            input = this.shadowRoot.querySelector("input");
        }
        else {
            input = this.shadowRoot.querySelector("textarea");
        }
        input.value = "";
        input.focus();
        input.dispatchEvent(new Event("input"));
    }
    _togglePasswordFieldType() {
        if (!this._isPasswordField)
            return;
        if (this.type === "password") {
            this.type = "text";
        }
        else {
            this.type = "password";
        }
    }
    _watchPasswordField() {
        // tslint:disable-next-line no-any
        const watcher = (e) => {
            const container = this.shadowRoot.querySelector(".input");
            if (e.path) {
                const clickWithinContainer = e.path.includes(container);
                if (clickWithinContainer === false && this.type === "text") {
                    this.type = "password";
                }
            }
        };
        document.removeEventListener("click", watcher);
        document.addEventListener("click", watcher);
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "placeholder", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "label", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "name", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: true })
], CTTextbox.prototype, "showClearOptions", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "defaultValue", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTTextbox.prototype, "required", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTTextbox.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTTextbox.prototype, "fullBorder", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: true, default: 4000 })
], CTTextbox.prototype, "max", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTTextbox.prototype, "validated", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTTextbox.prototype, "forceTransparency", void 0);
exports.CTTextbox = CTTextbox;
CTTextbox.register();


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const events_1 = __webpack_require__(9);
const ct_user_avatar_1 = __webpack_require__(62);
class CTUserDisplay extends base_1.CTLayerComponent {
    static get is() {
        return "ct-user-display";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.user) {
                this.user = yield this.layer.getCurrentUser();
            }
            this._update();
        });
    }
    setupListeners() {
        this.addListeners([
            events_1.BaseEvents.ConnectionStatusChange,
            events_1.BaseEvents.CurrentUserVCardUpdate
        ], () => {
            this._update();
        });
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:inline-flex;font-size:inherit;font-weight:inherit;color:inherit}:host .user-display{display:flex;flex-direction:row;align-items:center;max-width:100%;color:var(--default-font-color, #212121)}:host .user-display .right{padding:0 0 0 10px}:host .user-display .right .name{font-size:16px;font-weight:bold}:host .user-display .right .groups{font-style:italic}:host .user-display .icon{flex:none;margin:0 5px 0 0}:host .user-display .label{flex:1 1}
        `;
    }
    generateComponentMarkup() {
        if (!this.user)
            return null;
        return (window.__CTRender("div", { class: "user-display" },
            window.__CTRender("div", { class: "left" },
                window.__CTRender(ct_user_avatar_1.CTUserAvatar, { size: 40, user: this.user })),
            window.__CTRender("div", { class: "right" },
                window.__CTRender("div", { class: "name" },
                    this.user.firstName,
                    " ",
                    this.user.lastName),
                window.__CTRender("div", { class: "job-title" }, this.user.jobTitle || "No Job Title"),
                window.__CTRender("div", { class: "groups" }, this.user.group || "No Groups"))));
    }
    // === Private functions === //
    _update() {
        return __awaiter(this, void 0, void 0, function* () {
            this.user = yield this.layer.getCurrentUser();
        });
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "simple" })
], CTUserDisplay.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTUserDisplay.prototype, "showIcon", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTUserDisplay.prototype, "displayName", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTUserDisplay.prototype, "user", void 0);
exports.CTUserDisplay = CTUserDisplay;
CTUserDisplay.register();


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const metadata_1 = __webpack_require__(11);
const models_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(2);
const renderUtils_1 = __webpack_require__(8);
const components_1 = __webpack_require__(3);
const VirtualList_1 = __webpack_require__(33);
const ct_group_tile_1 = __webpack_require__(179);
const ct_group_avatar_1 = __webpack_require__(60);
const Events_1 = __webpack_require__(167);
const ct_selection_text_filter_1 = __webpack_require__(61);
var I18nKeys;
(function (I18nKeys) {
    // tslint:disable no-any
    I18nKeys[I18nKeys["SEARCH_PLACEHOLDER"] = "Find Users"] = "SEARCH_PLACEHOLDER";
    I18nKeys[I18nKeys["INITIAL_MESSAGE"] = "Find users by searching for first name or last name"] = "INITIAL_MESSAGE";
    I18nKeys[I18nKeys["NO_MATCHES"] = "No users match your search"] = "NO_MATCHES";
    I18nKeys[I18nKeys["SEARCH_BY"] = "Search By:"] = "SEARCH_BY";
    I18nKeys[I18nKeys["SEARCH_BY_ALL"] = "All"] = "SEARCH_BY_ALL";
    I18nKeys[I18nKeys["SEARCH_BY_NAME"] = "Name"] = "SEARCH_BY_NAME";
    I18nKeys[I18nKeys["SEARCH_BY_JOB_TITLE"] = "Job Title"] = "SEARCH_BY_JOB_TITLE";
    I18nKeys[I18nKeys["SEARCH_BY_ROLE"] = "Role"] = "SEARCH_BY_ROLE";
    I18nKeys[I18nKeys["UNABLE_TO_ADD_USERS"] = "Unable to add users"] = "UNABLE_TO_ADD_USERS";
    I18nKeys[I18nKeys["MAX_USERS_REACHED_ROLE"] = "It was not possible to add this role to the conversation as it would exceed the maximum number of users allowed"] = "MAX_USERS_REACHED_ROLE";
    I18nKeys[I18nKeys["MEMBERS"] = "Members"] = "MEMBERS";
    // tslint:enable no-any
})(I18nKeys || (I18nKeys = {}));
class CTUserListMetadata {
    static _create() {
        return new metadata_1.Metadata(CTUserList, I18nKeys);
    }
    static get instance() {
        return this._instance || (this._instance = this._create());
    }
}
CTUserListMetadata._instance = null;
exports.CTUserListMetadata = CTUserListMetadata;
class CTUserList extends base_1.CTLayerComponent {
    constructor() {
        super();
        // === End properties === //
        this.TILE_HEIGHT = 70;
        this._groupMemberMap = new Map();
        // === Event handlers === //
        this._onSearchChange = (searchFilter, searchTerm) => {
            const searchTermEmpty = !searchTerm || searchTerm.trim().length === 0;
            const debounce = searchTermEmpty ? 0 : 250;
            this.isFetching = !searchTermEmpty;
            this.debounce("search", () => {
                this._searchContacts((searchFilter || "").toLowerCase(), searchTerm);
            }, debounce);
        };
        this.setMetadata(CTUserListMetadata.instance);
        this._onWindowResize = this._onWindowResize.bind(this);
        window.addEventListener("resize", this._onWindowResize, true);
    }
    static get is() {
        return "ct-user-list";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rolesOnly) {
                this._virtualList = new VirtualList_1.VirtualList(this, [], {
                    itemHeight: this.TILE_HEIGHT,
                    itemKeyGetter: x => x.name
                });
            }
            else {
                this._virtualList = new VirtualList_1.VirtualList(this, [], {
                    itemHeight: this.TILE_HEIGHT,
                    itemKeyGetter: x => x.jid
                });
            }
            if (this.allowSearch && this.requireSearch) {
                this.isFetching = false;
                this.searchTerm = "";
            }
            else {
                this.isFetching = true;
                this.defer(() => __awaiter(this, void 0, void 0, function* () {
                    yield this._searchContacts("", "");
                }));
            }
            this._groupMemberMap = yield this.layer.getGroupMemberCache();
        });
    }
    setupListeners() {
    }
    disconnectedCallback() {
        window.removeEventListener("resize", this._onWindowResize);
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex-direction:column;height:100%}:host .user-list{position:relative;display:flex;flex-direction:column;flex:1 1 auto;height:100%}:host .user-list .search{flex:0 0 55px;display:flex;padding:0 20px;justify-content:center;align-items:center;background:var(--secondary-color, #f2f2f2);border-bottom:var(--secondary-border, 1px solid #ddd)}:host .user-list .search .search-box{width:75%;font-size:.833em}:host .user-list .search .fields{margin-top:10px}:host .user-list .search input[type="radio"]{display:none}:host .user-list .search input[type="radio"]:checked+span{font-weight:bold;color:var(--primary-color, #22b1c8)}:host .user-list .search label{border-right:solid 1px #E1E1E1;padding:0 10px;color:#999999;font-size:14px}:host .user-list .search label:first-child{color:#CCCCCC}:host .user-list .search label:first-child,:host .user-list .search label:last-child{border-right:none}:host .user-list .selected-users{flex:none;display:flex;align-items:center;height:0;background-color:var(--list-item-bg, #fff);overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;transition:height var(--animation-normal, .5s) ease-out}:host .user-list .selected-users .scroller{display:inline-flex}:host .user-list .selected-users .scroller .selected-user{display:inline-flex;flex-direction:column;justify-content:center;align-items:center;text-overflow:ellipsis;width:75px;margin:10px 0 0 0}:host .user-list .selected-users .scroller .selected-user .avatar{position:relative;margin:0 0 5px 0}:host .user-list .selected-users .scroller .selected-user .avatar .remove{position:absolute;display:flex;flex-direction:column;justify-content:center;align-items:center;top:-5px;right:-5px;width:16px;height:16px;border-radius:50%;background:var(--primary-color, #22b1c8);border:2px solid var(--avatar-color, #fff);color:var(--primary-font-color, #fff);cursor:pointer}:host .user-list .selected-users .scroller .selected-user .name{font-size:.833em;color:var(--default-font-color);overflow:hidden;text-overflow:ellipsis;width:100%;height:20px;line-height:0.9em;text-align:center;white-space:nowrap}:host .user-list .selected-users.has-selections{height:70px;border-bottom:var(--list-item-border, 1px solid #ddd)}:host .user-list .user-list-items{position:relative;display:flex;flex-direction:column;flex:1 1 auto;height:100%;overflow:hidden}:host .user-list .user-list-items .users-loading-bg{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;background:var(--list-bg, #f2f2f2);z-index:-1}:host .user-list .user-list-items .users{flex:1 1 auto;overflow:auto;-webkit-overflow-scrolling:touch}:host .user-list .user-list-items .users .user{position:relative}:host .user-list .user-list-items .users .user .selection{position:absolute;top:0;right:0;height:100%;display:flex;justify-content:center;align-items:center;padding:0 20px;cursor:pointer}:host .user-list .user-list-items .users .user .selection .checkbox{display:flex;justify-content:center;align-items:center;width:16px;height:16px;color:var(--subtle-font-color, #828688);border:2px solid var(--subtle-font-color, #828688)}:host .user-list .user-list-items .users .user.selected .selection .checkbox{border:0}:host .user-list .user-list-items .users .user.selection-disabled .selection{opacity:0;cursor:not-allowed}:host .user-list .user-list-items .users .user.clickable{cursor:pointer}:host .user-list .initial-message,:host .user-list .fetching,:host .user-list .no-users{flex:1;display:flex;justify-content:center;align-items:flex-start;height:100%;text-align:center;padding:55px;background:var(--list-bg, #f2f2f2);color:var(--subtle-font-color, #828688)}:host .user-list .initial-message{align-items:center;font-size:1.333em}
        `;
    }
    generateComponentMarkup() {
        const selectionItems = [
            this.translateI18nItem(I18nKeys.SEARCH_BY_NAME),
            this.translateI18nItem(I18nKeys.SEARCH_BY_JOB_TITLE)
        ];
        if (this.layer.config.roles.enableRoles) {
            selectionItems.push(this.layer.config.roles.rolesLabel || this.translateI18nItem(I18nKeys.SEARCH_BY_ROLE));
        }
        return (window.__CTRender("div", { class: "user-list" },
            this.allowSearch && (window.__CTRender("div", { class: "search" },
                window.__CTRender(ct_selection_text_filter_1.CTSelectionTextFilter, { placeholder: this.searchPlaceholder || this.translateI18nItem(I18nKeys.SEARCH_PLACEHOLDER), selectionItems: selectionItems, onSearch: this._onSearchChange }))),
            this.allowSelection && this._renderSelections(),
            this.isFetching && (window.__CTRender("div", { class: "fetching" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }))),
            !this.isFetching && (window.__CTRender("div", { class: "user-list-items" },
                this._users && this._users.length > 1 && (window.__CTRender("div", { class: "fetching users-loading-bg" },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.LoadingSpinner, spin: true }))),
                this._renderUsers()))));
    }
    _renderSelections() {
        const classes = [
            "selected-users"
        ];
        const hasSelections = this.selections.size > 0;
        if (hasSelections)
            classes.push("has-selections");
        return (window.__CTRender("div", { class: classes.join(" ") }, this.selections.size > 0 && (window.__CTRender("div", { class: "scroller" }, [...this.selections.values()].map(item => (window.__CTRender("div", { class: "selected-user" },
            renderUtils_1.renderIf(item.jid !== undefined, window.__CTRender("div", { class: "avatar" },
                window.__CTRender(components_1.CTUserAvatar, { user: item, size: 32 }),
                window.__CTRender("div", { class: "remove", onClick: e => this._removeUserSelection(item, e) },
                    window.__CTRender(components_1.CTIcon, { class: "icon", width: "6", height: "6", icon: models_1.Icons.COMMON.Cross })))),
            renderUtils_1.renderIf(item.name !== undefined, window.__CTRender("div", { class: "avatar" },
                window.__CTRender(ct_group_avatar_1.CTGroupAvatar, { size: 32 }),
                window.__CTRender("div", { class: "remove", onClick: e => this._removeUserSelection(item, e) },
                    window.__CTRender(components_1.CTIcon, { class: "icon", width: "6", height: "6", icon: models_1.Icons.COMMON.Cross })))),
            renderUtils_1.renderIf(item.jid !== undefined, window.__CTRender("div", { class: "name" }, utils_1.formatUserName(item, this.selectedUsersNameFormat))),
            renderUtils_1.renderIf(item.name !== undefined, window.__CTRender("div", { class: "name" }, item.name)))))))));
    }
    _renderUsers() {
        const searchTermEmpty = !this.searchTerm || this.searchTerm.trim().length === 0;
        if (this.allowSearch && this.requireSearch && searchTermEmpty) {
            return (window.__CTRender("div", { class: "initial-message" }, this.initialMessage || this.translateI18nItem(I18nKeys.INITIAL_MESSAGE)));
        }
        const totalUsers = this._users.length;
        if (totalUsers === 0) {
            return (window.__CTRender("div", { class: "no-users" }, this.noMatchesMessage || this.translateI18nItem(I18nKeys.NO_MATCHES)));
        }
        return this._virtualList.render(this._renderItem.bind(this), "users", "users-content");
    }
    _renderItem(item, props) {
        const userSelected = this._userSelected(item);
        const classes = [
            "user"
        ];
        const selectionDisabled = this._maxUsersReached();
        if (this.allowSelection && userSelected)
            classes.push("selected");
        if (!userSelected && selectionDisabled)
            classes.push("selection-disabled");
        if (typeof (this.onClickUser) === "function")
            classes.push("clickable");
        const selectionFunction = event => {
            event.stopPropagation();
            if (!this.allowSelection)
                return;
            if (!userSelected && selectionDisabled)
                return;
            this._toggleUserSelection(item, event);
        };
        const detailStyle = renderUtils_1.buildStyles({
            paddingRight: "36px"
        });
        if (item.name) {
            return (window.__CTRender("div", Object.assign({ class: classes.join(" ") }, props, { onClick: e => this._onClickItem(item, e) }),
                window.__CTRender(ct_group_tile_1.CTGroupTile, { group: item, height: `${this.TILE_HEIGHT}px`, detailStyle: detailStyle }, this.allowSelection && (window.__CTRender("div", { slot: "additional" },
                    window.__CTRender("div", { class: "members" },
                        this.translateI18nItem(I18nKeys.MEMBERS),
                        ": ",
                        this._groupMemberMap[item.name].length),
                    window.__CTRender("div", { class: "selection", onClick: selectionFunction.bind(this) },
                        window.__CTRender("div", { class: "checkbox" }, userSelected && window.__CTRender(components_1.CTIcon, { width: "12", height: "12", icon: models_1.Icons.COMMON.Tick }))))))));
        }
        else {
            return (window.__CTRender("div", Object.assign({ class: classes.join(" ") }, props, { onClick: e => this._onClickItem(item, e) }),
                window.__CTRender(components_1.CTUserTile, { user: item, nameFormat: this.nameFormat, height: `${this.TILE_HEIGHT}px`, detailStyle: detailStyle }, this.allowSelection && (window.__CTRender("div", { slot: "additional", class: "selection", onClick: selectionFunction.bind(this) },
                    window.__CTRender("div", { class: "checkbox" }, userSelected && window.__CTRender(components_1.CTIcon, { width: "12", height: "12", icon: models_1.Icons.COMMON.Tick })))))));
        }
    }
    _onWindowResize() {
        this.debounce("resize", () => {
            this.forceRecalcList();
        });
    }
    // When the search input gets unfocused we want to force the list to recalculate to 
    // take into account the keyboard now been out of the way (after a blur)
    // private _onSearchBlur(): void {
    //     // Give the keyboard time to close
    //     setTimeout(() => {
    //         // Force a recalculation of the rows in the list
    //         this._virtualList.forceRecalc();
    //     }, 250);
    // }
    forceRecalcList() {
        this._virtualList.forceRecalc();
    }
    _onClickItem(item, event) {
        event.stopPropagation();
        if (item.users) {
            if (typeof (this.onClickGroup) === "function")
                this.onClickGroup(item);
        }
        else {
            if (typeof (this.onClickUser) === "function")
                this.onClickUser(item);
        }
    }
    _toggleUserSelection(item, event) {
        return __awaiter(this, void 0, void 0, function* () {
            event.stopPropagation();
            if (!this.allowSelection)
                return;
            this._userSelected(item)
                ? yield this._removeUserSelection(item, event)
                : yield this._addUserSelection(item, event);
        });
    }
    _addUserSelection(item, event) {
        return __awaiter(this, void 0, void 0, function* () {
            event.stopPropagation();
            if (item.jid) {
                this.selections.set(item.jid, item);
            }
            else {
                if (this._maxUsersWillBeReached(item.users.length)) {
                    // Warning dialog
                    this.emitEvent(Events_1.PagerEvents._Request_RaiseAlert, this.defaultAlerts.AlertErrorWithOkayButton(this.translateI18nItem(I18nKeys.UNABLE_TO_ADD_USERS), this.translateI18nItem(I18nKeys.MAX_USERS_REACHED_ROLE), 1, {}));
                    return;
                }
                else {
                    this.selections.set(item.name, item);
                }
            }
            this.onRenderComplete(() => {
                const scrollable = this.shadowRoot.querySelector(".selected-users");
                scrollable.scrollLeft = scrollable.firstChild.clientWidth;
            }, true);
            if (typeof (this.onChangeSelection) === "function")
                this.onChangeSelection(yield this.getSelections());
            this.forceRedraw();
        });
    }
    _removeUserSelection(user, event) {
        return __awaiter(this, void 0, void 0, function* () {
            event.stopPropagation();
            if (user.jid) {
                this.selections.delete(user.jid);
            }
            else {
                this.selections.delete(user.name);
            }
            if (typeof (this.onChangeSelection) === "function")
                this.onChangeSelection(yield this.getSelections());
            this.forceRedraw();
        });
    }
    // === Public functions === //
    getSelections() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allowSelection)
                return [];
            return utils_1.deepCloneArray([...this.selections.values()]);
        });
    }
    clearSelections() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allowSelection)
                return;
            this.selections.clear();
            if (typeof (this.onChangeSelection) === "function")
                this.onChangeSelection(yield this.getSelections());
            this.forceRedraw();
            yield utils_1.sleep(0); // this needs to happen to allow the selections to be cleared prior to subsequent operations being performed
        });
    }
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clearSelections();
        });
    }
    // === Private functions === //
    _searchContacts(searchFilter, searchTerm) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rolesOnly = false;
            const searchTermEmpty = !searchTerm || searchTerm.trim().length === 0;
            const roleLabel = (this.layer.config.roles.rolesLabel || this.translateI18nItem(I18nKeys.SEARCH_BY_ROLE)).toLowerCase();
            if (searchTermEmpty && this.requireSearch) {
                this.searchTerm = "";
                this._updateUserList([]);
                this.isFetching = false;
            }
            else {
                // TODO: line the cases up with translated values...?
                const fields = [];
                switch (searchFilter) {
                    case "name":
                        fields.push("firstName");
                        fields.push("lastName");
                        break;
                    case "job title":
                        fields.push("jobTitle");
                        break;
                    case roleLabel:
                        fields.push("group");
                        this.rolesOnly = true;
                        break;
                }
                const users = yield this.layer.searchUsers(searchTerm, fields);
                const jidsToExclude = (this.excludeUsers || []).map(x => x.toLowerCase());
                const filteredUsers = jidsToExclude.length
                    ? users.filter(x => !jidsToExclude.includes(x.jid.toLowerCase()))
                    : users;
                this.searchTerm = searchTerm;
                this._updateUserList(filteredUsers);
                this.isFetching = false;
            }
        });
    }
    _userSelected(item) {
        if (item.name) {
            return this.selections.has(item.name);
        }
        else {
            return this.selections.has(item.jid);
        }
    }
    _maxUsersWillBeReached(adding) {
        if (!this.maxSelections && this.maxSelections !== 0)
            return false;
        return this._totalSelectedUserCount() + adding > this.maxSelections;
    }
    _totalSelectedUserCount() {
        const selectionMap = new Map();
        // Flatten
        for (const item of this.selections.values()) {
            if (item.jid) {
                selectionMap.set(item.jid, item);
            }
            else {
                item.users.map(subItem => selectionMap.set(subItem.jid, subItem));
            }
        }
        return selectionMap.size;
    }
    _maxUsersReached() {
        if (!this.maxSelections && this.maxSelections !== 0)
            return false;
        return this._totalSelectedUserCount() >= this.maxSelections;
    }
    _updateUserList(users) {
        return __awaiter(this, void 0, void 0, function* () {
            this._users = users;
            if (this.rolesOnly) {
                const groups = [];
                for (const user of users) {
                    const userGroups = user.group.split(", ");
                    userGroups.forEach(ug => {
                        let chatGroup = groups.find(g => g.name === ug);
                        if (chatGroup == null) {
                            chatGroup = {
                                name: ug,
                                users: []
                            };
                            groups.push(chatGroup);
                        }
                        chatGroup.users.push(user);
                    });
                }
                this._virtualList.setItems(groups);
            }
            else {
                this._virtualList.setItems(this._users);
            }
        });
    }
}
__decorate([
    base_1.prop({ type: Object, attribute: false, default: utils_1.NameFormat.PREFIX_FIRST_LAST })
], CTUserList.prototype, "nameFormat", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: null })
], CTUserList.prototype, "excludeUsers", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTUserList.prototype, "allowSearch", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTUserList.prototype, "requireSearch", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTUserList.prototype, "searchPlaceholder", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTUserList.prototype, "initialMessage", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTUserList.prototype, "noMatchesMessage", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTUserList.prototype, "allowSelection", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: utils_1.NameFormat.PREFIX_INITIAL_LAST })
], CTUserList.prototype, "selectedUsersNameFormat", void 0);
__decorate([
    base_1.prop({ type: base_1.NullableNumber, attribute: false, default: null })
], CTUserList.prototype, "maxSelections", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTUserList.prototype, "onClickUser", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTUserList.prototype, "onClickGroup", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false, default: null })
], CTUserList.prototype, "onChangeSelection", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: new Map() })
], CTUserList.prototype, "selections", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTUserList.prototype, "searchTerm", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTUserList.prototype, "isFetching", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTUserList.prototype, "rolesOnly", void 0);
exports.CTUserList = CTUserList;
CTUserList.register();


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(2);
const components_1 = __webpack_require__(3);
class CTUserTile extends base_1.CTLayerComponent {
    static get is() {
        return "ct-user-tile";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `/*! Copyright (c) 2018 CommonTime Ltd *//*! Copyright (c) 2018 CommonTime Ltd */input:not([type=checkbox]):not([type=radio]){-webkit-appearance:none}/*! Copyright (c) 2018 CommonTime Ltd */:host{font-family:inherit;font-size:inherit;font-weight:inherit;color:#212121}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{max-width:100%}:host .name{flex:1 1 auto;font-size:1.333em;color:var(--default-font-color, #212121);white-space:pre-line;overflow:hidden;text-overflow:ellipsis}:host .job-title,:host .group{color:var(--subtle-font-color, #828688);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}:host .group{font-style:italic}:host .empty{color:#E1E1E1}
        `;
    }
    generateComponentMarkup() {
        if (!this.user)
            return;
        const groupClasses = ["group"];
        if (!this.user.group)
            groupClasses.push("empty");
        const jobTitleClasses = ["job-title"];
        if (!this.user.jobTitle)
            jobTitleClasses.push("empty");
        return (window.__CTRender(components_1.CTAvatarTile, { height: this.height, showAvatar: this.showAvatar, detailStyle: this.detailStyle },
            this.showAvatar && (window.__CTRender(components_1.CTUserAvatar, { slot: "avatar", size: 40, user: this.user })),
            window.__CTRender("div", { class: "name" }, utils_1.formatUserName(this.user, this.nameFormat)),
            window.__CTRender("div", { class: jobTitleClasses.join(" ") }, this.user.jobTitle || "No Job Title"),
            this.layer.config.roles.enableRoles && window.__CTRender("div", { class: groupClasses.join(" ") }, this.user.group || `No ${this.layer.config.roles.rolesLabel || "Role"}`),
            window.__CTRender("slot", { name: "additional" })));
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: true })
], CTUserTile.prototype, "showAvatar", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false })
], CTUserTile.prototype, "user", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: utils_1.NameFormat.PREFIX_FIRST_LAST })
], CTUserTile.prototype, "nameFormat", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: null })
], CTUserTile.prototype, "height", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: {} })
], CTUserTile.prototype, "detailStyle", void 0);
exports.CTUserTile = CTUserTile;
CTUserTile.register();


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*! Copyright (c) 2018 CommonTime Ltd */

Object.defineProperty(exports, "__esModule", { value: true });
const Keys_1 = __webpack_require__(20);
const Alert_1 = __webpack_require__(46);
const components_1 = __webpack_require__(3);
function getCommonI18nKeys(fullyQualified = false, ...scopes) {
    if (scopes.length === 0)
        scopes = [...data.keys()]; // if no scopes supplied, all scopes apply
    const keys = scopes.reduce((acc, cur) => acc.concat(getScopedI18nKeys(fullyQualified, cur)), []);
    return keys
        .filter((key, idx, arr) => {
        return arr.indexOf(key) === idx;
    })
        .sort();
}
exports.getCommonI18nKeys = getCommonI18nKeys;
function getScopedI18nKeys(fullyQualified, scope) {
    if (scope !== null && !data.has(scope))
        return [];
    return data.get(scope).getUniqueI18Keys(fullyQualified) || [];
}
const data = new Map();
data.set("DefaultAlerts", Alert_1.DefaultAlertsMetadata.instance);
data.set("CTLoginForm", components_1.CTLoginFormMetadata.instance);
data.set("CTOnlineIndicator", components_1.CTOnlineIndicatorMetadata.instance);
data.set("CTUserList", components_1.CTUserListMetadata.instance);
data.set("Common", Keys_1.CommonMetadata);


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {
var $scope, conflict, conflictResolution = [];
if (typeof global === 'object' && global) {
  $scope = global;
} else if (typeof window !== 'undefined') {
  $scope = window;
} else {
  $scope = {};
}
conflict = $scope.DeepDiff;
if (conflict) {
  conflictResolution.push(
    function() {
      if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
        $scope.DeepDiff = conflict;
        conflict = undefined;
      }
    });
}

// nodejs compatible on server side and in the browser.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

function Diff(kind, path) {
  Object.defineProperty(this, 'kind', {
    value: kind,
    enumerable: true
  });
  if (path && path.length) {
    Object.defineProperty(this, 'path', {
      value: path,
      enumerable: true
    });
  }
}

function DiffEdit(path, origin, value) {
  DiffEdit.super_.call(this, 'E', path);
  Object.defineProperty(this, 'lhs', {
    value: origin,
    enumerable: true
  });
  Object.defineProperty(this, 'rhs', {
    value: value,
    enumerable: true
  });
}
inherits(DiffEdit, Diff);

function DiffNew(path, value) {
  DiffNew.super_.call(this, 'N', path);
  Object.defineProperty(this, 'rhs', {
    value: value,
    enumerable: true
  });
}
inherits(DiffNew, Diff);

function DiffDeleted(path, value) {
  DiffDeleted.super_.call(this, 'D', path);
  Object.defineProperty(this, 'lhs', {
    value: value,
    enumerable: true
  });
}
inherits(DiffDeleted, Diff);

function DiffArray(path, index, item) {
  DiffArray.super_.call(this, 'A', path);
  Object.defineProperty(this, 'index', {
    value: index,
    enumerable: true
  });
  Object.defineProperty(this, 'item', {
    value: item,
    enumerable: true
  });
}
inherits(DiffArray, Diff);

function arrayRemove(arr, from, to) {
  var rest = arr.slice((to || from) + 1 || arr.length);
  arr.length = from < 0 ? arr.length + from : from;
  arr.push.apply(arr, rest);
  return arr;
}

function realTypeOf(subject) {
  var type = typeof subject;
  if (type !== 'object') {
    return type;
  }

  if (subject === Math) {
    return 'math';
  } else if (subject === null) {
    return 'null';
  } else if (Array.isArray(subject)) {
    return 'array';
  } else if (Object.prototype.toString.call(subject) === '[object Date]') {
    return 'date';
  } else if (typeof subject.toString === 'function' && /^\/.*\//.test(subject.toString())) {
    return 'regexp';
  }
  return 'object';
}

function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
  path = path || [];
  stack = stack || [];
  var currentPath = path.slice(0);
  if (typeof key !== 'undefined') {
    if (prefilter) {
      if (typeof(prefilter) === 'function' && prefilter(currentPath, key)) {
        return; } else if (typeof(prefilter) === 'object') {
        if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
          return; }
        if (prefilter.normalize) {
          var alt = prefilter.normalize(currentPath, key, lhs, rhs);
          if (alt) {
            lhs = alt[0];
            rhs = alt[1];
          }
        }
      }
    }
    currentPath.push(key);
  }

  // Use string comparison for regexes
  if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
    lhs = lhs.toString();
    rhs = rhs.toString();
  }

  var ltype = typeof lhs;
  var rtype = typeof rhs;

  var ldefined = ltype !== 'undefined' || (stack && stack[stack.length - 1].lhs && stack[stack.length - 1].lhs.hasOwnProperty(key));
  var rdefined = rtype !== 'undefined' || (stack && stack[stack.length - 1].rhs && stack[stack.length - 1].rhs.hasOwnProperty(key));

  if (!ldefined && rdefined) {
    changes(new DiffNew(currentPath, rhs));
  } else if (!rdefined && ldefined) {
    changes(new DiffDeleted(currentPath, lhs));
  } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
    changes(new DiffEdit(currentPath, lhs, rhs));
  } else if (realTypeOf(lhs) === 'date' && (lhs - rhs) !== 0) {
    changes(new DiffEdit(currentPath, lhs, rhs));
  } else if (ltype === 'object' && lhs !== null && rhs !== null) {
    if (!stack.filter(function(x) {
        return x.lhs === lhs; }).length) {
      stack.push({ lhs: lhs, rhs: rhs });
      if (Array.isArray(lhs)) {
        var i, len = lhs.length;
        for (i = 0; i < lhs.length; i++) {
          if (i >= rhs.length) {
            changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
          } else {
            deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
          }
        }
        while (i < rhs.length) {
          changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
        }
      } else {
        var akeys = Object.keys(lhs);
        var pkeys = Object.keys(rhs);
        akeys.forEach(function(k, i) {
          var other = pkeys.indexOf(k);
          if (other >= 0) {
            deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
            pkeys = arrayRemove(pkeys, other);
          } else {
            deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);
          }
        });
        pkeys.forEach(function(k) {
          deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
        });
      }
      stack.length = stack.length - 1;
    } else if (lhs !== rhs) {
      // lhs is contains a cycle at this element and it differs from rhs
      changes(new DiffEdit(currentPath, lhs, rhs));
    }
  } else if (lhs !== rhs) {
    if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
      changes(new DiffEdit(currentPath, lhs, rhs));
    }
  }
}

function accumulateDiff(lhs, rhs, prefilter, accum) {
  accum = accum || [];
  deepDiff(lhs, rhs,
    function(diff) {
      if (diff) {
        accum.push(diff);
      }
    },
    prefilter);
  return (accum.length) ? accum : undefined;
}

function applyArrayChange(arr, index, change) {
  if (change.path && change.path.length) {
    var it = arr[index],
      i, u = change.path.length - 1;
    for (i = 0; i < u; i++) {
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        applyArrayChange(it[change.path[i]], change.index, change.item);
        break;
      case 'D':
        delete it[change.path[i]];
        break;
      case 'E':
      case 'N':
        it[change.path[i]] = change.rhs;
        break;
    }
  } else {
    switch (change.kind) {
      case 'A':
        applyArrayChange(arr[index], change.index, change.item);
        break;
      case 'D':
        arr = arrayRemove(arr, index);
        break;
      case 'E':
      case 'N':
        arr[index] = change.rhs;
        break;
    }
  }
  return arr;
}

function applyChange(target, source, change) {
  if (target && source && change && change.kind) {
    var it = target,
      i = -1,
      last = change.path ? change.path.length - 1 : 0;
    while (++i < last) {
      if (typeof it[change.path[i]] === 'undefined') {
        it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
      }
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
        break;
      case 'D':
        delete it[change.path[i]];
        break;
      case 'E':
      case 'N':
        it[change.path[i]] = change.rhs;
        break;
    }
  }
}

function revertArrayChange(arr, index, change) {
  if (change.path && change.path.length) {
    // the structure of the object at the index has changed...
    var it = arr[index],
      i, u = change.path.length - 1;
    for (i = 0; i < u; i++) {
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        revertArrayChange(it[change.path[i]], change.index, change.item);
        break;
      case 'D':
        it[change.path[i]] = change.lhs;
        break;
      case 'E':
        it[change.path[i]] = change.lhs;
        break;
      case 'N':
        delete it[change.path[i]];
        break;
    }
  } else {
    // the array item is different...
    switch (change.kind) {
      case 'A':
        revertArrayChange(arr[index], change.index, change.item);
        break;
      case 'D':
        arr[index] = change.lhs;
        break;
      case 'E':
        arr[index] = change.lhs;
        break;
      case 'N':
        arr = arrayRemove(arr, index);
        break;
    }
  }
  return arr;
}

function revertChange(target, source, change) {
  if (target && source && change && change.kind) {
    var it = target,
      i, u;
    u = change.path.length - 1;
    for (i = 0; i < u; i++) {
      if (typeof it[change.path[i]] === 'undefined') {
        it[change.path[i]] = {};
      }
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        // Array was modified...
        // it will be an array...
        revertArrayChange(it[change.path[i]], change.index, change.item);
        break;
      case 'D':
        // Item was deleted...
        it[change.path[i]] = change.lhs;
        break;
      case 'E':
        // Item was edited...
        it[change.path[i]] = change.lhs;
        break;
      case 'N':
        // Item is new...
        delete it[change.path[i]];
        break;
    }
  }
}

function applyDiff(target, source, filter) {
  if (target && source) {
    var onChange = function(change) {
      if (!filter || filter(target, source, change)) {
        applyChange(target, source, change);
      }
    };
    deepDiff(target, source, onChange);
  }
}

Object.defineProperties(accumulateDiff, {

  diff: {
    value: accumulateDiff,
    enumerable: true
  },
  observableDiff: {
    value: deepDiff,
    enumerable: true
  },
  applyDiff: {
    value: applyDiff,
    enumerable: true
  },
  applyChange: {
    value: applyChange,
    enumerable: true
  },
  revertChange: {
    value: revertChange,
    enumerable: true
  },
  isConflict: {
    value: function() {
      return 'undefined' !== typeof conflict;
    },
    enumerable: true
  },
  noConflict: {
    value: function() {
      if (conflictResolution) {
        conflictResolution.forEach(function(it) {
          it();
        });
        conflictResolution = null;
      }
      return accumulateDiff;
    },
    enumerable: true
  }
});

/* harmony default export */ __webpack_exports__["default"] = (accumulateDiff);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(35)))

/***/ }),
/* 196 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 197 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _linkify = __webpack_require__(199);

var linkify = _interopRequireWildcard(_linkify);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var tokenize = linkify.tokenize,
    options = linkify.options; /**
                               	Convert strings of text into linkable HTML text
                               */

var Options = options.Options;


function escapeText(text) {
	return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function escapeAttr(href) {
	return href.replace(/"/g, '&quot;');
}

function attributesToString(attributes) {
	if (!attributes) {
		return '';
	}
	var result = [];

	for (var attr in attributes) {
		var val = attributes[attr] + '';
		result.push(attr + '="' + escapeAttr(val) + '"');
	}
	return result.join(' ');
}

function linkifyStr(str) {
	var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	opts = new Options(opts);

	var tokens = tokenize(str);
	var result = [];

	for (var i = 0; i < tokens.length; i++) {
		var token = tokens[i];

		if (token.type === 'nl' && opts.nl2br) {
			result.push('<br>\n');
			continue;
		} else if (!token.isLink || !opts.check(token)) {
			result.push(escapeText(token.toString()));
			continue;
		}

		var _opts$resolve = opts.resolve(token),
		    formatted = _opts$resolve.formatted,
		    formattedHref = _opts$resolve.formattedHref,
		    tagName = _opts$resolve.tagName,
		    className = _opts$resolve.className,
		    target = _opts$resolve.target,
		    attributes = _opts$resolve.attributes;

		var link = '<' + tagName + ' href="' + escapeAttr(formattedHref) + '"';

		if (className) {
			link += ' class="' + escapeAttr(className) + '"';
		}

		if (target) {
			link += ' target="' + escapeAttr(target) + '"';
		}

		if (attributes) {
			link += ' ' + attributesToString(attributes);
		}

		link += '>' + escapeText(formatted) + '</' + tagName + '>';
		result.push(link);
	}

	return result.join('');
}

if (!String.prototype.linkify) {
	String.prototype.linkify = function (opts) {
		return linkifyStr(this, opts);
	};
}

exports.default = linkifyStr;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.tokenize = exports.test = exports.scanner = exports.parser = exports.options = exports.inherits = exports.find = undefined;

var _class = __webpack_require__(28);

var _options = __webpack_require__(203);

var options = _interopRequireWildcard(_options);

var _scanner = __webpack_require__(201);

var scanner = _interopRequireWildcard(_scanner);

var _parser = __webpack_require__(200);

var parser = _interopRequireWildcard(_parser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

if (!Array.isArray) {
	Array.isArray = function (arg) {
		return Object.prototype.toString.call(arg) === '[object Array]';
	};
}

/**
	Converts a string into tokens that represent linkable and non-linkable bits
	@method tokenize
	@param {String} str
	@return {Array} tokens
*/
var tokenize = function tokenize(str) {
	return parser.run(scanner.run(str));
};

/**
	Returns a list of linkable items in the given string.
*/
var find = function find(str) {
	var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	var tokens = tokenize(str);
	var filtered = [];

	for (var i = 0; i < tokens.length; i++) {
		var token = tokens[i];
		if (token.isLink && (!type || token.type === type)) {
			filtered.push(token.toObject());
		}
	}

	return filtered;
};

/**
	Is the given string valid linkable text of some sort
	Note that this does not trim the text for you.

	Optionally pass in a second `type` param, which is the type of link to test
	for.

	For example,

		test(str, 'email');

	Will return `true` if str is a valid email.
*/
var test = function test(str) {
	var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	var tokens = tokenize(str);
	return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].type === type);
};

// Scanner and parser provide states and tokens for the lexicographic stage
// (will be used to add additional link types)
exports.find = find;
exports.inherits = _class.inherits;
exports.options = options;
exports.parser = parser;
exports.scanner = scanner;
exports.test = test;
exports.tokenize = tokenize;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.start = exports.run = exports.TOKENS = exports.State = undefined;

var _state = __webpack_require__(65);

var _text = __webpack_require__(34);

var TEXT_TOKENS = _interopRequireWildcard(_text);

var _multi = __webpack_require__(202);

var MULTI_TOKENS = _interopRequireWildcard(_multi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var makeState = function makeState(tokenClass) {
	return new _state.TokenState(tokenClass);
};

// The universal starting state.
/**
	Not exactly parser, more like the second-stage scanner (although we can
	theoretically hotswap the code here with a real parser in the future... but
	for a little URL-finding utility abstract syntax trees may be a little
	overkill).

	URL format: http://en.wikipedia.org/wiki/URI_scheme
	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
	reference)

	@module linkify
	@submodule parser
	@main parser
*/

var S_START = makeState();

// Intermediate states for URLs. Note that domains that begin with a protocol
// are treated slighly differently from those that don't.
var S_PROTOCOL = makeState(); // e.g., 'http:'
var S_MAILTO = makeState(); // 'mailto:'
var S_PROTOCOL_SLASH = makeState(); // e.g., '/', 'http:/''
var S_PROTOCOL_SLASH_SLASH = makeState(); // e.g., '//', 'http://'
var S_DOMAIN = makeState(); // parsed string ends with a potential domain name (A)
var S_DOMAIN_DOT = makeState(); // (A) domain followed by DOT
var S_TLD = makeState(_multi.URL); // (A) Simplest possible URL with no query string
var S_TLD_COLON = makeState(); // (A) URL followed by colon (potential port number here)
var S_TLD_PORT = makeState(_multi.URL); // TLD followed by a port number
var S_URL = makeState(_multi.URL); // Long URL with optional port and maybe query string
var S_URL_NON_ACCEPTING = makeState(); // URL followed by some symbols (will not be part of the final URL)
var S_URL_OPENBRACE = makeState(); // URL followed by {
var S_URL_OPENBRACKET = makeState(); // URL followed by [
var S_URL_OPENANGLEBRACKET = makeState(); // URL followed by <
var S_URL_OPENPAREN = makeState(); // URL followed by (
var S_URL_OPENBRACE_Q = makeState(_multi.URL); // URL followed by { and some symbols that the URL can end it
var S_URL_OPENBRACKET_Q = makeState(_multi.URL); // URL followed by [ and some symbols that the URL can end it
var S_URL_OPENANGLEBRACKET_Q = makeState(_multi.URL); // URL followed by < and some symbols that the URL can end it
var S_URL_OPENPAREN_Q = makeState(_multi.URL); // URL followed by ( and some symbols that the URL can end it
var S_URL_OPENBRACE_SYMS = makeState(); // S_URL_OPENBRACE_Q followed by some symbols it cannot end it
var S_URL_OPENBRACKET_SYMS = makeState(); // S_URL_OPENBRACKET_Q followed by some symbols it cannot end it
var S_URL_OPENANGLEBRACKET_SYMS = makeState(); // S_URL_OPENANGLEBRACKET_Q followed by some symbols it cannot end it
var S_URL_OPENPAREN_SYMS = makeState(); // S_URL_OPENPAREN_Q followed by some symbols it cannot end it
var S_EMAIL_DOMAIN = makeState(); // parsed string starts with local email info + @ with a potential domain name (C)
var S_EMAIL_DOMAIN_DOT = makeState(); // (C) domain followed by DOT
var S_EMAIL = makeState(_multi.EMAIL); // (C) Possible email address (could have more tlds)
var S_EMAIL_COLON = makeState(); // (C) URL followed by colon (potential port number here)
var S_EMAIL_PORT = makeState(_multi.EMAIL); // (C) Email address with a port
var S_MAILTO_EMAIL = makeState(_multi.MAILTOEMAIL); // Email that begins with the mailto prefix (D)
var S_MAILTO_EMAIL_NON_ACCEPTING = makeState(); // (D) Followed by some non-query string chars
var S_LOCALPART = makeState(); // Local part of the email address
var S_LOCALPART_AT = makeState(); // Local part of the email address plus @
var S_LOCALPART_DOT = makeState(); // Local part of the email address plus '.' (localpart cannot end in .)
var S_NL = makeState(_multi.NL); // single new line

// Make path from start to protocol (with '//')
S_START.on(_text.NL, S_NL).on(_text.PROTOCOL, S_PROTOCOL).on(_text.MAILTO, S_MAILTO).on(_text.SLASH, S_PROTOCOL_SLASH);

S_PROTOCOL.on(_text.SLASH, S_PROTOCOL_SLASH);
S_PROTOCOL_SLASH.on(_text.SLASH, S_PROTOCOL_SLASH_SLASH);

// The very first potential domain name
S_START.on(_text.TLD, S_DOMAIN).on(_text.DOMAIN, S_DOMAIN).on(_text.LOCALHOST, S_TLD).on(_text.NUM, S_DOMAIN);

// Force URL for protocol followed by anything sane
S_PROTOCOL_SLASH_SLASH.on(_text.TLD, S_URL).on(_text.DOMAIN, S_URL).on(_text.NUM, S_URL).on(_text.LOCALHOST, S_URL);

// Account for dots and hyphens
// hyphens are usually parts of domain names
S_DOMAIN.on(_text.DOT, S_DOMAIN_DOT);
S_EMAIL_DOMAIN.on(_text.DOT, S_EMAIL_DOMAIN_DOT);

// Hyphen can jump back to a domain name

// After the first domain and a dot, we can find either a URL or another domain
S_DOMAIN_DOT.on(_text.TLD, S_TLD).on(_text.DOMAIN, S_DOMAIN).on(_text.NUM, S_DOMAIN).on(_text.LOCALHOST, S_DOMAIN);

S_EMAIL_DOMAIN_DOT.on(_text.TLD, S_EMAIL).on(_text.DOMAIN, S_EMAIL_DOMAIN).on(_text.NUM, S_EMAIL_DOMAIN).on(_text.LOCALHOST, S_EMAIL_DOMAIN);

// S_TLD accepts! But the URL could be longer, try to find a match greedily
// The `run` function should be able to "rollback" to the accepting state
S_TLD.on(_text.DOT, S_DOMAIN_DOT);
S_EMAIL.on(_text.DOT, S_EMAIL_DOMAIN_DOT);

// Become real URLs after `SLASH` or `COLON NUM SLASH`
// Here PSS and non-PSS converge
S_TLD.on(_text.COLON, S_TLD_COLON).on(_text.SLASH, S_URL);
S_TLD_COLON.on(_text.NUM, S_TLD_PORT);
S_TLD_PORT.on(_text.SLASH, S_URL);
S_EMAIL.on(_text.COLON, S_EMAIL_COLON);
S_EMAIL_COLON.on(_text.NUM, S_EMAIL_PORT);

// Types of characters the URL can definitely end in
var qsAccepting = [_text.DOMAIN, _text.AT, _text.LOCALHOST, _text.NUM, _text.PLUS, _text.POUND, _text.PROTOCOL, _text.SLASH, _text.TLD, _text.UNDERSCORE, _text.SYM, _text.AMPERSAND];

// Types of tokens that can follow a URL and be part of the query string
// but cannot be the very last characters
// Characters that cannot appear in the URL at all should be excluded
var qsNonAccepting = [_text.COLON, _text.DOT, _text.QUERY, _text.PUNCTUATION, _text.CLOSEBRACE, _text.CLOSEBRACKET, _text.CLOSEANGLEBRACKET, _text.CLOSEPAREN, _text.OPENBRACE, _text.OPENBRACKET, _text.OPENANGLEBRACKET, _text.OPENPAREN];

// These states are responsible primarily for determining whether or not to
// include the final round bracket.

// URL, followed by an opening bracket
S_URL.on(_text.OPENBRACE, S_URL_OPENBRACE).on(_text.OPENBRACKET, S_URL_OPENBRACKET).on(_text.OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET).on(_text.OPENPAREN, S_URL_OPENPAREN);

// URL with extra symbols at the end, followed by an opening bracket
S_URL_NON_ACCEPTING.on(_text.OPENBRACE, S_URL_OPENBRACE).on(_text.OPENBRACKET, S_URL_OPENBRACKET).on(_text.OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET).on(_text.OPENPAREN, S_URL_OPENPAREN);

// Closing bracket component. This character WILL be included in the URL
S_URL_OPENBRACE.on(_text.CLOSEBRACE, S_URL);
S_URL_OPENBRACKET.on(_text.CLOSEBRACKET, S_URL);
S_URL_OPENANGLEBRACKET.on(_text.CLOSEANGLEBRACKET, S_URL);
S_URL_OPENPAREN.on(_text.CLOSEPAREN, S_URL);
S_URL_OPENBRACE_Q.on(_text.CLOSEBRACE, S_URL);
S_URL_OPENBRACKET_Q.on(_text.CLOSEBRACKET, S_URL);
S_URL_OPENANGLEBRACKET_Q.on(_text.CLOSEANGLEBRACKET, S_URL);
S_URL_OPENPAREN_Q.on(_text.CLOSEPAREN, S_URL);
S_URL_OPENBRACE_SYMS.on(_text.CLOSEBRACE, S_URL);
S_URL_OPENBRACKET_SYMS.on(_text.CLOSEBRACKET, S_URL);
S_URL_OPENANGLEBRACKET_SYMS.on(_text.CLOSEANGLEBRACKET, S_URL);
S_URL_OPENPAREN_SYMS.on(_text.CLOSEPAREN, S_URL);

// URL that beings with an opening bracket, followed by a symbols.
// Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
// has a single opening bracket for some reason).
S_URL_OPENBRACE.on(qsAccepting, S_URL_OPENBRACE_Q);
S_URL_OPENBRACKET.on(qsAccepting, S_URL_OPENBRACKET_Q);
S_URL_OPENANGLEBRACKET.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
S_URL_OPENPAREN.on(qsAccepting, S_URL_OPENPAREN_Q);
S_URL_OPENBRACE.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
S_URL_OPENBRACKET.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
S_URL_OPENANGLEBRACKET.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
S_URL_OPENPAREN.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);

// URL that begins with an opening bracket, followed by some symbols
S_URL_OPENBRACE_Q.on(qsAccepting, S_URL_OPENBRACE_Q);
S_URL_OPENBRACKET_Q.on(qsAccepting, S_URL_OPENBRACKET_Q);
S_URL_OPENANGLEBRACKET_Q.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
S_URL_OPENPAREN_Q.on(qsAccepting, S_URL_OPENPAREN_Q);
S_URL_OPENBRACE_Q.on(qsNonAccepting, S_URL_OPENBRACE_Q);
S_URL_OPENBRACKET_Q.on(qsNonAccepting, S_URL_OPENBRACKET_Q);
S_URL_OPENANGLEBRACKET_Q.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
S_URL_OPENPAREN_Q.on(qsNonAccepting, S_URL_OPENPAREN_Q);

S_URL_OPENBRACE_SYMS.on(qsAccepting, S_URL_OPENBRACE_Q);
S_URL_OPENBRACKET_SYMS.on(qsAccepting, S_URL_OPENBRACKET_Q);
S_URL_OPENANGLEBRACKET_SYMS.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
S_URL_OPENPAREN_SYMS.on(qsAccepting, S_URL_OPENPAREN_Q);
S_URL_OPENBRACE_SYMS.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
S_URL_OPENBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
S_URL_OPENANGLEBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
S_URL_OPENPAREN_SYMS.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);

// Account for the query string
S_URL.on(qsAccepting, S_URL);
S_URL_NON_ACCEPTING.on(qsAccepting, S_URL);

S_URL.on(qsNonAccepting, S_URL_NON_ACCEPTING);
S_URL_NON_ACCEPTING.on(qsNonAccepting, S_URL_NON_ACCEPTING);

// Email address-specific state definitions
// Note: We are not allowing '/' in email addresses since this would interfere
// with real URLs

// For addresses with the mailto prefix
// 'mailto:' followed by anything sane is a valid email
S_MAILTO.on(_text.TLD, S_MAILTO_EMAIL).on(_text.DOMAIN, S_MAILTO_EMAIL).on(_text.NUM, S_MAILTO_EMAIL).on(_text.LOCALHOST, S_MAILTO_EMAIL);

// Greedily get more potential valid email values
S_MAILTO_EMAIL.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
S_MAILTO_EMAIL_NON_ACCEPTING.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);

// For addresses without the mailto prefix
// Tokens allowed in the localpart of the email
var localpartAccepting = [_text.DOMAIN, _text.NUM, _text.PLUS, _text.POUND, _text.QUERY, _text.UNDERSCORE, _text.SYM, _text.AMPERSAND, _text.TLD];

// Some of the tokens in `localpartAccepting` are already accounted for here and
// will not be overwritten (don't worry)
S_DOMAIN.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT);
S_TLD.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT);
S_DOMAIN_DOT.on(localpartAccepting, S_LOCALPART);

// Okay we're on a localpart. Now what?
// TODO: IP addresses and what if the email starts with numbers?
S_LOCALPART.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT) // close to an email address now
.on(_text.DOT, S_LOCALPART_DOT);
S_LOCALPART_DOT.on(localpartAccepting, S_LOCALPART);
S_LOCALPART_AT.on(_text.TLD, S_EMAIL_DOMAIN).on(_text.DOMAIN, S_EMAIL_DOMAIN).on(_text.LOCALHOST, S_EMAIL);
// States following `@` defined above

var run = function run(tokens) {
	var len = tokens.length;
	var cursor = 0;
	var multis = [];
	var textTokens = [];

	while (cursor < len) {
		var state = S_START;
		var secondState = null;
		var nextState = null;
		var multiLength = 0;
		var latestAccepting = null;
		var sinceAccepts = -1;

		while (cursor < len && !(secondState = state.next(tokens[cursor]))) {
			// Starting tokens with nowhere to jump to.
			// Consider these to be just plain text
			textTokens.push(tokens[cursor++]);
		}

		while (cursor < len && (nextState = secondState || state.next(tokens[cursor]))) {

			// Get the next state
			secondState = null;
			state = nextState;

			// Keep track of the latest accepting state
			if (state.accepts()) {
				sinceAccepts = 0;
				latestAccepting = state;
			} else if (sinceAccepts >= 0) {
				sinceAccepts++;
			}

			cursor++;
			multiLength++;
		}

		if (sinceAccepts < 0) {

			// No accepting state was found, part of a regular text token
			// Add all the tokens we looked at to the text tokens array
			for (var i = cursor - multiLength; i < cursor; i++) {
				textTokens.push(tokens[i]);
			}
		} else {

			// Accepting state!

			// First close off the textTokens (if available)
			if (textTokens.length > 0) {
				multis.push(new _multi.TEXT(textTokens));
				textTokens = [];
			}

			// Roll back to the latest accepting state
			cursor -= sinceAccepts;
			multiLength -= sinceAccepts;

			// Create a new multitoken
			var MULTI = latestAccepting.emit();
			multis.push(new MULTI(tokens.slice(cursor - multiLength, cursor)));
		}
	}

	// Finally close off the textTokens (if available)
	if (textTokens.length > 0) {
		multis.push(new _multi.TEXT(textTokens));
	}

	return multis;
};

exports.State = _state.TokenState;
exports.TOKENS = MULTI_TOKENS;
exports.run = run;
exports.start = S_START;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.start = exports.run = exports.TOKENS = exports.State = undefined;

var _state = __webpack_require__(65);

var _text = __webpack_require__(34);

var TOKENS = _interopRequireWildcard(_text);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var tlds = 'aaa|aarp|abb|abbott|abogado|ac|academy|accenture|accountant|accountants|aco|active|actor|ad|adac|ads|adult|ae|aeg|aero|af|afl|ag|agency|ai|aig|airforce|airtel|al|alibaba|alipay|allfinanz|alsace|am|amica|amsterdam|an|analytics|android|ao|apartments|app|apple|aq|aquarelle|ar|aramco|archi|army|arpa|arte|as|asia|associates|at|attorney|au|auction|audi|audio|author|auto|autos|avianca|aw|ax|axa|az|azure|ba|baidu|band|bank|bar|barcelona|barclaycard|barclays|bargains|bauhaus|bayern|bb|bbc|bbva|bcg|bcn|bd|be|beats|beer|bentley|berlin|best|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|bloomberg|blue|bm|bms|bmw|bn|bnl|bnpparibas|bo|boats|boehringer|bom|bond|boo|book|boots|bosch|bostik|bot|boutique|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|camera|camp|cancerresearch|canon|capetown|capital|car|caravan|cards|care|career|careers|cars|cartier|casa|cash|casino|cat|catering|cba|cbn|cc|cd|ceb|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|chase|chat|cheap|chloe|christmas|chrome|church|ci|cipriani|circle|cisco|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cool|coop|corsica|country|coupon|coupons|courses|cr|credit|creditcard|creditunion|cricket|crown|crs|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|date|dating|datsun|day|dclk|de|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|diamonds|diet|digital|direct|directory|discount|dj|dk|dm|dnp|do|docs|dog|doha|domains|download|drive|dubai|durban|dvag|dz|earth|eat|ec|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epson|equipment|er|erni|es|esq|estate|et|eu|eurovision|eus|events|everbank|exchange|expert|exposed|express|fage|fail|fairwinds|faith|family|fan|fans|farm|fashion|fast|feedback|ferrero|fi|film|final|finance|financial|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|florist|flowers|flsmidth|fly|fm|fo|foo|football|ford|forex|forsale|forum|foundation|fox|fr|fresenius|frl|frogans|frontier|fund|furniture|futbol|fyi|ga|gal|gallery|gallup|game|garden|gb|gbiz|gd|gdn|ge|gea|gent|genting|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|gold|goldpoint|golf|goo|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|group|gs|gt|gu|gucci|guge|guide|guitars|guru|gw|gy|hamburg|hangout|haus|hdfcbank|health|healthcare|help|helsinki|here|hermes|hiphop|hitachi|hiv|hk|hm|hn|hockey|holdings|holiday|homedepot|homes|honda|horse|host|hosting|hoteles|hotmail|house|how|hr|hsbc|ht|hu|hyundai|ibm|icbc|ice|icu|id|ie|ifm|iinet|il|im|immo|immobilien|in|industries|infiniti|info|ing|ink|institute|insurance|insure|int|international|investments|io|ipiranga|iq|ir|irish|is|iselect|ist|istanbul|it|itau|iwc|jaguar|java|jcb|je|jetzt|jewelry|jlc|jll|jm|jmp|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kitchen|kiwi|km|kn|koeln|komatsu|kp|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|lamborghini|lamer|lancaster|land|landrover|lanxess|lasalle|lat|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|legal|lexus|lgbt|li|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|limited|limo|lincoln|linde|link|live|living|lixil|lk|loan|loans|local|locus|lol|london|lotte|lotto|love|lr|ls|lt|ltd|ltda|lu|lupin|luxe|luxury|lv|ly|ma|madrid|maif|maison|makeup|man|management|mango|market|marketing|markets|marriott|mba|mc|md|me|med|media|meet|melbourne|meme|memorial|men|menu|meo|mg|mh|miami|microsoft|mil|mini|mk|ml|mm|mma|mn|mo|mobi|mobily|moda|moe|moi|mom|monash|money|montblanc|mormon|mortgage|moscow|motorcycles|mov|movie|movistar|mp|mq|mr|ms|mt|mtn|mtpc|mtr|mu|museum|mutuelle|mv|mw|mx|my|mz|na|nadex|nagoya|name|natura|navy|nc|ne|nec|net|netbank|network|neustar|new|news|nexus|nf|ng|ngo|nhk|ni|nico|nikon|ninja|nissan|nl|no|nokia|norton|nowruz|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|office|okinawa|om|omega|one|ong|onl|online|ooo|oracle|orange|org|organic|origins|osaka|otsuka|ovh|pa|page|pamperedchef|panerai|paris|pars|partners|parts|party|passagens|pe|pet|pf|pg|ph|pharmacy|philips|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pohl|poker|porn|post|pr|praxi|press|pro|prod|productions|prof|promo|properties|property|protection|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|racing|re|read|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|ricoh|rio|rip|ro|rocher|rocks|rodeo|room|rs|rsvp|ru|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|saxo|sb|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scor|scot|sd|se|seat|security|seek|select|sener|services|seven|sew|sex|sexy|sfr|sg|sh|sharp|shell|shia|shiksha|shoes|show|shriram|si|singles|site|sj|sk|ski|skin|sky|skype|sl|sm|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|sr|srl|st|stada|star|starhub|statefarm|statoil|stc|stcgroup|stockholm|storage|store|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiss|sx|sy|sydney|symantec|systems|sz|tab|taipei|taobao|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|team|tech|technology|tel|telecity|telefonica|temasek|tennis|tf|tg|th|thd|theater|theatre|tickets|tienda|tiffany|tips|tires|tirol|tj|tk|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tp|tr|trade|trading|training|travel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubs|ug|uk|unicom|university|uno|uol|us|uy|uz|va|vacations|vana|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|viking|villas|vin|vip|virgin|vision|vista|vistaprint|viva|vlaanderen|vn|vodka|volkswagen|vote|voting|voto|voyage|vu|vuelos|wales|walter|wang|wanggou|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|wme|wolterskluwer|work|works|world|ws|wtc|wtf|xbox|xerox|xin|xperia|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|youtube|yt|za|zara|zero|zip|zm|zone|zuerich|zw'.split('|'); // macro, see gulpfile.js

/**
	The scanner provides an interface that takes a string of text as input, and
	outputs an array of tokens instances that can be used for easy URL parsing.

	@module linkify
	@submodule scanner
	@main scanner
*/

var NUMBERS = '0123456789'.split('');
var ALPHANUM = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
var WHITESPACE = [' ', '\f', '\r', '\t', '\v', '\xA0', '\u1680', '\u180E']; // excluding line breaks

var domainStates = []; // states that jump to DOMAIN on /[a-z0-9]/
var makeState = function makeState(tokenClass) {
	return new _state.CharacterState(tokenClass);
};

// Frequently used states
var S_START = makeState();
var S_NUM = makeState(_text.NUM);
var S_DOMAIN = makeState(_text.DOMAIN);
var S_DOMAIN_HYPHEN = makeState(); // domain followed by 1 or more hyphen characters
var S_WS = makeState(_text.WS);

// States for special URL symbols
S_START.on('@', makeState(_text.AT)).on('.', makeState(_text.DOT)).on('+', makeState(_text.PLUS)).on('#', makeState(_text.POUND)).on('?', makeState(_text.QUERY)).on('/', makeState(_text.SLASH)).on('_', makeState(_text.UNDERSCORE)).on(':', makeState(_text.COLON)).on('{', makeState(_text.OPENBRACE)).on('[', makeState(_text.OPENBRACKET)).on('<', makeState(_text.OPENANGLEBRACKET)).on('(', makeState(_text.OPENPAREN)).on('}', makeState(_text.CLOSEBRACE)).on(']', makeState(_text.CLOSEBRACKET)).on('>', makeState(_text.CLOSEANGLEBRACKET)).on(')', makeState(_text.CLOSEPAREN)).on('&', makeState(_text.AMPERSAND)).on([',', ';', '!', '"', '\''], makeState(_text.PUNCTUATION));

// Whitespace jumps
// Tokens of only non-newline whitespace are arbitrarily long
S_START.on('\n', makeState(_text.NL)).on(WHITESPACE, S_WS);

// If any whitespace except newline, more whitespace!
S_WS.on(WHITESPACE, S_WS);

// Generates states for top-level domains
// Note that this is most accurate when tlds are in alphabetical order
for (var i = 0; i < tlds.length; i++) {
	var newStates = (0, _state.stateify)(tlds[i], S_START, _text.TLD, _text.DOMAIN);
	domainStates.push.apply(domainStates, newStates);
}

// Collect the states generated by different protocls
var partialProtocolFileStates = (0, _state.stateify)('file', S_START, _text.DOMAIN, _text.DOMAIN);
var partialProtocolFtpStates = (0, _state.stateify)('ftp', S_START, _text.DOMAIN, _text.DOMAIN);
var partialProtocolHttpStates = (0, _state.stateify)('http', S_START, _text.DOMAIN, _text.DOMAIN);
var partialProtocolMailtoStates = (0, _state.stateify)('mailto', S_START, _text.DOMAIN, _text.DOMAIN);

// Add the states to the array of DOMAINeric states
domainStates.push.apply(domainStates, partialProtocolFileStates);
domainStates.push.apply(domainStates, partialProtocolFtpStates);
domainStates.push.apply(domainStates, partialProtocolHttpStates);

// Protocol states
var S_PROTOCOL_FILE = partialProtocolFileStates.pop();
var S_PROTOCOL_FTP = partialProtocolFtpStates.pop();
var S_PROTOCOL_HTTP = partialProtocolHttpStates.pop();
var S_MAILTO = partialProtocolMailtoStates.pop();
var S_PROTOCOL_SECURE = makeState(_text.DOMAIN);
var S_FULL_PROTOCOL = makeState(_text.PROTOCOL); // Full protocol ends with COLON
var S_FULL_MAILTO = makeState(_text.MAILTO); // Mailto ends with COLON

// Secure protocols (end with 's')
S_PROTOCOL_FTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);

S_PROTOCOL_HTTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);

domainStates.push(S_PROTOCOL_SECURE);

// Become protocol tokens after a COLON
S_PROTOCOL_FILE.on(':', S_FULL_PROTOCOL);
S_PROTOCOL_SECURE.on(':', S_FULL_PROTOCOL);
S_MAILTO.on(':', S_FULL_MAILTO);

// Localhost
var partialLocalhostStates = (0, _state.stateify)('localhost', S_START, _text.LOCALHOST, _text.DOMAIN);
domainStates.push.apply(domainStates, partialLocalhostStates);

// Everything else
// DOMAINs make more DOMAINs
// Number and character transitions
S_START.on(NUMBERS, S_NUM);
S_NUM.on('-', S_DOMAIN_HYPHEN).on(NUMBERS, S_NUM).on(ALPHANUM, S_DOMAIN); // number becomes DOMAIN

S_DOMAIN.on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);

// All the generated states should have a jump to DOMAIN
for (var _i = 0; _i < domainStates.length; _i++) {
	domainStates[_i].on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
}

S_DOMAIN_HYPHEN.on('-', S_DOMAIN_HYPHEN).on(NUMBERS, S_DOMAIN).on(ALPHANUM, S_DOMAIN);

// Set default transition
S_START.defaultTransition = makeState(_text.SYM);

/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {String} str Input string to scan
	@return {Array} Array of TOKEN instances
*/
var run = function run(str) {

	// The state machine only looks at lowercase strings.
	// This selective `toLowerCase` is used because lowercasing the entire
	// string causes the length and character position to vary in some in some
	// non-English strings. This happens only on V8-based runtimes.
	var lowerStr = str.replace(/[A-Z]/g, function (c) {
		return c.toLowerCase();
	});
	var len = str.length;
	var tokens = []; // return value

	var cursor = 0;

	// Tokenize the string
	while (cursor < len) {
		var state = S_START;
		var secondState = null;
		var nextState = null;
		var tokenLength = 0;
		var latestAccepting = null;
		var sinceAccepts = -1;

		while (cursor < len && (nextState = state.next(lowerStr[cursor]))) {
			secondState = null;
			state = nextState;

			// Keep track of the latest accepting state
			if (state.accepts()) {
				sinceAccepts = 0;
				latestAccepting = state;
			} else if (sinceAccepts >= 0) {
				sinceAccepts++;
			}

			tokenLength++;
			cursor++;
		}

		if (sinceAccepts < 0) {
			continue;
		} // Should never happen

		// Roll back to the latest accepting state
		cursor -= sinceAccepts;
		tokenLength -= sinceAccepts;

		// Get the class for the new token
		var TOKEN = latestAccepting.emit(); // Current token class

		// No more jumps, just make a new token
		tokens.push(new TOKEN(str.substr(cursor - tokenLength, tokenLength)));
	}

	return tokens;
};

var start = S_START;
exports.State = _state.CharacterState;
exports.TOKENS = TOKENS;
exports.run = run;
exports.start = start;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.URL = exports.TEXT = exports.NL = exports.EMAIL = exports.MAILTOEMAIL = exports.Base = undefined;

var _createTokenClass = __webpack_require__(66);

var _class = __webpack_require__(28);

var _text = __webpack_require__(34);

/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/

// Is the given token a valid domain token?
// Should nums be included here?
function isDomainToken(token) {
	return token instanceof _text.DOMAIN || token instanceof _text.TLD;
}

/**
	Abstract class used for manufacturing tokens of text tokens. That is rather
	than the value for a token being a small string of text, it's value an array
	of text tokens.

	Used for grouping together URLs, emails, hashtags, and other potential
	creations.

	@class MultiToken
	@abstract
*/
var MultiToken = (0, _createTokenClass.createTokenClass)();

MultiToken.prototype = {
	/**
 	String representing the type for this token
 	@property type
 	@default 'TOKEN'
 */
	type: 'token',

	/**
 	Is this multitoken a link?
 	@property isLink
 	@default false
 */
	isLink: false,

	/**
 	Return the string this token represents.
 	@method toString
 	@return {String}
 */
	toString: function toString() {
		var result = [];
		for (var i = 0; i < this.v.length; i++) {
			result.push(this.v[i].toString());
		}
		return result.join('');
	},


	/**
 	What should the value for this token be in the `href` HTML attribute?
 	Returns the `.toString` value by default.
 		@method toHref
 	@return {String}
 */
	toHref: function toHref() {
		return this.toString();
	},


	/**
 	Returns a hash of relevant values for this token, which includes keys
 	* type - Kind of token ('url', 'email', etc.)
 	* value - Original text
 	* href - The value that should be added to the anchor tag's href
 		attribute
 		@method toObject
 	@param {String} [protocol] `'http'` by default
 	@return {Object}
 */
	toObject: function toObject() {
		var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';

		return {
			type: this.type,
			value: this.toString(),
			href: this.toHref(protocol)
		};
	}
};

/**
	Represents an arbitrarily mailto email address with the prefix included
	@class MAILTO
	@extends MultiToken
*/
var MAILTOEMAIL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
	type: 'email',
	isLink: true
});

/**
	Represents a list of tokens making up a valid email address
	@class EMAIL
	@extends MultiToken
*/
var EMAIL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
	type: 'email',
	isLink: true,
	toHref: function toHref() {
		var tokens = this.v;
		return 'mailto:' + this.toString();
	}
});

/**
	Represents some plain text
	@class TEXT
	@extends MultiToken
*/
var TEXT = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), { type: 'text' });

/**
	Multi-linebreak token - represents a line break
	@class NL
	@extends MultiToken
*/
var NL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), { type: 'nl' });

/**
	Represents a list of tokens making up a valid URL
	@class URL
	@extends MultiToken
*/
var URL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
	type: 'url',
	isLink: true,

	/**
 	Lowercases relevant parts of the domain and adds the protocol if
 	required. Note that this will not escape unsafe HTML characters in the
 	URL.
 		@method href
 	@param {String} protocol
 	@return {String}
 */
	toHref: function toHref() {
		var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';

		var hasProtocol = false;
		var hasSlashSlash = false;
		var tokens = this.v;
		var result = [];
		var i = 0;

		// Make the first part of the domain lowercase
		// Lowercase protocol
		while (tokens[i] instanceof _text.PROTOCOL) {
			hasProtocol = true;
			result.push(tokens[i].toString().toLowerCase());
			i++;
		}

		// Skip slash-slash
		while (tokens[i] instanceof _text.SLASH) {
			hasSlashSlash = true;
			result.push(tokens[i].toString());
			i++;
		}

		// Lowercase all other characters in the domain
		while (isDomainToken(tokens[i])) {
			result.push(tokens[i].toString().toLowerCase());
			i++;
		}

		// Leave all other characters as they were written
		for (; i < tokens.length; i++) {
			result.push(tokens[i].toString());
		}

		result = result.join('');

		if (!(hasProtocol || hasSlashSlash)) {
			result = protocol + '://' + result;
		}

		return result;
	},
	hasProtocol: function hasProtocol() {
		return this.v[0] instanceof _text.PROTOCOL;
	}
});

exports.Base = MultiToken;
exports.MAILTOEMAIL = MAILTOEMAIL;
exports.EMAIL = EMAIL;
exports.NL = NL;
exports.TEXT = TEXT;
exports.URL = URL;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var defaults = {
	defaultProtocol: 'http',
	events: null,
	format: noop,
	formatHref: noop,
	nl2br: false,
	tagName: 'a',
	target: typeToTarget,
	validate: true,
	ignoreTags: [],
	attributes: null,
	className: 'linkified' };

exports.defaults = defaults;
exports.Options = Options;
exports.contains = contains;


function Options(opts) {
	opts = opts || {};

	this.defaultProtocol = opts.defaultProtocol || defaults.defaultProtocol;
	this.events = opts.events || defaults.events;
	this.format = opts.format || defaults.format;
	this.formatHref = opts.formatHref || defaults.formatHref;
	this.nl2br = opts.nl2br || defaults.nl2br;
	this.tagName = opts.tagName || defaults.tagName;
	this.target = opts.target || defaults.target;
	this.validate = opts.validate || defaults.validate;
	this.ignoreTags = [];

	// linkAttributes and linkClass is deprecated
	this.attributes = opts.attributes || opts.linkAttributes || defaults.attributes;
	this.className = opts.className || opts.linkClass || defaults.className;

	// Make all tags names upper case

	var ignoredTags = opts.ignoreTags || defaults.ignoreTags;
	for (var i = 0; i < ignoredTags.length; i++) {
		this.ignoreTags.push(ignoredTags[i].toUpperCase());
	}
}

Options.prototype = {
	/**
  * Given the token, return all options for how it should be displayed
  */
	resolve: function resolve(token) {
		var href = token.toHref(this.defaultProtocol);
		return {
			formatted: this.get('format', token.toString(), token),
			formattedHref: this.get('formatHref', href, token),
			tagName: this.get('tagName', href, token),
			className: this.get('className', href, token),
			target: this.get('target', href, token),
			events: this.getObject('events', href, token),
			attributes: this.getObject('attributes', href, token)
		};
	},


	/**
  * Returns true or false based on whether a token should be displayed as a
  * link based on the user options. By default,
  */
	check: function check(token) {
		return this.get('validate', token.toString(), token);
	},


	// Private methods

	/**
  * Resolve an option's value based on the value of the option and the given
  * params.
  * @param [String] key Name of option to use
  * @param operator will be passed to the target option if it's method
  * @param [MultiToken] token The token from linkify.tokenize
  */
	get: function get(key, operator, token) {
		var option = this[key];

		if (!option) {
			return option;
		}

		switch (typeof option === 'undefined' ? 'undefined' : _typeof(option)) {
			case 'function':
				return option(operator, token.type);
			case 'object':
				var optionValue = option[token.type] || defaults[key];
				return typeof optionValue === 'function' ? optionValue(operator, token.type) : optionValue;
		}

		return option;
	},
	getObject: function getObject(key, operator, token) {
		var option = this[key];
		return typeof option === 'function' ? option(operator, token.type) : option;
	}
};

/**
 * Quick indexOf replacement for checking the ignoreTags option
 */
function contains(arr, value) {
	for (var i = 0; i < arr.length; i++) {
		if (arr[i] === value) {
			return true;
		}
	}
	return false;
}

function noop(val) {
	return val;
}

function typeToTarget(href, type) {
	return type === 'url' ? '_blank' : null;
}

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(198).default;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports

//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

hooks.defineLocale('af', {
    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM : function (input) {
        return /^nm$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'vm' : 'VM';
        } else {
            return isLower ? 'nm' : 'NM';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Vandag om] LT',
        nextDay : '[Mre om] LT',
        nextWeek : 'dddd [om] LT',
        lastDay : '[Gister om] LT',
        lastWeek : '[Laas] dddd [om] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'oor %s',
        past : '%s gelede',
        s : '\'n paar sekondes',
        m : '\'n minuut',
        mm : '%d minute',
        h : '\'n uur',
        hh : '%d ure',
        d : '\'n dag',
        dd : '%d dae',
        M : '\'n maand',
        MM : '%d maande',
        y : '\'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week : {
        dow : 1, // Maandag is die eerste dag van die week.
        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

hooks.defineLocale('ar-dz', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 4  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

hooks.defineLocale('ar-kw', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

var symbolMap = {
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    '0': '0'
};
var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals = {
    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
};
var pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
            str = plurals[u][pluralForm(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months$1 = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

hooks.defineLocale('ar-ly', {
    months : months$1,
    monthsShort : months$1,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : pluralize('s'),
        m : pluralize('m'),
        mm : pluralize('m'),
        h : pluralize('h'),
        hh : pluralize('h'),
        d : pluralize('d'),
        dd : pluralize('d'),
        M : pluralize('M'),
        MM : pluralize('M'),
        y : pluralize('y'),
        yy : pluralize('y')
    },
    preparse: function (string) {
        return string.replace(/\u200f/g, '').replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

hooks.defineLocale('ar-ma', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

var symbolMap$1 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('ar-sa', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$1[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

hooks.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: ' %s',
        past: ' %s',
        s: '',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

var symbolMap$2 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$1 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};
var pluralForm$1 = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals$1 = {
    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
};
var pluralize$1 = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm$1(number),
            str = plurals$1[u][pluralForm$1(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months$2 = [
    '  ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    '  ',
    '  ',
    '  '
];

hooks.defineLocale('ar', {
    months : months$2,
    monthsShort : months$2,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : pluralize$1('s'),
        m : pluralize$1('m'),
        mm : pluralize$1('m'),
        h : pluralize$1('h'),
        hh : pluralize$1('h'),
        d : pluralize$1('d'),
        dd : pluralize$1('d'),
        M : pluralize$1('M'),
        MM : pluralize$1('M'),
        y : pluralize$1('y'),
        yy : pluralize$1('y')
    },
    preparse: function (string) {
        return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
            return numberMap$1[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$2[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
};

hooks.defineLocale('az', {
    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugn saat] LT',
        nextDay : '[sabah saat] LT',
        nextWeek : '[gln hft] dddd [saat] LT',
        lastDay : '[dnn] LT',
        lastWeek : '[ken hft] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s vvl',
        s : 'birne saniyy',
        m : 'bir dqiq',
        mm : '%d dqiq',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gn',
        dd : '%d gn',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir il',
        yy : '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM : function (input) {
        return /^(gndz|axam)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'gec';
        } else if (hour < 12) {
            return 'shr';
        } else if (hour < 17) {
            return 'gndz';
        } else {
            return 'axam';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '-nc';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else if (key === 'h') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}

hooks.defineLocale('be', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : {
        format: '______'.split('_'),
        standalone: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        lastDay: '[ ] LT',
        nextWeek: function () {
            return '[] dddd [] LT';
        },
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : relativeTimeWithPlural,
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM : function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

hooks.defineLocale('bg', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-';
        } else if (last2Digits === 0) {
            return number + '-';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-';
        } else if (lastDigit === 1) {
            return number + '-';
        } else if (lastDigit === 2) {
            return number + '-';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-';
        } else {
            return number + '-';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

var symbolMap$3 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$2 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('bn', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$2[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$3[match];
        });
    },
    meridiemParse: /||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                (meridiem === '' && hour < 5) ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

var symbolMap$4 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$3 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('bo', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[], LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$3[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$4[match];
        });
    },
    meridiemParse: /||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                (meridiem === '' && hour < 5) ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
        'mm': 'munutenn',
        'MM': 'miz',
        'dd': 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
}
function specialMutationForYears(number) {
    switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
    }
}
function lastNumber(number) {
    if (number > 9) {
        return lastNumber(number % 10);
    }
    return number;
}
function mutation(text, number) {
    if (number === 2) {
        return softMutation(text);
    }
    return text;
}
function softMutation(text) {
    var mutationTable = {
        'm': 'v',
        'b': 'v',
        'd': 'z'
    };
    if (mutationTable[text.charAt(0)] === undefined) {
        return text;
    }
    return mutationTable[text.charAt(0)] + text.substring(1);
}

hooks.defineLocale('br', {
    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h[e]mm A',
        LTS : 'h[e]mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [a viz] MMMM YYYY',
        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
    },
    calendar : {
        sameDay : '[Hiziv da] LT',
        nextDay : '[Warc\'hoazh da] LT',
        nextWeek : 'dddd [da] LT',
        lastDay : '[Dec\'h da] LT',
        lastWeek : 'dddd [paset da] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'a-benn %s',
        past : '%s \'zo',
        s : 'un nebeud segondenno',
        m : 'ur vunutenn',
        mm : relativeTimeWithMutation,
        h : 'un eur',
        hh : '%d eur',
        d : 'un devezh',
        dd : relativeTimeWithMutation,
        M : 'ur miz',
        MM : relativeTimeWithMutation,
        y : 'ur bloaz',
        yy : specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal : function (number) {
        var output = (number === 1) ? 'a' : 'vet';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

hooks.defineLocale('bs', {
    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate,
        mm     : translate,
        h      : translate,
        hh     : translate,
        d      : 'dan',
        dd     : translate,
        M      : 'mjesec',
        MM     : translate,
        y      : 'godinu',
        yy     : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

hooks.defineLocale('ca', {
    months : {
        standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
        isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : '[el] D MMMM [de] YYYY',
        ll : 'D MMM YYYY',
        LLL : '[el] D MMMM [de] YYYY [a les] H:mm',
        lll : 'D MMM YYYY, H:mm',
        LLLL : '[el] dddd D MMMM [de] YYYY [a les] H:mm',
        llll : 'ddd D MMM YYYY, H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextDay : function () {
            return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastDay : function () {
            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'd\'aqu %s',
        past : 'fa %s',
        s : 'uns segons',
        m : 'un minut',
        mm : '%d minuts',
        h : 'una hora',
        hh : '%d hores',
        d : 'un dia',
        dd : '%d dies',
        M : 'un mes',
        MM : '%d mesos',
        y : 'un any',
        yy : '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal : function (number, period) {
        var output = (number === 1) ? 'r' :
            (number === 2) ? 'n' :
            (number === 3) ? 'r' :
            (number === 4) ? 't' : '';
        if (period === 'w' || period === 'W') {
            output = 'a';
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

var months$3 = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
function plural$1(n) {
    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
}
function translate$1(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'dny' : 'dn');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'msce' : 'msc');
            } else {
                return result + 'msci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
    }
}

hooks.defineLocale('cs', {
    months : months$3,
    monthsShort : monthsShort,
    monthsParse : (function (months, monthsShort) {
        var i, _monthsParse = [];
        for (i = 0; i < 12; i++) {
            // use custom parser to solve problem with July (ervenec)
            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
        }
        return _monthsParse;
    }(months$3, monthsShort)),
    shortMonthsParse : (function (monthsShort) {
        var i, _shortMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
        }
        return _shortMonthsParse;
    }(monthsShort)),
    longMonthsParse : (function (months) {
        var i, _longMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
        }
        return _longMonthsParse;
    }(months$3)),
    weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm',
        l : 'D. M. YYYY'
    },
    calendar : {
        sameDay: '[dnes v] LT',
        nextDay: '[ztra v] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve stedu v] LT';
                case 4:
                    return '[ve tvrtek v] LT';
                case 5:
                    return '[v ptek v] LT';
                case 6:
                    return '[v sobotu v] LT';
            }
        },
        lastDay: '[vera v] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minulou nedli v] LT';
                case 1:
                case 2:
                    return '[minul] dddd [v] LT';
                case 3:
                    return '[minulou stedu v] LT';
                case 4:
                case 5:
                    return '[minul] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'ped %s',
        s : translate$1,
        m : translate$1,
        mm : translate$1,
        h : translate$1,
        hh : translate$1,
        d : translate$1,
        dd : translate$1,
        M : translate$1,
        MM : translate$1,
        y : translate$1,
        yy : translate$1
    },
    dayOfMonthOrdinalParse : /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

hooks.defineLocale('cv', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'YYYY [] MMMM [] D[-]',
        LLL : 'YYYY [] MMMM [] D[-], HH:mm',
        LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar : {
        sameDay: '[] LT []',
        nextDay: '[] LT []',
        lastDay: '[] LT []',
        nextWeek: '[] dddd LT []',
        lastWeek: '[] dddd LT []',
        sameElse: 'L'
    },
    relativeTime : {
        future : function (output) {
            var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
            return output + affix;
        },
        past : '%s ',
        s : '- ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal : '%d-',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

hooks.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    // time formats are the same as en-gb
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[Heddiw am] LT',
        nextDay: '[Yfory am] LT',
        nextWeek: 'dddd [am] LT',
        lastDay: '[Ddoe am] LT',
        lastWeek: 'dddd [diwethaf am] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'mewn %s',
        past: '%s yn l',
        s: 'ychydig eiliadau',
        m: 'munud',
        mm: '%d munud',
        h: 'awr',
        hh: '%d awr',
        d: 'diwrnod',
        dd: '%d diwrnod',
        M: 'mis',
        MM: '%d mis',
        y: 'blwyddyn',
        yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
        var b = number,
            output = '',
            lookup = [
                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
            ];
        if (b > 20) {
            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                output = 'fed'; // not 30ain, 70ain or 90ain
            } else {
                output = 'ain';
            }
        } else if (b > 0) {
            output = lookup[b];
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

hooks.defineLocale('da', {
    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay : '[i dag kl.] LT',
        nextDay : '[i morgen kl.] LT',
        nextWeek : 'p dddd [kl.] LT',
        lastDay : '[i gr kl.] LT',
        lastWeek : '[i] dddd[s kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'f sekunder',
        m : 'et minut',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dage',
        M : 'en mned',
        MM : '%d mneder',
        y : 'et r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('de-at', {
    months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

// based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('de-ch', {
    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Febr._Mrz_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH.mm',
        LTS: 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH.mm',
        LLLL : 'dddd, D. MMMM YYYY HH.mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime$1,
        mm : '%d Minuten',
        h : processRelativeTime$1,
        hh : '%d Stunden',
        d : processRelativeTime$1,
        dd : processRelativeTime$1,
        M : processRelativeTime$1,
        MM : processRelativeTime$1,
        y : processRelativeTime$1,
        yy : processRelativeTime$1
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('de', {
    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime$2,
        mm : '%d Minuten',
        h : processRelativeTime$2,
        hh : '%d Stunden',
        d : processRelativeTime$2,
        dd : processRelativeTime$2,
        M : processRelativeTime$2,
        MM : processRelativeTime$2,
        y : processRelativeTime$2,
        yy : processRelativeTime$2
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

var months$4 = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var weekdays = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

hooks.defineLocale('dv', {
    months : months$4,
    monthsShort : months$4,
    weekdays : weekdays,
    weekdaysShort : weekdays,
    weekdaysMin : '______'.split('_'),
    longDateFormat : {

        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/M/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : ' %d',
        h : '',
        hh : ' %d',
        d : '',
        dd : ' %d',
        M : '',
        MM : ' %d',
        y : '',
        yy : ' %d'
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 7,  // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

hooks.defineLocale('el', {
    monthsNominativeEl : '___________'.split('_'),
    monthsGenitiveEl : '___________'.split('_'),
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return this._monthsNominativeEl;
        } else if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
            return this._monthsGenitiveEl[momentToFormat.month()];
        } else {
            return this._monthsNominativeEl[momentToFormat.month()];
        }
    },
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? '' : '';
        } else {
            return isLower ? '' : '';
        }
    },
    isPM : function (input) {
        return ((input + '').toLowerCase()[0] === '');
    },
    meridiemParse : /[]\.??\.?/i,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl : {
        sameDay : '[ {}] LT',
        nextDay : '[ {}] LT',
        nextWeek : 'dddd [{}] LT',
        lastDay : '[ {}] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 6:
                    return '[ ] dddd [{}] LT';
                default:
                    return '[ ] dddd [{}] LT';
            }
        },
        sameElse : 'L'
    },
    calendar : function (key, mom) {
        var output = this._calendarEl[key],
            hours = mom && mom.hours();
        if (isFunction(output)) {
            output = output.apply(mom);
        }
        return output.replace('{}', (hours % 12 === 1 ? '' : ''));
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

hooks.defineLocale('en-au', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

hooks.defineLocale('en-ca', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'YYYY-MM-DD',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

hooks.defineLocale('en-gb', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

hooks.defineLocale('en-ie', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

hooks.defineLocale('en-nz', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean

hooks.defineLocale('eo', {
    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
    weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D[-a de] MMMM, YYYY',
        LLL : 'D[-a de] MMMM, YYYY HH:mm',
        LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
        return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p.t.m.' : 'P.T.M.';
        } else {
            return isLower ? 'a.t.m.' : 'A.T.M.';
        }
    },
    calendar : {
        sameDay : '[Hodia je] LT',
        nextDay : '[Morga je] LT',
        nextWeek : 'dddd [je] LT',
        lastDay : '[Hiera je] LT',
        lastWeek : '[pasinta] dddd [je] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'post %s',
        past : 'anta %s',
        s : 'sekundoj',
        m : 'minuto',
        mm : '%d minutoj',
        h : 'horo',
        hh : '%d horoj',
        d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
        dd : '%d tagoj',
        M : 'monato',
        MM : '%d monatoj',
        y : 'jaro',
        yy : '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal : '%da',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

hooks.defineLocale('es-do', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort$1[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY h:mm A',
        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc

var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

hooks.defineLocale('es', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot$1;
        } else if (/-MMM-/.test(format)) {
            return monthsShort$2[m.month()];
        } else {
            return monthsShortDot$1[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
    var format = {
        's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
        'm' : ['he minuti', 'ks minut'],
        'mm': [number + ' minuti', number + ' minutit'],
        'h' : ['he tunni', 'tund aega', 'ks tund'],
        'hh': [number + ' tunni', number + ' tundi'],
        'd' : ['he peva', 'ks pev'],
        'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
        'MM': [number + ' kuu', number + ' kuud'],
        'y' : ['he aasta', 'aasta', 'ks aasta'],
        'yy': [number + ' aasta', number + ' aastat']
    };
    if (withoutSuffix) {
        return format[key][2] ? format[key][2] : format[key][1];
    }
    return isFuture ? format[key][0] : format[key][1];
}

hooks.defineLocale('et', {
    months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat : {
        LT   : 'H:mm',
        LTS : 'H:mm:ss',
        L    : 'DD.MM.YYYY',
        LL   : 'D. MMMM YYYY',
        LLL  : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[Tna,] LT',
        nextDay  : '[Homme,] LT',
        nextWeek : '[Jrgmine] dddd LT',
        lastDay  : '[Eile,] LT',
        lastWeek : '[Eelmine] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s prast',
        past   : '%s tagasi',
        s      : processRelativeTime$3,
        m      : processRelativeTime$3,
        mm     : processRelativeTime$3,
        h      : processRelativeTime$3,
        hh     : processRelativeTime$3,
        d      : processRelativeTime$3,
        dd     : '%d peva',
        M      : processRelativeTime$3,
        MM     : processRelativeTime$3,
        y      : processRelativeTime$3,
        yy     : processRelativeTime$3
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

hooks.defineLocale('eu', {
    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact : true,
    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY[ko] MMMM[ren] D[a]',
        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
        l : 'YYYY-M-D',
        ll : 'YYYY[ko] MMM D[a]',
        lll : 'YYYY[ko] MMM D[a] HH:mm',
        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar : {
        sameDay : '[gaur] LT[etan]',
        nextDay : '[bihar] LT[etan]',
        nextWeek : 'dddd LT[etan]',
        lastDay : '[atzo] LT[etan]',
        lastWeek : '[aurreko] dddd LT[etan]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s barru',
        past : 'duela %s',
        s : 'segundo batzuk',
        m : 'minutu bat',
        mm : '%d minutu',
        h : 'ordu bat',
        hh : '%d ordu',
        d : 'egun bat',
        dd : '%d egun',
        M : 'hilabete bat',
        MM : '%d hilabete',
        y : 'urte bat',
        yy : '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

var symbolMap$5 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$4 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('fa', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function (input) {
        return /  /.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '  ';
        } else {
            return '  ';
        }
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : 'dddd [] [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[-]/g, function (match) {
            return numberMap$4[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$5[match];
        }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12 // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
var numbersFuture = [
        'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
        numbersPast[7], numbersPast[8], numbersPast[9]
    ];
function translate$2(number, withoutSuffix, key, isFuture) {
    var result = '';
    switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'pivn' : 'piv';
        case 'dd':
            result = isFuture ? 'pivn' : 'piv';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
    }
    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
}
function verbalNumber(number, isFuture) {
    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
}

hooks.defineLocale('fi', {
    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'Do MMMM[ta] YYYY',
        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
        l : 'D.M.YYYY',
        ll : 'Do MMM YYYY',
        lll : 'Do MMM YYYY, [klo] HH.mm',
        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar : {
        sameDay : '[tnn] [klo] LT',
        nextDay : '[huomenna] [klo] LT',
        nextWeek : 'dddd [klo] LT',
        lastDay : '[eilen] [klo] LT',
        lastWeek : '[viime] dddd[na] [klo] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s pst',
        past : '%s sitten',
        s : translate$2,
        m : translate$2,
        mm : translate$2,
        h : translate$2,
        hh : translate$2,
        d : translate$2,
        dd : translate$2,
        M : translate$2,
        MM : translate$2,
        y : translate$2,
        yy : translate$2
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123

hooks.defineLocale('fo', {
    months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ dag kl.] LT',
        nextDay : '[ morgin kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[ gjr kl.] LT',
        lastWeek : '[sstu] dddd [kl] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'um %s',
        past : '%s sani',
        s : 'f sekund',
        m : 'ein minutt',
        mm : '%d minuttir',
        h : 'ein tmi',
        hh : '%d tmar',
        d : 'ein dagur',
        dd : '%d dagar',
        M : 'ein mnai',
        MM : '%d mnair',
        y : 'eitt r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

hooks.defineLocale('fr-ca', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    }
});

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

hooks.defineLocale('fr-ch', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

hooks.defineLocale('fr', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal : function (number, period) {
        switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case 'D':
                return number + (number === 1 ? 'er' : '');

            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

hooks.defineLocale('fy', {
    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[hjoed om] LT',
        nextDay: '[moarn om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[juster om] LT',
        lastWeek: '[frne] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'oer %s',
        past : '%s lyn',
        s : 'in pear sekonden',
        m : 'ien mint',
        mm : '%d minuten',
        h : 'ien oere',
        hh : '%d oeren',
        d : 'ien dei',
        dd : '%d dagen',
        M : 'ien moanne',
        MM : '%d moannen',
        y : 'ien jier',
        yy : '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

var months$5 = [
    'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
];

var monthsShort$3 = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

var weekdays$1 = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

hooks.defineLocale('gd', {
    months : months$5,
    monthsShort : monthsShort$3,
    monthsParseExact : true,
    weekdays : weekdays$1,
    weekdaysShort : weekdaysShort,
    weekdaysMin : weekdaysMin,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[An-diugh aig] LT',
        nextDay : '[A-mireach aig] LT',
        nextWeek : 'dddd [aig] LT',
        lastDay : '[An-d aig] LT',
        lastWeek : 'dddd [seo chaidh] [aig] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ann an %s',
        past : 'bho chionn %s',
        s : 'beagan diogan',
        m : 'mionaid',
        mm : '%d mionaidean',
        h : 'uair',
        hh : '%d uairean',
        d : 'latha',
        dd : '%d latha',
        M : 'mos',
        MM : '%d mosan',
        y : 'bliadhna',
        yy : '%d bliadhna'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
    ordinal : function (number) {
        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

hooks.defineLocale('gl', {
    months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
        },
        lastDay : function () {
            return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
        },
        lastWeek : function () {
            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : function (str) {
            if (str.indexOf('un') === 0) {
                return 'n' + str;
            }
            return 'en ' + str;
        },
        past : 'hai %s',
        s : 'uns segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'unha hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['thodde secondanim', 'thodde second'],
        'm': ['eka mintan', 'ek minute'],
        'mm': [number + ' mintanim', number + ' mintam'],
        'h': ['eka horan', 'ek hor'],
        'hh': [number + ' horanim', number + ' hor'],
        'd': ['eka disan', 'ek dis'],
        'dd': [number + ' disanim', number + ' dis'],
        'M': ['eka mhoinean', 'ek mhoino'],
        'MM': [number + ' mhoineanim', number + ' mhoine'],
        'y': ['eka vorsan', 'ek voros'],
        'yy': [number + ' vorsanim', number + ' vorsam']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('gom-latn', {
    months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
    monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
    weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm [vazta]',
        LTS : 'A h:mm:ss [vazta]',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY A h:mm [vazta]',
        LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
        llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar : {
        sameDay: '[Aiz] LT',
        nextDay: '[Faleam] LT',
        nextWeek: '[Ieta to] dddd[,] LT',
        lastDay: '[Kal] LT',
        lastWeek: '[Fatlo] dddd[,] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s adim',
        s : processRelativeTime$4,
        m : processRelativeTime$4,
        mm : processRelativeTime$4,
        h : processRelativeTime$4,
        hh : processRelativeTime$4,
        d : processRelativeTime$4,
        dd : processRelativeTime$4,
        M : processRelativeTime$4,
        MM : processRelativeTime$4,
        y : processRelativeTime$4,
        yy : processRelativeTime$4
    },
    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
    ordinal : function (number, period) {
        switch (period) {
            // the ordinal 'er' only applies to day of the month
            case 'D':
                return number + 'er';
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
            case 'w':
            case 'W':
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    },
    meridiemParse: /rati|sokalli|donparam|sanje/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'rati') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'sokalli') {
            return hour;
        } else if (meridiem === 'donparam') {
            return hour > 12 ? hour : hour + 12;
        } else if (meridiem === 'sanje') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'rati';
        } else if (hour < 12) {
            return 'sokalli';
        } else if (hour < 16) {
            return 'donparam';
        } else if (hour < 20) {
            return 'sanje';
        } else {
            return 'rati';
        }
    }
});

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

hooks.defineLocale('he', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D []MMMM YYYY',
        LLL : 'D []MMMM YYYY HH:mm',
        LLLL : 'dddd, D []MMMM YYYY HH:mm',
        l : 'D/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ]LT',
        nextDay : '[ ]LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ]LT',
        lastWeek : '[] dddd [ ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        d : '',
        dd : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        M : '',
        MM : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        y : '',
        yy : function (number) {
            if (number === 2) {
                return '';
            } else if (number % 10 === 0 && number !== 10) {
                return number + ' ';
            }
            return number + ' ';
        }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM : function (input) {
        return /^("| |)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 5) {
            return ' ';
        } else if (hour < 10) {
            return '';
        } else if (hour < 12) {
            return isLower ? '"' : ' ';
        } else if (hour < 18) {
            return isLower ? '"' : ' ';
        } else {
            return '';
        }
    }
});

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

var symbolMap$6 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$5 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('hi', {
    months : '___________'.split('_'),
    monthsShort : '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$5[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$6[match];
        });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic

function translate$3(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

hooks.defineLocale('hr', {
    months : {
        format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
        standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate$3,
        mm     : translate$3,
        h      : translate$3,
        hh     : translate$3,
        d      : 'dan',
        dd     : translate$3,
        M      : 'mjesec',
        MM     : translate$3,
        y      : 'godinu',
        yy     : translate$3
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
function translate$4(number, withoutSuffix, key, isFuture) {
    var num = number,
        suffix;
    switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }
    return '';
}
function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
}

hooks.defineLocale('hu', {
    months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
    weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'YYYY.MM.DD.',
        LL : 'YYYY. MMMM D.',
        LLL : 'YYYY. MMMM D. H:mm',
        LLLL : 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
        return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower === true ? 'de' : 'DE';
        } else {
            return isLower === true ? 'du' : 'DU';
        }
    },
    calendar : {
        sameDay : '[ma] LT[-kor]',
        nextDay : '[holnap] LT[-kor]',
        nextWeek : function () {
            return week.call(this, true);
        },
        lastDay : '[tegnap] LT[-kor]',
        lastWeek : function () {
            return week.call(this, false);
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s mlva',
        past : '%s',
        s : translate$4,
        m : translate$4,
        mm : translate$4,
        h : translate$4,
        hh : translate$4,
        d : translate$4,
        dd : translate$4,
        M : translate$4,
        MM : translate$4,
        y : translate$4,
        yy : translate$4
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

hooks.defineLocale('hy-am', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[] LT',
        nextDay: '[] LT',
        lastDay: '[] LT',
        nextWeek: function () {
            return 'dddd [ ] LT';
        },
        lastWeek: function () {
            return '[] dddd [ ] LT';
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    meridiemParse: /|||/,
    isPM: function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-';
                }
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

hooks.defineLocale('id', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'siang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sore' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'siang';
        } else if (hours < 19) {
            return 'sore';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Besok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kemarin pukul] LT',
        lastWeek : 'dddd [lalu pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lalu',
        s : 'beberapa detik',
        m : 'semenit',
        mm : '%d menit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik

function plural$2(n) {
    if (n % 100 === 11) {
        return true;
    } else if (n % 10 === 1) {
        return false;
    }
    return true;
}
function translate$5(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
        case 'm':
            return withoutSuffix ? 'mnta' : 'mntu';
        case 'mm':
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
            } else if (withoutSuffix) {
                return result + 'mnta';
            }
            return result + 'mntu';
        case 'hh':
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (plural$2(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dgum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mnuur';
            }
            return isFuture ? 'mnu' : 'mnui';
        case 'MM':
            if (plural$2(number)) {
                if (withoutSuffix) {
                    return result + 'mnuir';
                }
                return result + (isFuture ? 'mnui' : 'mnuum');
            } else if (withoutSuffix) {
                return result + 'mnuur';
            }
            return result + (isFuture ? 'mnu' : 'mnui');
        case 'y':
            return withoutSuffix || isFuture ? 'r' : 'ri';
        case 'yy':
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
            }
            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
}

hooks.defineLocale('is', {
    months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar : {
        sameDay : '[ dag kl.] LT',
        nextDay : '[ morgun kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[ gr kl.] LT',
        lastWeek : '[sasta] dddd [kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'eftir %s',
        past : 'fyrir %s san',
        s : translate$5,
        m : translate$5,
        mm : translate$5,
        h : 'klukkustund',
        hh : translate$5,
        d : translate$5,
        dd : translate$5,
        M : translate$5,
        MM : translate$5,
        y : translate$5,
        yy : translate$5
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

hooks.defineLocale('it', {
    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Oggi alle] LT',
        nextDay: '[Domani alle] LT',
        nextWeek: 'dddd [alle] LT',
        lastDay: '[Ieri alle] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[la scorsa] dddd [alle] LT';
                default:
                    return '[lo scorso] dddd [alle] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : function (s) {
            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
        },
        past : '%s fa',
        s : 'alcuni secondi',
        m : 'un minuto',
        mm : '%d minuti',
        h : 'un\'ora',
        hh : '%d ore',
        d : 'un giorno',
        dd : '%d giorni',
        M : 'un mese',
        MM : '%d mesi',
        y : 'un anno',
        yy : '%d anni'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

hooks.defineLocale('ja', {
    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYYMD',
        LLL : 'YYYYMD HH:mm',
        LLLL : 'YYYYMD HH:mm dddd',
        l : 'YYYY/MM/DD',
        ll : 'YYYYMD',
        lll : 'YYYYMD HH:mm',
        llll : 'YYYYMD HH:mm dddd'
    },
    meridiemParse: /|/i,
    isPM : function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[]dddd LT',
        lastDay : '[] LT',
        lastWeek : '[]dddd LT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1',
        mm : '%d',
        h : '1',
        hh : '%d',
        d : '1',
        dd : '%d',
        M : '1',
        MM : '%d',
        y : '1',
        yy : '%d'
    }
});

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

hooks.defineLocale('jv', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'enjing') {
            return hour;
        } else if (meridiem === 'siyang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'enjing';
        } else if (hours < 15) {
            return 'siyang';
        } else if (hours < 19) {
            return 'sonten';
        } else {
            return 'ndalu';
        }
    },
    calendar : {
        sameDay : '[Dinten puniko pukul] LT',
        nextDay : '[Mbenjang pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kala wingi pukul] LT',
        lastWeek : 'dddd [kepengker pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'wonten ing %s',
        past : '%s ingkang kepengker',
        s : 'sawetawis detik',
        m : 'setunggal menit',
        mm : '%d menit',
        h : 'setunggal jam',
        hh : '%d jam',
        d : 'sedinten',
        dd : '%d dinten',
        M : 'sewulan',
        MM : '%d wulan',
        y : 'setaun',
        yy : '%d taun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

hooks.defineLocale('ka', {
    months : {
        standalone: '___________'.split('_'),
        format: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /(|)/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[] LT[-]',
        nextDay : '[] LT[-]',
        lastDay : '[] LT[-]',
        nextWeek : '[] dddd LT[-]',
        lastWeek : '[] dddd LT-',
        sameElse : 'L'
    },
    relativeTime : {
        future : function (s) {
            return (/(|||)/).test(s) ?
                s.replace(/$/, '') :
                s + '';
        },
        past : function (s) {
            if ((/(||||)/).test(s)) {
                return s.replace(/(|)$/, ' ');
            }
            if ((//).test(s)) {
                return s.replace(/$/, ' ');
            }
        },
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal : function (number) {
        if (number === 0) {
            return number;
        }
        if (number === 1) {
            return number + '-';
        }
        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
            return '-' + number;
        }
        return number + '-';
    },
    week : {
        dow : 1,
        doy : 7
    }
});

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

var suffixes$1 = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
};

hooks.defineLocale('kk', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : '[ ] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

hooks.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[ ] LT',
        lastWeek: 'dddd [] [] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: '%s',
        past: '%s',
        s: '',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

var symbolMap$7 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$6 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('kn', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$6[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$7[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal : function (number) {
        return number + '';
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

hooks.defineLocale('ko', {
    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'YYYY.MM.DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D A h:mm',
        LLLL : 'YYYY MMMM D dddd A h:mm',
        l : 'YYYY.MM.DD',
        ll : 'YYYY MMMM D',
        lll : 'YYYY MMMM D A h:mm',
        llll : 'YYYY MMMM D dddd A h:mm'
    },
    calendar : {
        sameDay : ' LT',
        nextDay : ' LT',
        nextWeek : 'dddd LT',
        lastDay : ' LT',
        lastWeek : ' dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        ss : '%d',
        m : '1',
        mm : '%d',
        h : ' ',
        hh : '%d',
        d : '',
        dd : '%d',
        M : ' ',
        MM : '%d',
        y : ' ',
        yy : '%d'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    meridiemParse : /|/,
    isPM : function (token) {
        return token === '';
    },
    meridiem : function (hour, minute, isUpper) {
        return hour < 12 ? '' : '';
    }
});

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz


var suffixes$2 = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
};

hooks.defineLocale('ky', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : '[ ] dddd [] [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eng Minutt', 'enger Minutt'],
        'h': ['eng Stonn', 'enger Stonn'],
        'd': ['een Dag', 'engem Dag'],
        'M': ['ee Mount', 'engem Mount'],
        'y': ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}
function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'a ' + string;
    }
    return 'an ' + string;
}
function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'viru ' + string;
    }
    return 'virun ' + string;
}
/**
 * Returns true if the word before the given number loses the '-n' ending.
 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
 *
 * @param number {integer}
 * @returns {boolean}
 */
function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);
    if (isNaN(number)) {
        return false;
    }
    if (number < 0) {
        // Negative Number --> always true
        return true;
    } else if (number < 10) {
        // Only 1 digit
        if (4 <= number && number <= 7) {
            return true;
        }
        return false;
    } else if (number < 100) {
        // 2 digits
        var lastDigit = number % 10, firstDigit = number / 10;
        if (lastDigit === 0) {
            return eifelerRegelAppliesToNumber(firstDigit);
        }
        return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
        // 3 or 4 digits --> recursively check first digit
        while (number >= 10) {
            number = number / 10;
        }
        return eifelerRegelAppliesToNumber(number);
    } else {
        // Anything larger than 4 digits: recursively check first n-3 digits
        number = number / 1000;
        return eifelerRegelAppliesToNumber(number);
    }
}

hooks.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm [Auer]',
        LTS: 'H:mm:ss [Auer]',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm [Auer]',
        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
        sameDay: '[Haut um] LT',
        sameElse: 'L',
        nextDay: '[Muer um] LT',
        nextWeek: 'dddd [um] LT',
        lastDay: '[Gschter um] LT',
        lastWeek: function () {
            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
            switch (this.day()) {
                case 2:
                case 4:
                    return '[Leschten] dddd [um] LT';
                default:
                    return '[Leschte] dddd [um] LT';
            }
        }
    },
    relativeTime : {
        future : processFutureTime,
        past : processPastTime,
        s : 'e puer Sekonnen',
        m : processRelativeTime$5,
        mm : '%d Minutten',
        h : processRelativeTime$5,
        hh : '%d Stonnen',
        d : processRelativeTime$5,
        dd : '%d Deeg',
        M : processRelativeTime$5,
        MM : '%d Mint',
        y : processRelativeTime$5,
        yy : '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

hooks.defineLocale('lo', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[]dddd[] LT',
        lastDay : '[] LT',
        lastWeek : '[]dddd[] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal : function (number) {
        return '' + number;
    }
});

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras

var units = {
    'm' : 'minut_minuts_minut',
    'mm': 'minuts_minui_minutes',
    'h' : 'valanda_valandos_valand',
    'hh': 'valandos_valand_valandas',
    'd' : 'diena_dienos_dien',
    'dd': 'dienos_dien_dienas',
    'M' : 'mnuo_mnesio_mnes',
    'MM': 'mnesiai_mnesi_mnesius',
    'y' : 'metai_met_metus',
    'yy': 'metai_met_metus'
};
function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
        return 'kelios sekunds';
    } else {
        return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
}
function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
}
function special(number) {
    return number % 10 === 0 || (number > 10 && number < 20);
}
function forms(key) {
    return units[key].split('_');
}
function translate$6(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    if (number === 1) {
        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
        if (isFuture) {
            return result + forms(key)[1];
        } else {
            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
        }
    }
}
hooks.defineLocale('lt', {
    months : {
        format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
        standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays : {
        format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
        standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
        isFormat: /dddd HH:mm/
    },
    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY [m.] MMMM D [d.]',
        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
        l : 'YYYY-MM-DD',
        ll : 'YYYY [m.] MMMM D [d.]',
        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar : {
        sameDay : '[iandien] LT',
        nextDay : '[Rytoj] LT',
        nextWeek : 'dddd LT',
        lastDay : '[Vakar] LT',
        lastWeek : '[Prajus] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'po %s',
        past : 'prie %s',
        s : translateSeconds,
        m : translateSingular,
        mm : translate$6,
        h : translateSingular,
        hh : translate$6,
        d : translateSingular,
        dd : translate$6,
        M : translateSingular,
        MM : translate$6,
        y : translateSingular,
        yy : translate$6
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal : function (number) {
        return number + '-oji';
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

var units$1 = {
    'm': 'mintes_mintm_minte_mintes'.split('_'),
    'mm': 'mintes_mintm_minte_mintes'.split('_'),
    'h': 'stundas_stundm_stunda_stundas'.split('_'),
    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
    'd': 'dienas_dienm_diena_dienas'.split('_'),
    'dd': 'dienas_dienm_diena_dienas'.split('_'),
    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'y': 'gada_gadiem_gads_gadi'.split('_'),
    'yy': 'gada_gadiem_gads_gadi'.split('_')
};
/**
 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
 */
function format$1(forms, number, withoutSuffix) {
    if (withoutSuffix) {
        // E.g. "21 minte", "3 mintes".
        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
        // E.g. "21 mintes" as in "pc 21 mintes".
        // E.g. "3 mintm" as in "pc 3 mintm".
        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
}
function relativeTimeWithPlural$1(number, withoutSuffix, key) {
    return number + ' ' + format$1(units$1[key], number, withoutSuffix);
}
function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format$1(units$1[key], number, withoutSuffix);
}
function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
}

hooks.defineLocale('lv', {
    months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY.',
        LL : 'YYYY. [gada] D. MMMM',
        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar : {
        sameDay : '[odien pulksten] LT',
        nextDay : '[Rt pulksten] LT',
        nextWeek : 'dddd [pulksten] LT',
        lastDay : '[Vakar pulksten] LT',
        lastWeek : '[Pagju] dddd [pulksten] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'pc %s',
        past : 'pirms %s',
        s : relativeSeconds,
        m : relativeTimeWithSingular,
        mm : relativeTimeWithPlural$1,
        h : relativeTimeWithSingular,
        hh : relativeTimeWithPlural$1,
        d : relativeTimeWithSingular,
        dd : relativeTimeWithPlural$1,
        M : relativeTimeWithSingular,
        MM : relativeTimeWithPlural$1,
        y : relativeTimeWithSingular,
        yy : relativeTimeWithPlural$1
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

var translator = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jednog minuta'],
        mm: ['minut', 'minuta', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mjesec', 'mjeseca', 'mjeseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

hooks.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact : true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sjutra u] LT',

        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jue u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prole] [nedjelje] [u] LT',
                '[prolog] [ponedjeljka] [u] LT',
                '[prolog] [utorka] [u] LT',
                '[prole] [srijede] [u] LT',
                '[prolog] [etvrtka] [u] LT',
                '[prolog] [petka] [u] LT',
                '[prole] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'nekoliko sekundi',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : 'dan',
        dd     : translator.translate,
        M      : 'mjesec',
        MM     : translator.translate,
        y      : 'godinu',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

hooks.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY [i] HH:mm',
        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
        sameDay: '[i teie mahana, i] LT',
        nextDay: '[apopo i] LT',
        nextWeek: 'dddd [i] LT',
        lastDay: '[inanahi i] LT',
        lastWeek: 'dddd [whakamutunga i] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'i roto i %s',
        past: '%s i mua',
        s: 'te hkona ruarua',
        m: 'he meneti',
        mm: '%d meneti',
        h: 'te haora',
        hh: '%d haora',
        d: 'he ra',
        dd: '%d ra',
        M: 'he marama',
        MM: '%d marama',
        y: 'he tau',
        yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0

hooks.defineLocale('mk', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : 'e_o_____a'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : '[] dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-';
        } else if (last2Digits === 0) {
            return number + '-';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-';
        } else if (lastDigit === 1) {
            return number + '-';
        } else if (lastDigit === 2) {
            return number + '-';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-';
        } else {
            return number + '-';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

hooks.defineLocale('ml', {
    months : '___________'.split('_'),
    monthsShort : '._._._.___._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm -',
        LTS : 'A h:mm:ss -',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm -',
        LLLL : 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                meridiem === ' ' ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return ' ';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    }
});

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

var symbolMap$8 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$7 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

function relativeTimeMr(number, withoutSuffix, string, isFuture)
{
    var output = '';
    if (withoutSuffix) {
        switch (string) {
            case 's': output = ' '; break;
            case 'm': output = ' '; break;
            case 'mm': output = '%d '; break;
            case 'h': output = ' '; break;
            case 'hh': output = '%d '; break;
            case 'd': output = ' '; break;
            case 'dd': output = '%d '; break;
            case 'M': output = ' '; break;
            case 'MM': output = '%d '; break;
            case 'y': output = ' '; break;
            case 'yy': output = '%d '; break;
        }
    }
    else {
        switch (string) {
            case 's': output = ' '; break;
            case 'm': output = ' '; break;
            case 'mm': output = '%d '; break;
            case 'h': output = ' '; break;
            case 'hh': output = '%d '; break;
            case 'd': output = ' '; break;
            case 'dd': output = '%d '; break;
            case 'M': output = ' '; break;
            case 'MM': output = '%d '; break;
            case 'y': output = ' '; break;
            case 'yy': output = '%d '; break;
        }
    }
    return output.replace(/%d/i, number);
}

hooks.defineLocale('mr', {
    months : '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek: '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future: '%s',
        past: '%s',
        s: relativeTimeMr,
        m: relativeTimeMr,
        mm: relativeTimeMr,
        h: relativeTimeMr,
        hh: relativeTimeMr,
        d: relativeTimeMr,
        dd: relativeTimeMr,
        M: relativeTimeMr,
        MM: relativeTimeMr,
        y: relativeTimeMr,
        yy: relativeTimeMr
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$7[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$8[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem: function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

hooks.defineLocale('ms-my', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

hooks.defineLocale('ms', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

var symbolMap$9 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$8 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),

    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[.] LT []',
        nextDay: '[] LT []',
        nextWeek: 'dddd LT []',
        lastDay: '[.] LT []',
        lastWeek: '[] dddd LT []',
        sameElse: 'L'
    },
    relativeTime: {
        future: ' %s ',
        past: ' %s ',
        s: '.',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$8[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$9[match];
        });
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

hooks.defineLocale('nb', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[i dag kl.] LT',
        nextDay: '[i morgen kl.] LT',
        nextWeek: 'dddd [kl.] LT',
        lastDay: '[i gr kl.] LT',
        lastWeek: '[forrige] dddd [kl.] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'noen sekunder',
        m : 'ett minutt',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dager',
        M : 'en mned',
        MM : '%d mneder',
        y : 'ett r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

var symbolMap$10 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$9 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('ne', {
    months : '___________'.split('_'),
    monthsShort : '._.__.___._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '._._._._._._.'.split('_'),
    weekdaysMin : '._._._._._._.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$9[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$10[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 3) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 16) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[] dddd[,] LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd[,] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex$1 = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

hooks.defineLocale('nl-be', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots$1;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots$1[m.month()];
        } else {
            return monthsShortWithDots$1[m.month()];
        }
    },

    monthsRegex: monthsRegex$1,
    monthsShortRegex: monthsRegex$1,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'n minuut',
        mm : '%d minuten',
        h : 'n uur',
        hh : '%d uur',
        d : 'n dag',
        dd : '%d dagen',
        M : 'n maand',
        MM : '%d maanden',
        y : 'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse$1 = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex$2 = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

hooks.defineLocale('nl', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots$2;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots$2[m.month()];
        } else {
            return monthsShortWithDots$2[m.month()];
        }
    },

    monthsRegex: monthsRegex$2,
    monthsShortRegex: monthsRegex$2,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse$1,
    longMonthsParse : monthsParse$1,
    shortMonthsParse : monthsParse$1,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'n minuut',
        mm : '%d minuten',
        h : 'n uur',
        hh : '%d uur',
        d : 'n dag',
        dd : '%d dagen',
        M : 'n maand',
        MM : '%d maanden',
        y : 'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! author : https://github.com/mechuwind

hooks.defineLocale('nn', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
    weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[I dag klokka] LT',
        nextDay: '[I morgon klokka] LT',
        nextWeek: 'dddd [klokka] LT',
        lastDay: '[I gr klokka] LT',
        lastWeek: '[Fregande] dddd [klokka] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s sidan',
        s : 'nokre sekund',
        m : 'eit minutt',
        mm : '%d minutt',
        h : 'ein time',
        hh : '%d timar',
        d : 'ein dag',
        dd : '%d dagar',
        M : 'ein mnad',
        MM : '%d mnader',
        y : 'eit r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

var symbolMap$11 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$10 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$10[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$11[match];
        });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
function plural$3(n) {
    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
}
function translate$7(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minut';
        case 'mm':
            return result + (plural$3(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzin';
        case 'hh':
            return result + (plural$3(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural$3(number) ? 'miesice' : 'miesicy');
        case 'yy':
            return result + (plural$3(number) ? 'lata' : 'lat');
    }
}

hooks.defineLocale('pl', {
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return monthsNominative;
        } else if (format === '') {
            // Hack: if format empty we know this is used to generate
            // RegExp by moment. Give then back both valid forms of months
            // in RegExp ready format.
            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
        } else if (/D MMMM/.test(format)) {
            return monthsSubjective[momentToFormat.month()];
        } else {
            return monthsNominative[momentToFormat.month()];
        }
    },
    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Dzi o] LT',
        nextDay: '[Jutro o] LT',
        nextWeek: '[W] dddd [o] LT',
        lastDay: '[Wczoraj o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[W zesz niedziel o] LT';
                case 3:
                    return '[W zesz rod o] LT';
                case 6:
                    return '[W zesz sobot o] LT';
                default:
                    return '[W zeszy] dddd [o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : '%s temu',
        s : 'kilka sekund',
        m : translate$7,
        mm : translate$7,
        h : translate$7,
        hh : translate$7,
        d : '1 dzie',
        dd : '%d dni',
        M : 'miesic',
        MM : translate$7,
        y : 'rok',
        yy : translate$7
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

hooks.defineLocale('pt-br', {
    months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar : {
        sameDay: '[Hoje s] LT',
        nextDay: '[Amanh s] LT',
        nextWeek: 'dddd [s] LT',
        lastDay: '[Ontem s] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : '%s atrs',
        s : 'poucos segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um ms',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d'
});

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

hooks.defineLocale('pt', {
    months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hoje s] LT',
        nextDay: '[Amanh s] LT',
        nextWeek: 'dddd [s] LT',
        lastDay: '[Ontem s] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : 'h %s',
        s : 'segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um ms',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

function relativeTimeWithPlural$2(number, withoutSuffix, key) {
    var format = {
            'mm': 'minute',
            'hh': 'ore',
            'dd': 'zile',
            'MM': 'luni',
            'yy': 'ani'
        },
        separator = ' ';
    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
        separator = ' de ';
    }
    return number + separator + format[key];
}

hooks.defineLocale('ro', {
    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[azi la] LT',
        nextDay: '[mine la] LT',
        nextWeek: 'dddd [la] LT',
        lastDay: '[ieri la] LT',
        lastWeek: '[fosta] dddd [la] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'peste %s',
        past : '%s n urm',
        s : 'cteva secunde',
        m : 'un minut',
        mm : relativeTimeWithPlural$2,
        h : 'o or',
        hh : relativeTimeWithPlural$2,
        d : 'o zi',
        dd : relativeTimeWithPlural$2,
        M : 'o lun',
        MM : relativeTimeWithPlural$2,
        y : 'un an',
        yy : relativeTimeWithPlural$2
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

function plural$4(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural$3(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural$4(format[key], +number);
    }
}
var monthsParse$2 = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

// http://new.gramota.ru/spravka/rules/139-prop :  103
//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
hooks.defineLocale('ru', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : {
        //  CLDR  "."  ".",        ?
        format: '._._._.____._._._._.'.split('_'),
        standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays : {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    monthsParse : monthsParse$2,
    longMonthsParse : monthsParse$2,
    shortMonthsParse : monthsParse$2,

    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        lastDay: '[ ] LT',
        nextWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[] dddd [] LT';
                } else {
                    return '[] dddd [] LT';
                }
            }
        },
        lastWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[] dddd [] LT';
                } else {
                    return '[] dddd [] LT';
                }
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural$3,
        mm : relativeTimeWithPlural$3,
        h : '',
        hh : relativeTimeWithPlural$3,
        d : '',
        dd : relativeTimeWithPlural$3,
        M : '',
        MM : relativeTimeWithPlural$3,
        y : '',
        yy : relativeTimeWithPlural$3
    },
    meridiemParse: /|||/i,
    isPM : function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

var months$6 = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var days$1 = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

hooks.defineLocale('sd', {
    months : months$6,
    monthsShort : months$6,
    weekdays : days$1,
    weekdaysShort : days$1,
    weekdaysMin : days$1,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        }
        return '';
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd [  ] LT',
        lastDay : '[] LT',
        lastWeek : '[ ] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell


hooks.defineLocale('se', {
    months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'MMMM D. [b.] YYYY',
        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar : {
        sameDay: '[otne ti] LT',
        nextDay: '[ihttin ti] LT',
        nextWeek: 'dddd [ti] LT',
        lastDay: '[ikte ti] LT',
        lastWeek: '[ovddit] dddd [ti] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s geaes',
        past : 'mait %s',
        s : 'moadde sekunddat',
        m : 'okta minuhta',
        mm : '%d minuhtat',
        h : 'okta diimmu',
        hh : '%d diimmut',
        d : 'okta beaivi',
        dd : '%d beaivvit',
        M : 'okta mnnu',
        MM : '%d mnut',
        y : 'okta jahki',
        yy : '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

/*jshint -W100*/
hooks.defineLocale('si', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'a h:mm',
        LTS : 'a h:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D, a h:mm',
        LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar : {
        sameDay : '[] LT[]',
        nextDay : '[] LT[]',
        nextWeek : 'dddd LT[]',
        lastDay : '[] LT[]',
        lastWeek : '[] dddd LT[]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s ',
        s : ' ',
        m : '',
        mm : ' %d',
        h : '',
        hh : ' %d',
        d : '',
        dd : ' %d',
        M : '',
        MM : ' %d',
        y : '',
        yy : ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal : function (number) {
        return number + ' ';
    },
    meridiemParse : / | |.|../,
    isPM : function (input) {
        return input === '..' || input === ' ';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? '..' : ' ';
        } else {
            return isLower ? '..' : ' ';
        }
    }
});

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

var months$7 = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
var monthsShort$4 = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
function plural$5(n) {
    return (n > 1) && (n < 5);
}
function translate$8(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'minty' : 'mint');
            } else {
                return result + 'mintami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'hodiny' : 'hodn');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de' : 'dom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'dni' : 'dn');
            } else {
                return result + 'dami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
    }
}

hooks.defineLocale('sk', {
    months : months$7,
    monthsShort : monthsShort$4,
    weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[dnes o] LT',
        nextDay: '[zajtra o] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedeu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
            }
        },
        lastDay: '[vera o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minul nedeu o] LT';
                case 1:
                case 2:
                    return '[minul] dddd [o] LT';
                case 3:
                    return '[minul stredu o] LT';
                case 4:
                case 5:
                    return '[minul] dddd [o] LT';
                case 6:
                    return '[minul sobotu o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'pred %s',
        s : translate$8,
        m : translate$8,
        mm : translate$8,
        h : translate$8,
        hh : translate$8,
        d : translate$8,
        dd : translate$8,
        M : translate$8,
        MM : translate$8,
        y : translate$8,
        yy : translate$8
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek

function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
    }
}

hooks.defineLocale('sl', {
    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danes ob] LT',
        nextDay  : '[jutri ob] LT',

        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
            }
        },
        lastDay  : '[veraj ob] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[prejnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejnji] dddd [ob] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ez %s',
        past   : 'pred %s',
        s      : processRelativeTime$6,
        m      : processRelativeTime$6,
        mm     : processRelativeTime$6,
        h      : processRelativeTime$6,
        hh     : processRelativeTime$6,
        d      : processRelativeTime$6,
        dd     : processRelativeTime$6,
        M      : processRelativeTime$6,
        MM     : processRelativeTime$6,
        y      : processRelativeTime$6,
        yy     : processRelativeTime$6
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

hooks.defineLocale('sq', {
    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
        return input.charAt(0) === 'M';
    },
    meridiem : function (hours, minutes, isLower) {
        return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Sot n] LT',
        nextDay : '[Nesr n] LT',
        nextWeek : 'dddd [n] LT',
        lastDay : '[Dje n] LT',
        lastWeek : 'dddd [e kaluar n] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'n %s',
        past : '%s m par',
        s : 'disa sekonda',
        m : 'nj minut',
        mm : '%d minuta',
        h : 'nj or',
        hh : '%d or',
        d : 'nj dit',
        dd : '%d dit',
        M : 'nj muaj',
        MM : '%d muaj',
        y : 'nj vit',
        yy : '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

var translator$1 = {
    words: { //Different grammatical cases
        m: [' ', ' '],
        mm: ['', '', ''],
        h: [' ', ' '],
        hh: ['', '', ''],
        dd: ['', '', ''],
        MM: ['', '', ''],
        yy: ['', '', '']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator$1.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator$1.correctGrammaticalCase(number, wordKey);
        }
    }
};

hooks.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[] [] [] LT';
                case 3:
                    return '[] [] [] LT';
                case 6:
                    return '[] [] [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
            }
        },
        lastDay  : '[ ] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past   : ' %s',
        s      : ' ',
        m      : translator$1.translate,
        mm     : translator$1.translate,
        h      : translator$1.translate,
        hh     : translator$1.translate,
        d      : '',
        dd     : translator$1.translate,
        M      : '',
        MM     : translator$1.translate,
        y      : '',
        yy     : translator$1.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

var translator$2 = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jedne minute'],
        mm: ['minut', 'minute', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mesec', 'meseca', 'meseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator$2.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator$2.correctGrammaticalCase(number, wordKey);
        }
    }
};

hooks.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sutra u] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jue u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prole] [nedelje] [u] LT',
                '[prolog] [ponedeljka] [u] LT',
                '[prolog] [utorka] [u] LT',
                '[prole] [srede] [u] LT',
                '[prolog] [etvrtka] [u] LT',
                '[prolog] [petka] [u] LT',
                '[prole] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'pre %s',
        s      : 'nekoliko sekundi',
        m      : translator$2.translate,
        mm     : translator$2.translate,
        h      : translator$2.translate,
        hh     : translator$2.translate,
        d      : 'dan',
        dd     : translator$2.translate,
        M      : 'mesec',
        MM     : translator$2.translate,
        y      : 'godinu',
        yy     : translator$2.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies


hooks.defineLocale('ss', {
    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Namuhla nga] LT',
        nextDay : '[Kusasa nga] LT',
        nextWeek : 'dddd [nga] LT',
        lastDay : '[Itolo nga] LT',
        lastWeek : 'dddd [leliphelile] [nga] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'nga %s',
        past : 'wenteka nga %s',
        s : 'emizuzwana lomcane',
        m : 'umzuzu',
        mm : '%d emizuzu',
        h : 'lihora',
        hh : '%d emahora',
        d : 'lilanga',
        dd : '%d emalanga',
        M : 'inyanga',
        MM : '%d tinyanga',
        y : 'umnyaka',
        yy : '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'ekuseni';
        } else if (hours < 15) {
            return 'emini';
        } else if (hours < 19) {
            return 'entsambama';
        } else {
            return 'ebusuku';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'ekuseni') {
            return hour;
        } else if (meridiem === 'emini') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
            if (hour === 0) {
                return 0;
            }
            return hour + 12;
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

hooks.defineLocale('sv', {
    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Idag] LT',
        nextDay: '[Imorgon] LT',
        lastDay: '[Igr] LT',
        nextWeek: '[P] dddd LT',
        lastWeek: '[I] dddd[s] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : 'fr %s sedan',
        s : 'ngra sekunder',
        m : 'en minut',
        mm : '%d minuter',
        h : 'en timme',
        hh : '%d timmar',
        d : 'en dag',
        dd : '%d dagar',
        M : 'en mnad',
        MM : '%d mnader',
        y : 'ett r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'e' :
            (b === 1) ? 'a' :
            (b === 2) ? 'a' :
            (b === 3) ? 'e' : 'e';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

hooks.defineLocale('sw', {
    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[leo saa] LT',
        nextDay : '[kesho saa] LT',
        nextWeek : '[wiki ijayo] dddd [saat] LT',
        lastDay : '[jana] LT',
        lastWeek : '[wiki iliyopita] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s baadaye',
        past : 'tokea %s',
        s : 'hivi punde',
        m : 'dakika moja',
        mm : 'dakika %d',
        h : 'saa limoja',
        hh : 'masaa %d',
        d : 'siku moja',
        dd : 'masiku %d',
        M : 'mwezi mmoja',
        MM : 'miezi %d',
        y : 'mwaka mmoja',
        yy : 'miaka %d'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

var symbolMap$12 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap$11 = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

hooks.defineLocale('ta', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, HH:mm',
        LLLL : 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[ ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : ' ',
        mm : '%d ',
        h : '  ',
        hh : '%d  ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number + '';
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap$11[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$12[match];
        });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem : function (hour, minute, isLower) {
        if (hour < 2) {
            return ' ';
        } else if (hour < 6) {
            return ' ';  // 
        } else if (hour < 10) {
            return ' '; // 
        } else if (hour < 14) {
            return ' '; // 
        } else if (hour < 18) {
            return ' '; // 
        } else if (hour < 22) {
            return ' '; // 
        } else {
            return ' ';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 2 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else {
            return hour + 12;
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

hooks.defineLocale('te', {
    months : '___________'.split('_'),
    monthsShort : '._.__.____._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo

hooks.defineLocale('tet', {
    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Ohin iha] LT',
        nextDay: '[Aban iha] LT',
        nextWeek: 'dddd [iha] LT',
        lastDay: '[Horiseik iha] LT',
        lastWeek: 'dddd [semana kotuk] [iha] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'iha %s',
        past : '%s liuba',
        s : 'minutu balun',
        m : 'minutu ida',
        mm : 'minutus %d',
        h : 'horas ida',
        hh : 'horas %d',
        d : 'loron ida',
        dd : 'loron %d',
        M : 'fulan ida',
        MM : 'fulan %d',
        y : 'tinan ida',
        yy : 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

hooks.defineLocale('th', {
    months : '___________'.split('_'),
    monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'), // yes, three characters difference
    weekdaysMin : '._._._._._._.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY  H:mm',
        LLLL : 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd[ ] LT',
        lastDay : '[ ] LT',
        lastWeek : '[]dddd[ ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

hooks.defineLocale('tl-ph', {
    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'MM/D/YYYY',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY HH:mm',
        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar : {
        sameDay: 'LT [ngayong araw]',
        nextDay: '[Bukas ng] LT',
        nextWeek: 'LT [sa susunod na] dddd',
        lastDay: 'LT [kahapon]',
        lastWeek: 'LT [noong nakaraang] dddd',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'sa loob ng %s',
        past : '%s ang nakalipas',
        s : 'ilang segundo',
        m : 'isang minuto',
        mm : '%d minuto',
        h : 'isang oras',
        hh : '%d oras',
        d : 'isang araw',
        dd : '%d araw',
        M : 'isang buwan',
        MM : '%d buwan',
        y : 'isang taon',
        yy : '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

function translateFuture(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'leS' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'waQ' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'nem' :
    time + ' pIq';
    return time;
}

function translatePast(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'Hu' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'wen' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'ben' :
    time + ' ret';
    return time;
}

function translate$9(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);
    switch (string) {
        case 'mm':
            return numberNoun + ' tup';
        case 'hh':
            return numberNoun + ' rep';
        case 'dd':
            return numberNoun + ' jaj';
        case 'MM':
            return numberNoun + ' jar';
        case 'yy':
            return numberNoun + ' DIS';
    }
}

function numberAsNoun(number) {
    var hundred = Math.floor((number % 1000) / 100),
    ten = Math.floor((number % 100) / 10),
    one = number % 10,
    word = '';
    if (hundred > 0) {
        word += numbersNouns[hundred] + 'vatlh';
    }
    if (ten > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
    }
    if (one > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
    }
    return (word === '') ? 'pagh' : word;
}

hooks.defineLocale('tlh', {
    months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact : true,
    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[DaHjaj] LT',
        nextDay: '[waleS] LT',
        nextWeek: 'LLL',
        lastDay: '[waHu] LT',
        lastWeek: 'LLL',
        sameElse: 'L'
    },
    relativeTime : {
        future : translateFuture,
        past : translatePast,
        s : 'puS lup',
        m : 'wa tup',
        mm : translate$9,
        h : 'wa rep',
        hh : translate$9,
        d : 'wa jaj',
        dd : translate$9,
        M : 'wa jar',
        MM : translate$9,
        y : 'wa DIS',
        yy : translate$9
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

var suffixes$3 = {
    1: '\'inci',
    5: '\'inci',
    8: '\'inci',
    70: '\'inci',
    80: '\'inci',
    2: '\'nci',
    7: '\'nci',
    20: '\'nci',
    50: '\'nci',
    3: '\'nc',
    4: '\'nc',
    100: '\'nc',
    6: '\'nc',
    9: '\'uncu',
    10: '\'uncu',
    30: '\'uncu',
    60: '\'nc',
    90: '\'nc'
};

hooks.defineLocale('tr', {
    months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
    weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugn saat] LT',
        nextDay : '[yarn saat] LT',
        nextWeek : '[haftaya] dddd [saat] LT',
        lastDay : '[dn] LT',
        lastWeek : '[geen hafta] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s nce',
        s : 'birka saniye',
        m : 'bir dakika',
        mm : '%d dakika',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gn',
        dd : '%d gn',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir yl',
        yy : '%d yl'
    },
    dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '\'nc';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes$3[a] || suffixes$3[b] || suffixes$3[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun

// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
// This is currently too difficult (maybe even impossible) to add.
hooks.defineLocale('tzl', {
    months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM [dallas] YYYY',
        LLL : 'D. MMMM [dallas] YYYY HH.mm',
        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM : function (input) {
        return 'd\'o' === input.toLowerCase();
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'd\'o' : 'D\'O';
        } else {
            return isLower ? 'd\'a' : 'D\'A';
        }
    },
    calendar : {
        sameDay : '[oxhi ] LT',
        nextDay : '[dem ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ieiri ] LT',
        lastWeek : '[sr el] dddd [lasteu ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'osprei %s',
        past : 'ja%s',
        s : processRelativeTime$7,
        m : processRelativeTime$7,
        mm : processRelativeTime$7,
        h : processRelativeTime$7,
        hh : processRelativeTime$7,
        d : processRelativeTime$7,
        dd : processRelativeTime$7,
        M : processRelativeTime$7,
        MM : processRelativeTime$7,
        y : processRelativeTime$7,
        yy : processRelativeTime$7
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['viensas secunds', '\'iensas secunds'],
        'm': ['\'n mut', '\'iens mut'],
        'mm': [number + ' muts', '' + number + ' muts'],
        'h': ['\'n ora', '\'iensa ora'],
        'hh': [number + ' oras', '' + number + ' oras'],
        'd': ['\'n ziua', '\'iensa ziua'],
        'dd': [number + ' ziuas', '' + number + ' ziuas'],
        'M': ['\'n mes', '\'iens mes'],
        'MM': [number + ' mesen', '' + number + ' mesen'],
        'y': ['\'n ar', '\'iens ar'],
        'yy': [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
}

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

hooks.defineLocale('tzm-latn', {
    months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[asdkh g] LT',
        nextDay: '[aska g] LT',
        nextWeek: 'dddd [g] LT',
        lastDay: '[assant g] LT',
        lastWeek: 'dddd [g] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'dadkh s yan %s',
        past : 'yan %s',
        s : 'imik',
        m : 'minu',
        mm : '%d minu',
        h : 'saa',
        hh : '%d tassain',
        d : 'ass',
        dd : '%d ossan',
        M : 'ayowr',
        MM : '%d iyyirn',
        y : 'asgas',
        yy : '%d isgasn'
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

hooks.defineLocale('tzm', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[ ] LT',
        lastWeek: 'dddd [] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '   %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d o',
        M : 'o',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

function plural$6(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural$4(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else if (key === 'h') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural$6(format[key], +number);
    }
}
function weekdaysCaseReplace(m, format) {
    var weekdays = {
        'nominative': '______'.split('_'),
        'accusative': '______'.split('_'),
        'genitive': '______'.split('_')
    };

    if (!m) {
        return weekdays['nominative'];
    }

    var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
        'accusative' :
        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
            'genitive' :
            'nominative');
    return weekdays[nounCase][m.day()];
}
function processHoursFunction(str) {
    return function () {
        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
}

hooks.defineLocale('uk', {
    months : {
        'format': '___________'.split('_'),
        'standalone': '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : weekdaysCaseReplace,
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: processHoursFunction('[ '),
        nextDay: processHoursFunction('[ '),
        lastDay: processHoursFunction('[ '),
        nextWeek: processHoursFunction('[] dddd ['),
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[] dddd [').call(this);
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural$4,
        mm : relativeTimeWithPlural$4,
        h : '',
        hh : relativeTimeWithPlural$4,
        d : '',
        dd : relativeTimeWithPlural$4,
        M : '',
        MM : relativeTimeWithPlural$4,
        y : '',
        yy : relativeTimeWithPlural$4
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

var months$8 = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var days$2 = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

hooks.defineLocale('ur', {
    months : months$8,
    monthsShort : months$8,
    weekdays : days$2,
    weekdaysShort : days$2,
    weekdaysMin : days$2,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        }
        return '';
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[  ] LT',
        lastWeek : '[] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

hooks.defineLocale('uz-latn', {
    months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[Bugun soat] LT [da]',
        nextDay : '[Ertaga] LT [da]',
        nextWeek : 'dddd [kuni soat] LT [da]',
        lastDay : '[Kecha soat] LT [da]',
        lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'Yaqin %s ichida',
        past : 'Bir necha %s oldin',
        s : 'soniya',
        m : 'bir daqiqa',
        mm : '%d daqiqa',
        h : 'bir soat',
        hh : '%d soat',
        d : 'bir kun',
        dd : '%d kun',
        M : 'bir oy',
        MM : '%d oy',
        y : 'bir yil',
        yy : '%d yil'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

hooks.defineLocale('uz', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT []',
        nextDay : '[] LT []',
        nextWeek : 'dddd [ ] LT []',
        lastDay : '[ ] LT []',
        lastWeek : '[] dddd [ ] LT []',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s ',
        past : '  %s ',
        s : '',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk

hooks.defineLocale('vi', {
    months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
    monthsParseExact : true,
    weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /sa|ch/i,
    isPM : function (input) {
        return /^ch$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'sa' : 'SA';
        } else {
            return isLower ? 'ch' : 'CH';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM [nm] YYYY',
        LLL : 'D MMMM [nm] YYYY HH:mm',
        LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
        l : 'DD/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hm nay lc] LT',
        nextDay: '[Ngy mai lc] LT',
        nextWeek: 'dddd [tun ti lc] LT',
        lastDay: '[Hm qua lc] LT',
        lastWeek: 'dddd [tun ri lc] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s ti',
        past : '%s trc',
        s : 'vi giy',
        m : 'mt pht',
        mm : '%d pht',
        h : 'mt gi',
        hh : '%d gi',
        d : 'mt ngy',
        dd : '%d ngy',
        M : 'mt thng',
        MM : '%d thng',
        y : 'mt nm',
        yy : '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

hooks.defineLocale('x-pseudo', {
    months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact : true,
    weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[T~d~ t] LT',
        nextDay : '[T~m~rr~w t] LT',
        nextWeek : 'dddd [t] LT',
        lastDay : '[~st~rd~ t] LT',
        lastWeek : '[L~st] dddd [t] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '~ %s',
        past : '%s ~g',
        s : ' ~fw ~sc~ds',
        m : ' ~m~t',
        mm : '%d m~~ts',
        h : '~ h~r',
        hh : '%d h~rs',
        d : ' ~d',
        dd : '%d d~s',
        M : ' ~m~th',
        MM : '%d m~t~hs',
        y : ' ~r',
        yy : '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

hooks.defineLocale('yo', {
    months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Oni ni] LT',
        nextDay : '[la ni] LT',
        nextWeek : 'dddd [s ton\'b] [ni] LT',
        lastDay : '[Ana ni] LT',
        lastWeek : 'dddd [s tol] [ni] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ni %s',
        past : '%s kja',
        s : 'isju aaya die',
        m : 'isju kan',
        mm : 'isju %d',
        h : 'wakati kan',
        hh : 'wakati %d',
        d : 'j kan',
        dd : 'j %d',
        M : 'osu kan',
        MM : 'osu %d',
        y : 'dun kan',
        yy : 'dun %d'
    },
    dayOfMonthOrdinalParse : /j\s\d{1,2}/,
    ordinal : 'j %d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4 // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

hooks.defineLocale('zh-cn', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMDAhmm',
        LLLL : 'YYYYMMMDddddAhmm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' ||
                meridiem === '') {
            return hour;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        } else {
            // ''
            return hour >= 11 ? hour : hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    },
    week : {
        // GB/T 7408-1994ISO 8601:1988
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd

hooks.defineLocale('zh-hk', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMD HH:mm',
        LLLL : 'YYYYMMMDdddd HH:mm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

hooks.defineLocale('zh-tw', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMD HH:mm',
        LLLL : 'YYYYMMMDdddd HH:mm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

hooks.locale('en');

return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(208)(module)))

/***/ }),
/* 206 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 207 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["clamp"] = clamp;
/*!
    * Clamp.js 0.5.1
    *
    * Copyright 2011-2013, Joseph Schmitt http://joe.sh
    * Released under the WTFPL license
    * http://sam.zoy.org/wtfpl/
*/

function clamp(element, options) {
    options = options || {};
 
    var self = this,
        win = window,
        opt = {
            clamp:              options.clamp || 1000000,
            useNativeClamp:     typeof(options.useNativeClamp) != 'undefined' ? options.useNativeClamp : true,
            splitOnChars:       options.splitOnChars || ['.', '-', '', '', ' '], //Split on sentences (periods), hypens, en-dashes, em-dashes, and words (spaces).
            animate:            options.animate || false,
            truncationChar:     options.truncationChar || '',
            truncationHTML:     options.truncationHTML
        },
 
        sty = element.style,
        originalText = element.innerHTML,
 
        supportsNativeClamp = typeof(element.style.webkitLineClamp) != 'undefined',
        clampValue = opt.clamp,
        isCSSValue = clampValue.indexOf && (clampValue.indexOf('px') > -1 || clampValue.indexOf('em') > -1),
        truncationHTMLContainer;
        
    if (opt.truncationHTML) {
        truncationHTMLContainer = document.createElement('span');
        truncationHTMLContainer.innerHTML = opt.truncationHTML;
    }
 
 
    // UTILITY FUNCTIONS __________________________________________________________
 
    /**
     * Return the current style for an element.
     * @param {HTMLElement} elem The element to compute.
     * @param {string} prop The style property.
     * @returns {number}
     */
    function computeStyle(elem, prop) {
        if (!win.getComputedStyle) {
            win.getComputedStyle = function(el, pseudo) {
                this.el = el;
                this.getPropertyValue = function(prop) {
                    var re = /(\-([a-z]){1})/g;
                    if (prop == 'float') prop = 'styleFloat';
                    if (re.test(prop)) {
                        prop = prop.replace(re, function () {
                            return arguments[2].toUpperCase();
                        });
                    }
                    return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;
                }
                return this;
            }
        }
 
        return win.getComputedStyle(elem, null).getPropertyValue(prop);
    }
 
    /**
     * Returns the maximum number of lines of text that should be rendered based
     * on the current height of the element and the line-height of the text.
     */
    function getMaxLines(height) {
        var availHeight = height || element.clientHeight,
            lineHeight = getLineHeight(element);
 
        return Math.max(Math.floor(availHeight/lineHeight), 0);
    }
 
    /**
     * Returns the maximum height a given element should have based on the line-
     * height of the text and the given clamp value.
     */
    function getMaxHeight(clmp) {
        var lineHeight = getLineHeight(element);
        return lineHeight * clmp;
    }
 
    /**
     * Returns the line-height of an element as an integer.
     */
    function getLineHeight(elem) {
        var lh = computeStyle(elem, 'line-height');
        if (lh == 'normal') {
            // Normal line heights vary from browser to browser. The spec recommends
            // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.
            lh = parseInt(computeStyle(elem, 'font-size')) * 1.2;
        }
        return parseInt(lh);
    }
 
 
    // MEAT AND POTATOES (MMMM, POTATOES...) ______________________________________
    var splitOnChars = opt.splitOnChars.slice(0),
        splitChar = splitOnChars[0],
        chunks,
        lastChunk;
    
    /**
     * Gets an element's last child. That may be another node or a node's contents.
     */
    function getLastChild(elem) {
        //Current element has children, need to go deeper and get last child as a text node
        if (elem.lastChild.children && elem.lastChild.children.length > 0) {
            return getLastChild(Array.prototype.slice.call(elem.children).pop());
        }
        //This is the absolute last child, a text node, but something's wrong with it. Remove it and keep trying
        else if (!elem.lastChild || !elem.lastChild.nodeValue || elem.lastChild.nodeValue == '' || elem.lastChild.nodeValue == opt.truncationChar) {
            elem.lastChild.parentNode.removeChild(elem.lastChild);
            return getLastChild(element);
        }
        //This is the last child we want, return it
        else {
            return elem.lastChild;
        }
    }
    
    /**
     * Removes one character at a time from the text until its width or
     * height is beneath the passed-in max param.
     */
    function truncate(target, maxHeight) {
        if (!maxHeight) {return;}
        
        /**
         * Resets global variables.
         */
        function reset() {
            splitOnChars = opt.splitOnChars.slice(0);
            splitChar = splitOnChars[0];
            chunks = null;
            lastChunk = null;
        }
        
        var nodeValue = target.nodeValue.replace(opt.truncationChar, '');
        
        //Grab the next chunks
        if (!chunks) {
            //If there are more characters to try, grab the next one
            if (splitOnChars.length > 0) {
                splitChar = splitOnChars.shift();
            }
            //No characters to chunk by. Go character-by-character
            else {
                splitChar = '';
            }
            
            chunks = nodeValue.split(splitChar);
        }
        
        //If there are chunks left to remove, remove the last one and see if
        // the nodeValue fits.
        if (chunks.length > 1) {
            // console.log('chunks', chunks);
            lastChunk = chunks.pop();
            // console.log('lastChunk', lastChunk);
            applyEllipsis(target, chunks.join(splitChar));
        }
        //No more chunks can be removed using this character
        else {
            chunks = null;
        }
        
        //Insert the custom HTML before the truncation character
        if (truncationHTMLContainer) {
            target.nodeValue = target.nodeValue.replace(opt.truncationChar, '');
            element.innerHTML = target.nodeValue + ' ' + truncationHTMLContainer.innerHTML + opt.truncationChar;
        }
 
        //Search produced valid chunks
        if (chunks) {
            //It fits
            if (element.clientHeight <= maxHeight) {
                //There's still more characters to try splitting on, not quite done yet
                if (splitOnChars.length >= 0 && splitChar != '') {
                    applyEllipsis(target, chunks.join(splitChar) + splitChar + lastChunk);
                    chunks = null;
                }
                //Finished!
                else {
                    return element.innerHTML;
                }
            }
        }
        //No valid chunks produced
        else {
            //No valid chunks even when splitting by letter, time to move
            //on to the next node
            if (splitChar == '') {
                applyEllipsis(target, '');
                target = getLastChild(element);
                
                reset();
            }
        }
        
        //If you get here it means still too big, let's keep truncating
        if (opt.animate) {
            setTimeout(function() {
                truncate(target, maxHeight);
            }, opt.animate === true ? 10 : opt.animate);
        }
        else {
            return truncate(target, maxHeight);
        }
    }
    
    function applyEllipsis(elem, str) {
        elem.nodeValue = str + opt.truncationChar;
    }
 
 
    // CONSTRUCTOR ________________________________________________________________
    if (clampValue == 'auto') {
        clampValue = getMaxLines();
    }
    else if (isCSSValue) {
        clampValue = getMaxLines(parseInt(clampValue));
    }
 
    var clampedText;
    if (supportsNativeClamp && opt.useNativeClamp) {
        sty.overflow = 'hidden';
        sty.textOverflow = 'ellipsis';
        sty.webkitBoxOrient = 'vertical';
        sty.display = '-webkit-box';
        sty.webkitLineClamp = clampValue;
 
        if (isCSSValue) {
            sty.height = opt.clamp + 'px';
        }
    }
    else {
        var height = getMaxHeight(clampValue);
        if (height <= element.clientHeight) {
            clampedText = truncate(getLastChild(element), height);
        }
    }
    
    return {
        'original': originalText,
        'clamped': clampedText
    }
 }

/***/ }),
/* 210 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(3);
__webpack_require__(67);
__webpack_require__(36);
__webpack_require__(37);
__webpack_require__(38);
__webpack_require__(39);
__webpack_require__(40);
__webpack_require__(29);
__webpack_require__(41);
__webpack_require__(68);
module.exports = __webpack_require__(69);


/***/ })
/******/ ]);